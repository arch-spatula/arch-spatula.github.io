---
sidebar_position: 3
tags: ['data type', 'core', 'memory', 'JavaScript']
draft: true
---

# 자료형(Data Type)

:::danger 경고

교육과정에서 내용을 듣고 정리한 필기자료입니다.

교육과정에서는 정재남 선생님의 코어자바스크립트를 활용한 것으로 추측합니다. 그래서 책의 내용을 보면 많이 겹칠 것입니다.

:::

다음 내용은 자바스크립트 자료형을 다룰 것이지만 자료형에 따라 자바스크립트가 메모리에 할당하는 방식을 설명하겠습니다.

## tl;dr

- 참조형은 원시형의 묶음으로 생각하면 쉬워집니다.
- 참조형 자체에 대한 메모리 주소는 자바스크립트 특성상 주의하지 않으면 불변성을 보장하기 어렵습니다.
- 참조형은 동일한 메모리 주소를 바라보고 있기 때문에 의도하지 않은 데이터 변환을 가할 수 있습니다.

## 데이터 타입의 종류

자료형은 원시형과 참조형 2가지가 존재합니다. 참조형은 다른 값들을 참조하고 있는 데이터 타입입니다.

> 원시형 `number`, `string`, `boolean`, `null`, `undefined`, `symbol`

> 참조형 `array`, `function`, `Date`, `RegExp`, `Map`, `Set`, `WeakMap`, `WeakSet`

기본형과 참조형을 나누는 기준은 복제방식입니다. 원시형은 값이 담긴 주소를 바로 복제합니다. 값을 복제하는 것이 아니라 주솟값을 복제합니다.

값이 담긴 주솟값들로 이루어진 묶음을 가리키는 주솟값을 복제합니다. 식별자는 주솟값의 묶음을 참조하고 수좃값의 묶음이 다른 주솟값들을 복제합니다.

```js
a = [1, 2, 3, 4, 5];
```

`a`는 원시형 `1`, `2`, `3`, `4`, `5` 주소들의 묶음(`[]`)을 참조하는 방식입니다.

또 기본형은 불변입니다. 하지만 참조형은 가변형입니다.

메모리 구조를 식별자는 새로운 주소를 바라만 보면 값 자체는 변하지 않습니다. 하지만 참조형은 주소의 묶음이 변하기 때문에 가변형이라고 합니다.

컴퓨터는 비트로 말합니다. 가장 작은 메모리 조각은 0, 1로 구성된 것입니다. 비트는 작은 메모리 조각입니다. 비트들의 합은 메모리가 됩니다.

메모리의 의미를 파악해봅시다. 기억, 저장입니다. 비트는 메모리 조각입니다. 비트는 하나하나 각각 식별자를 갖습니다. 메모리는 모든 식별자의 모음입니다. 특정 식별자를 찾기 위해서는 메모리 전체를 찾아야 합니다. 하지만 0, 1만으로 찾는 것은 상당히 비효율적인 작업입니다. 그래서 비트로 묶어서 작업하기 시작합니다. 하지만 너무 작은 값에 큰 비트를 할당하는 것도 비효율적입니다. 대략 8비트가 효율적입니다.

모어의 법칙에 맞게 하드웨어 성능이 시간이 지날수록 좋아졌습니다. 하지만 과거 메모리 성능이 안 좋았던 시대에는 메모리 관리를 많이 해야 했습니다.

자바스크립트는 식별자에 값을 할당하고 메모리에 저장하고 간단하게 끝납니다. 하지만 자바는 다양한 저장 방식을 제공합니다. 자바는 `byte`, `short`, `int`, `long`으로 저장합니다. 자바는 메모리 저장방식으로 관리하지만 자바스크립트는 딱히 관리하지 않습니다. 자바스크립트는 좋은 시대에서 사용할 수 있는 언어입니다.

## 식별자와 변수

식별자와 변수입니다. 변수를 이상하게 생각하는 사람이 많습니다.

```js
let testValue = 3;
```

여기서 `testValue`는 식별자입니다. 3은 데이터이고 값이고 변수입니다.

모든 데이터는 바이트 단위입니다. 비트는 너무작아서 비효율적이고 바이트는 적당합니다. 바이트 단위로 저장한다는 것은 이해를 못하면 외우기라도 합니다.

## 데이터 할당

자바스크립트가 식별자에 데이터를 할당하는 방식을 다룹니다. 변수란 변할 수 있는 데이터 담긴 식별자입니다.

```js
let testValue = 'test value!';
```

testValue는 할당하는 데이터가 업데이트될 수 있습니다.

```js
let testValue;
let testValue = 'test value!';
```

식별자는 먼저 정의하고 다음에 식별자에 값을 할당하는 방식입니다.

<!-- TODO: FigJam으로 다이어그램 정리 -->

| 주소   | …   | 1002                      | 1003 | 1004 | 1005 | …   |
| ------ | --- | ------------------------- | ---- | ---- | ---- | --- |
| 데이터 |     | `식별자: testValue` @5004 |      |      |      |     |

| 주소   | …   | 5002 | 5003 | 5004         | 5005 | …   |
| ------ | --- | ---- | ---- | ------------ | ---- | --- |
| 데이터 |     |      |      | `test value` |      |     |

식별자를 정의하는 순간 메모리에 비어있는 공간을 찾습니다.

식별자가 주소를 담고 주소로 데이터를 찾아가는 방식입니다. 바로 보면 비효율적으로 보입니다. 이렇게 하는 이유는 다양합니다. 하나는 자유로운 데이터 변환이 가능하도록 합니다. 주소만 바꾸면 되기 때문에 식별자의 데이터를 쉽게 바꿀 수 있습니다. 다른 하나는 메모리관리가 효율적입니다.

숫자는 8바이트입니다. 영어는 1글자에 1바이트 한글은 1글자에 2바이트입니다.

메모리공간에서 만약에 새로운 데이터가 생성되면 데이터 주소를 연속으로 한 칸식 밀어줘야 합니다. 상당히 비효율적입니다. 하지만 할당은 효율적입니다.

만약에 값이 동일한 숫자를 800번 저장하면 매번 메모리에 공간을 확보해야 합니다. 숫자 1글자는 8바이트면 `8*800(6400)` 바이트가 필요합니다. 하지만 식별자 바이트가 2바이트고 숫자 1개 8바이트만 사용하면 `2*800+8(1608)` 바이트가 필요합니다. 여러개의 식별자가 동일한 주솟값을 갖고 있는 구조입니다.

더 좋은 설명

```js
// 변수명(=식별자)과, 실제 그 변수에 할당된 데이터(값)는 구분이 필요해요!!
var a = 3; // 이라고 했을 때,
// var a를 저장하는 크기 -> 2byte(예를 들어)
// 3을 저장하는 크기 -> 8byte
// 로 이해하는게 좀 더 맞아요!
// 그래서
var a = 3;
var b = 3; // 을 했을 때
// a와 b를 위한 공간 각각 2바이트 -> 총 4바이트
// 그리구 3을 저장하기 위한 공간 8바이트
```

## 기본형 데이터와 참조형 데이터

변수와 상수입니다. 변수와 상수를 구분하는 것은 변경 가능성입니다. 변경이 가능하면 변수이고 불가능하면 상수입니다. 변수와 상수를 구분하는 것을 변수 데이터의 식별자 값의 가변성입니다. 불변성을 구분하는 것은 변수의 값이 바뀔 수 있는가가 아니라 데이터 영역의 메모리가 바뀔 수 있고 없고입니다.

```js
let a = 'abc';
a += 'def';
```

위와 같은 코드를 표현하면 아래와 같습니다. 식별자 a는 메모리 주소 `@5003`에서 `@5004`를 바라보게 되는 것입니다. `@5003`의 데이터를 업데이트할 것이라고 많이 착각하는데 아니고 새로운 값을 메모리에 할당하고 새로 할당된 메모리 주소를 바라보게 식별자의 주소를 업데이트하는 방식입니다.

| 주소   | …   | 1002              | 1003 | 1004 | 1005 | …   |
| ------ | --- | ----------------- | ---- | ---- | ---- | --- |
| 데이터 |     | `식별자: a` @5004 |      |      |      |     |

| 주소   | …   | 5002 | 5003  | 5004     | 5005 | …   |
| ------ | --- | ---- | ----- | -------- | ---- | --- |
| 데이터 |     |      | `abc` | `abcdef` |      |     |

메모리에서 식별자 영역과 데이터 영역에서 데이터 영역은 새로운 데이터만 공간을 확보하고 기존 데이터는 변화가 없습니다.

불변성은 식별자 영역이 아니라 데이터 영역입니다. 데이터 영역의 가변성 및 불변성에 대한 것입니다.

## 가비지컬렉팅

가비지컬렉팅입니다. 가비지는 메모리에서 참조하지 않는 데이터입니다. 가비지를 컬랙팅하는 주체는 프로그램입니다. 위 예시에서 `abc`는 참조 카운트가 0이기 때문에 수거대상이 됩니다.

원시형은 불변, 참조형은 가변입니다. 참조형이 가변적이기 때문에 다양한 문제가 발생합니다.

```js
let obj1 = {
  a: 1,
  b: `abc`,
};
```

위 값은 참조형입니다.

| 주소   | …   | 1002                   | 1003 | 1004 | 1005 | …   |
| ------ | --- | ---------------------- | ---- | ---- | ---- | --- |
| 데이터 |     | `식별자: obj1` @5002 ~ |      |      |      |     |

| 주소   | …   | 5002          | 5003 | 5004  | 5005 | …   |
| ------ | --- | ------------- | ---- | ----- | ---- | --- |
| 데이터 |     | @7002 ~ @7003 | 1    | `abc` |      |     |

| 주소   | …   | 7002                      | 7003                      | 7004 | 7005 | …   |
| ------ | --- | ------------------------- | ------------------------- | ---- | ---- | --- |
| 데이터 |     | `프로퍼티 식별자 a` @5003 | `프로퍼티 식별자 b` @5004 |      |      |     |

원시형은 객체를 위 프로퍼티영역이 존재하지 않았습니다. 하지만 참조형은 층 1개가 더 있는 것입니다. 그리고 식별자가 메모리 주소를 1개 이상 갖고 있습니다.

참조형은 가변적입니다.

```js
let obj1 = {
  a: 1,
  b: `abc`,
};

obj1.a = 2;
```

위 값은 참조형입니다.

| 주소   | …   | 1002                   | 1003 | 1004 | 1005 | …   |
| ------ | --- | ---------------------- | ---- | ---- | ---- | --- |
| 데이터 |     | `식별자: obj1` @5002 ~ |      |      |      |     |

| 주소   | …   | 5002          | 5003 | 5004  | 5005 | …   |
| ------ | --- | ------------- | ---- | ----- | ---- | --- |
| 데이터 |     | @7002 ~ @7003 | 1    | `abc` | 2    |     |

| 주소   | …   | 7002                      | 7003                      | 7004 | 7005 | …   |
| ------ | --- | ------------------------- | ------------------------- | ---- | ---- | --- |
| 데이터 |     | `프로퍼티 식별자 a` @5005 | `프로퍼티 식별자 b` @5004 |      |      |     |

없으면 데이터 영역 주소에 새롭게 만들고 `@5003`에서 `@5005`로 업데이트합니다. 데이터 영역이 바뀌는 것은 불변성 식별자의 변수 영역이 상수 변수를 구분합니다.

변수 복사입니다.

```js
//기본형 데이터
var a = 10;
var b = a;

//참조형 데이터
var obj1 = { c: 10, d: 'ddd' };
var obj2 = obj1;

b = 15;
obj2.c = 20;
```

| 주소   | …   | 1002              | 1003 | 1004                 | 1005 | …   |
| ------ | --- | ----------------- | ---- | -------------------- | ---- | --- |
| 데이터 |     | `식별자: a` @5002 |      | `식별자: obj1` @5004 |      |     |

| 주소   | …   | 5002 | 5003  | 5004          | 5005 | …   |
| ------ | --- | ---- | ----- | ------------- | ---- | --- |
| 데이터 |     | 10   | `ddd` | @7002 ~ @7003 |      |     |

| 주소   | …   | 7002                       | 7003                       | 7004 | 7005 | …   |
| ------ | --- | -------------------------- | -------------------------- | ---- | ---- | --- |
| 데이터 |     | `프로퍼티 식별자: c` @5002 | `프로퍼티 식별자: d` @5003 |      |      |     |

여기까지는 배운 내용 복습니다. 이제 값을 복사하는 영역입니다.

| 주소   | …   | 1002              | 1003              | 1004                   | 1005                 | …   |
| ------ | --- | ----------------- | ----------------- | ---------------------- | -------------------- | --- |
| 데이터 |     | `식별자: a` @5002 | `식별자: b` @5001 | `식별자: obj1` @5004 ~ | `식별자: obj2` @5004 |     |

| 주소   | …   | 5002 | 5003  | 5004          | 5005 | …   |
| ------ | --- | ---- | ----- | ------------- | ---- | --- |
| 데이터 |     | 10   | `ddd` | @7002 ~ @7003 |      |     |

| 주소   | …   | 7002                       | 7003                       | 7004 | 7005 | …   |
| ------ | --- | -------------------------- | -------------------------- | ---- | ---- | --- |
| 데이터 |     | `프로퍼티 식별자: c` @5002 | `프로퍼티 식별자: d` @5003 |      |      |     |

원시형을 복사할 때는 간단하게 바라보는 주소만 동일하게 만듭니다. 참조형도 원시형처럼 주소를 복사합니다. 하지만 `b = 15;`과 `obj2.c = 20;`으로 재할당하는 방식입니다.

| 주소   | …   | 1002              | 1003              | 1004                 | 1005                 | …   |
| ------ | --- | ----------------- | ----------------- | -------------------- | -------------------- | --- |
| 데이터 |     | `식별자: a` @5002 | `식별자: b` @5004 | `식별자: obj1` @5006 | `식별자: obj2` @5006 |     |

| 주소   | …   | 5002 | 5003  | 5004 | 5005 | 5006          | 5007 … |
| ------ | --- | ---- | ----- | ---- | ---- | ------------- | ------ | --- |
| 데이터 |     | 10   | `ddd` | 15   | 20   | @7002 ~ @7003 |        |     |

| 주소   | …   | 7002                       | 7003                       | 7004 | 7005 | …   |
| ------ | --- | -------------------------- | -------------------------- | ---- | ---- | --- |
| 데이터 |     | `프로퍼티 식별자: c` @5005 | `프로퍼티 식별자: d` @5003 |      |      |     |

원시형은 `15`를 `@5004`에 새롭게 공간을 확보하고 `b` 식별자의 주소를 업데이트합니다. 하지만 참조형 데이터의 복사는 조금 다릅니다. `20`은 새롭게 공간을 `@5005`에 확보합니다. 그리고 `c`프로퍼티 식별자의 주소는 `20`을 바라봅니다.

```js
a === b; // false
obj1 === obj2; // true
```

이렇게 된 이유는 참조형의 메모리 영역에서 프로퍼티 식별자(예: `obj1.a`)의 주소를 업데이트하는데 참조형 식별자(`obj1`)의 주소는 그대로이기 때문입니다. 이런 점이 자바스크립트의 단점입니다. 원시형처럼 개별 객체가 되는 것이 당연할 것이라고 생각하지만 아닙니다. `obj2`을 변경했지만 `obj1`도 같이 변하게 되었습니다. 의도하면 괜찮지만 의도하지 않으면 엄청난 사이드이팩트가 됩니다.

당연히 해결방법도 존재합니다. `obj2`를 할당 할 때 참조형인 주소의 묶음이 개별적인 존재로 할당하는 전략입니다.

```js
var obj1 = { c: 10, d: 'ddd' };
var obj2 = { c: 20, d: 'ddd' };
```

이렇게 정의하면 식별자는 각각 다른 주소의 묶음을 바라봅니다.

## 불변 객체

불변객체는 가변일수밖에 없는 참조형 자료형의 문제가 있습니다. 이런 것을 제거하기 위해서 탄생했습니다.

```js
var user = {
  name: 'fin',
  gender: 'male',
};
var changeName = function (user, newName) {
  var newUser = user;
  newUser.name = newName;
  return newUser; // 기존 객체
};
var user2 = changeName(user, 'jake');
if (user !== user2) {
  console.log('유저 정보가 변경되었습니다.');
}

console.log(user.name, user2.name); // jake jake
console.log(user === user2); // true
```

위 `changeName` 함수는 첫번째 인자로 객체를 받고 두번째 인자는 프로퍼티의 값을 업데이트할 자료를 넣습니다. 현재 `user` 객체는 가변객체입니다. 그래서 복사한 식별자의 데이터에 변형을 가했더니 원본에도 영향을 줍니다.

이런 문제를 해결하기 위한 전략입니다.

```js
var user = {
  name: 'fin',
  gender: 'male',
};
var changeName = function (user, newName) {
  return {
    // 새로운 객체
    name: newName,
    gender: user.gender,
  };
};
var user2 = changeName(user, 'jake');
if (user !== user2) {
  console.log('유저 정보가 변경되었습니다.');
}
console.log(user.name, user2.name); // fin jake
console.log(user === user2); // false
```

새로운 객체를 반환한 상태로 식별자에 할당하면서 동일한 객체 문제를 해결할 수 있습니다.

하지만 문제가 여전히 있습니다. 만약에 프로퍼티가 1억개면 일일이 작성해야 합니다. 위 코드는 문제를 해결하지만 상당히 비효율적인 코드입니다. 유지보수 측면에서 상당히 나쁜 코드입니다.

```js
//이런 패턴은 어떨까요?
var copyObject = function (target) {
  var result = {};
  for (var prop in target) {
    result[prop] = target[prop];
  }
  return result;
};

//위 패턴을 우리 예제에 적용해봅시다.
var user = {
  name: 'fin',
  gender: 'male',
};
var user2 = copyObject(user);
user2.name = 'jake';
if (user !== user2) {
  console.log('유저 정보가 변경되었습니다.');
}
console.log(user.name, user2.name); // fin jake
console.log(user === user2); // false
```

이렇게 작성하면 아까보다 더 좋은 코드입니다. 프로퍼티 1억개 문제를 해결했습니다. 다음 문제는 깊은 복사 얕은 복사 문제입니다.

현재는 참조형이 원시형들을 참조하고 있습니다. 만약에 참조형 속에 참조형을 참조하는 구조이면 문제가 발생합니다. 깊은 복사가 얼마나 깊을지 모르는 경우까지 해결해줘야 합니다. 이런 개념을 보고 얕은 복사와 깊은 복사라고 합니다.

얕은 복사는 참조형의 바로 아래 속한 값들입니다.

```js
a = [1, 2, 3];
```

문제는 참조형 데이터가 프로퍼티를 복사할 때 주소만 복사합니다.

깊은 복사는 내부의 모든 값을 하나하나 다 찾아 모두 복사합니다. 이런 깊은 복사를 구현하기 위한 전략은 재귀함수가 있습니다.

```js
var user = {
  name: 'jake',
  urls: {
    portfolio: 'http://github.com/jake',
    blog: 'http://blog.com/jake',
    facebook: 'http://facebook.com/jake',
  },
};
var user2 = copyObject(user);
user2.urls = copyObject(user.urls);
user.urls.portfolio = 'http://portfolio.com';
console.log(user.urls.portfolio === user2.urls.portfolio);
user2.urls.blog = '';
console.log(user.urls.blog === user2.urls.blog);
```

이런 전략은 하드코딩입니다. 권장하지 않습니다.

```js
var copyObjectDeep = function (target) {
  var result = {};
  if (typeof target === 'object' && target !== null) {
    for (var prop in target) {
      result[prop] = copyObjectDeep(target[prop]);
    }
  } else {
    result = target;
  }
  return result;
};
//결과 확인
var obj = {
  a: 1,
  b: {
    c: null,
    d: [1, 2],
  },
};
var obj2 = copyObjectDeep(obj);
obj2.a = 3;
obj2.b.c = 4;
obj2.b.d[1] = 3;
console.log(obj); // { a: 1, b: { c: null, d: [ 1, 2 ] } }
console.log(obj2); // { a: 3, b: { c: 4, d: { '0': 1, '1': 3 } } }
```

위 코드는 재귀함수로 객체형을 판단합니다. 하지만 참조형이면 객체형으로 판단합니다. 참고로 `array`와 `null`도 객체형으로 자바스크립트가 판단합니다. 재귀함수로 또 호출하게 되는 구조입니다. 만약에 객체형이 아니면 반환값을 바로 할당하는 방식으로 동작합니다.

더 쉬운 방법은 JSON으로 다루는 것입니다. 당연히 단점도 있습니다.

```js
const obj1 = {
  a: 1,
  b: 'string',
  c: {
    name: 'Leon',
    age: '29',
  },
};

// Deep Copy 방법
const obj2 = JSON.parse(JSON.stringify(obj1));
```

이렇게 작성하면 성능이슈가 심각하지만 코드 자체는 엄청 단순해집니다.

### structuredClone

최근에 자바스크립트 내장함수로 `structuredClone` 즉 깊은 복사 함수를 지원하기 시작했습니다.[^1] 그래서 면접용 라이브 코딩 이외 일반적인 상황에서는 복사 재귀함수를 작성할 필요는 없습니다.

```js
//결과 확인
var obj = {
  a: 1,
  b: {
    c: null,
    d: [1, 2],
  },
};
var obj2 = structuredClone(obj);
obj2.a = 3;
obj2.b.c = 4;
obj2.b.d[1] = 3;
console.log(obj); // { a: 1, b: { c: null, d: [ 1, 2 ] } }
console.log(obj2); // { a: 3, b: { c: 4, d: { '0': 1, '1': 3 } } }
```

## undefined와 null

`undefined`와 `null` 모두 없음을 의미합니다.

```js
let a = undefined;
```

이렇게 작성하는 것은 당연히 바람직하지 못합니다.

```js
let a;
console.log(a); // undefined
```

이렇게 동작하기 때문에 `undefined`을 할당할 필요가 없습니다.

```js
let obj1 = { a: 1 };
console.log(obj1.a); // 1
console.log(obj1.b); // undefined

// console.log(b) // 참조 오류

var func = function () {};
var c = func();
console.log(c); // undefined
```

```js
/** empty element와, undefined를 할당한 element는 다른거에요! */
var arr1 = [];
arr1.length = 3;
console.log(arr1); // [ <3 empty items> ]
var arr2 = new Array(3);
console.log(arr2); // [ <3 empty items> ]
var arr3 = [undefined, undefined, undefined];
console.log(arr3); // [ undefined, undefined, undefined ]
```

`undefined`도 자료형으로 분류됩니다. 그래서 출력이 됩니다. 비어있는것과 없다는 것은 다른 의미입니다.

고차함수 배열 메서드는 `empty`는 skip합니다. 하지만 `undefined`은 수행합니다.

`undefined`는 할당한 것인지 자바스크립트가 반환해준 것인지 구분하기 어렵습니다. 그래서 없음을 명시할 때는 `null`로 지정하는 것이 많이 있습니다. 하지만 `null`에서 중요한점은 `null`은 객체가 되기 때문입니다.

```js
let var1 = null;
if (typeof var1 === 'object' && var1 === null) {
  console.log(var1);
}
```

이렇게 다루는 것도 하나의 전략입니다.

```js
var n = null;
console.log(typeof n); // object
//동등연산자(equality operator)
console.log(n == undefined); // true
console.log(n == null); // true
//일치연산자(identity operator)
console.log(n === undefined); // false
console.log(n === null); // true
```

`null`은 객체로 자바스크립트가 판단하기 때문에 주의가 필요합니다.

[^1]: [structuredClone - MDN](https://developer.mozilla.org/en-US/docs/Web/API/structuredClone)
