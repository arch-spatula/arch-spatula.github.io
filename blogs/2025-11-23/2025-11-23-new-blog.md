---
title: '2025년 블로그 재단장하기 2편'
authors: [arch-spatula]
tags: ['node.js', 'template']
description: 'build를 처리하는 방법'
date: 2025-11-23
---

<!--
@todo:
-->

## 빌드 로직

- 지금 읽고 있는 내용들은 절대 선형적으로 작성된 것이 아닙니다. 대부분의 개발은 이 글을 읽고 있는 사람도 경험해봤듯이 순환적입니다. 가장 단순하고 작은 최소한의 빌드 로직에서 점차 기능을 붙여나간 방식입니다.
- 빌드 로직에서 제일 중요한 부분이 있다면 그것은 템플릿처리 로직입니다. 템플릿처리를 위해 라이브러리를 설치할 수 있었지만 저는 극도로 단순해서 AI보고 만들어달라고 했습니다.
- 빌드와 관련 된 모든 내용은 github 레포에 [build를 위해 만들어둔 스크립트](https://github.com/arch-spatula/arch-spatula.github.io/blob/dev/app/build.ts)에서 확인하실 수 있습니다.
  - 많은 로직은 opus의 힘을 빌려 작성했습니다.
  - 템플릿처리를 해야겠다는 생각은 제가 했습니다.
- 최대한 숨겨진 제어흐름이 발생하지 않게 만들기 위해 1번 실행할 함수로 만들었습니다.

<!-- - 로직의 가장 핵심은 3계층 구조가 됩니다. 마크다운 파일들을 읽고 처리하고 html로 저장하는 것이 본질입니다. 하지만 블로그의 편의 기능과 메타정보를 위해 겹겹이 로직을 감쌓았습니다. -->
<!-- - 가능하면 build라는 로직을 직접 테스트하지 않고 의존하는 함수를 테스트하고자 했습니다. -->

## build 로직

```ts
/**
 * 길어서 생략
 */
const build = async () => {
  // 길어서 생략
};

build();
```

- 최종 배포는 `build.ts`에서 `build` 함수 1개만 실행하도록 하는 것이 설계 의도입니다. 모든 것은 질렬적으로 추상화 없이 해결되어야 합니다.

<!--

- 이 함수는 단위 테스트코드로 테스트하지 않습니다. 그렇게 하는 것은 가능해도 playwright 테스트할 때 의미를 갖을 것입니다.
아주 단순한 파일 읽기, 데이터 처리, 파일 쓰기 수준이 되게 만들고 했습니다.

-->

```json
{
  // ... 생략
  "scripts": {
    "build": "tsx app/build.ts"
    // ... 생략
  }
}
```

- 단순하게 단 하나의 함수를 실행하고 모든 것을 dist 파일로 저장하게 만드는 것이 의도입니다.

## 템플릿 로직

- 템플릿을 어떻게 처리할지 의문이 많이 있었습니다. 예전에 [ejs](https://ejs.co/)라는 것을 알게 되어서 [express](https://expressjs.com/ko/)로 서버에서 html을 생성해서 응답한다는 것을 줍줍한 것이 있습니다. 하지만 너무 오래된 기술이라 거부감이 있었습니다.
- `handlebars.js`라는 것을 알게되었습니다. ~~사실 AI에게 질문했습니다.~~ 템플릿처리를 해주는 라이브러리라고 합니다.
  - [공식 문서](https://handlebarsjs.com/)를 조사하다가 [템플릿의 표준 비슷한 것](https://mustache.github.io/mustache.5.html)을 발견했습니다. RFC 표준은 전혀 아닙니다.

```txt
hello {{foo}}!
```

```json
{ "foo": "world" }
```

- 위처럼 템플릿 문자열에 json 데이터를 넣으면 `hello world!`가 출력되게 만드는 것이 핵심입니다. 이런 저런 다양한 표현이 있습니다.

```txt
{{#if light}}
  let there be light
{{/if light}}
```

```json
{ "light": false }
```

- 위는 공식 문서의 표현이 아닙니다. 공식 문서의 경우 `{{#light}} {{/light}}`으로 표현해야 합니다.
  - 저는 공식문서에서 이렇게 표현하는 것이 명확하지 않다고 보고 있습니다. 단순히 문자열을 받을지 부울을 받을지 배열처럼 연속된 정보를 받을지 너무 자유롭다고 봅니다.
  - handlebars.js의 경우 `with`로 처리하고 있습니다.
- 지금 템플릿 로직으로 처리된 결과는 빈문자열(`""`)이 나와야 합니다.

```txt
{{#each adventureTime}}
  {{name}} the {{ethnicity}}
{{/each}}
```

```json
{
  "adventureTime": [
    { "name": "Jake", "ethnicity": "Dog" },
    { "name": "Finn", "ethnicity": "Human" }
  ]
}
```

```txt
Jake the Dog
Finn The Human
```

- 위는 목록처럼 연속된 템플릿입니다. 참고로 중첩구조를 자질 수 있습니다.

## 템플릿 파일

- 실제로 1번만 읽으면 되는 파일을 초기화할 때 호출합니다. 데이터 사이즈도 별로 안 커서 메모리에서 계속 읽기만 하면 됩니다.

```ts
const appTemplate = await readFile(join(process.cwd(), 'app', 'templates', 'app.html'), 'utf8');
const postTemplate = await readFile(join(process.cwd(), 'app', 'templates', 'post.html'), 'utf8');
const mainTemplate = await readFile(join(process.cwd(), 'app', 'templates', 'main.html'), 'utf8');
const searchTemplate = await readFile(join(process.cwd(), 'app', 'templates', 'search.html'), 'utf8');
```

- 위 4개의 파일을 모두 읽기만 합니다.
- 루트역할을 하고 모든 내용을 받을 것은 `appTemplate`입니다.
- `appTemplate`은 `searchTemplate`을 모두 받습니다. 또 조건부로 `postTemplate` 혹은 `mainTemplate`을 받아야 합니다.

```html
<!doctype html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/logo.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="/style.css" />
    <title>Arch-Spatula의 개발 레시피{{title}}</title>
    <meta name="description" content="{{description}}" />
    <meta name="tags" content="{{tags}}" />
    <meta name="authors" content="{{authors}}" />
    <meta name="date" content="{{date}}" />
  </head>
  <body>
    <nav id="nav">
      <ul>
        <li class="blog-logo-container">
          <a class="blog-logo" href="/"
            ><img class="logo-img" src="/profile.png" alt="blog logo" />
            <p>home</p></a
          >
        </li>
        <li>
          <button id="popup-btn">
            <img class="icon" src="/search.svg" alt="search" />
            <p class="popup-text">Ctrl + k</p>
          </button>
        </li>
        <li class="github-link">
          <a href="https://github.com/arch-spatula/arch-spatula.github.io" target="_blank">GitHub</a>
        </li>
      </ul>
    </nav>
    <div id="app">{{body}}</div>
    <div id="search" class="hidden">{{search}}</div>
    <footer class="footer"></footer>
    <script src="/script.js"></script>
  </body>
</html>
```

- 여기서 동적으로 바꿔 줄 것은 `{{title}}`, `{{body}}`, `{{search}}`입니다. 즉 루트 역할을 해야 합니다.
- `{{title}}`은 블로그 글 제목에 따라 조건부로 처리되어야 합니다.
  - 있으면 `Arch-Spatula의 개발 레시피 - foo bar baz`처럼 작성되어야 합니다.
  - 없으면 `Arch-Spatula의 개발 레시피`으로 작성되어야 합니다.
- `{{body}}`는 조건부로 처리됩니다.
  - `index.html`의 경우 게시글을 볼 수 있는 목록이 됩니다.
  - `2025-11-23-new-blog.html`의 경우 마크다운을 처리한 내용을 볼 수 있습니다.

```html
<div id="search-popup">
  <div id="popup-container">
    <form id="search-form">
      <img id="search-icon" src="/search.svg" alt="search" /><input
        id="search-input"
        type="search"
        name="search-input"
        placeholder="Search"
        autocomplete="off"
      />
      <div></div>
    </form>
    <ul id="search-tag-list">
      {{#each tags}}
      <li class="search-tag-item">
        <a class="tag-link" href="#" data-tag="{{name}}">#{{name}} - {{count}}</a>
      </li>
      {{/each}}
    </ul>
    <ul id="search-blog-list">
      {{#each posts}}
      <li class="search-item">
        <a href="{{filePath}}" class="search-item-link">{{title}}</a>
      </li>
      {{/each}}
    </ul>
  </div>
</div>
<div id="overlay"></div>
```

- 이 내용이 `{{search}}` 안에 위치하게 됩니다.
- 모든 태그와 게시글 목록을 확인할 수 있습니다.
- 일단 html로 모두 랜더링이 되고 css로 숨기고 있습니다. 이 부분은 다음편에 공개하겠습니다. 빌드타임에 처리할 수 없고 브라우저에서 처리되어야 하는 로직입니다.

```html
<main id="main">
  <ul class="blog-list">
    {{#each posts}}
    <li class="blog-item">
      <div>
        <a href="{{filePath}}" class="blog-link">{{title}}</a>
        <p class="blog-date">{{date}}</p>
        <ul class="tag-list">
          {{#each tags}}
          <li class="tag-item" data-id="{{this}}">
            <a href="#" data-tag="{{this}}" class="tag-text">#{{this}}</a>
          </li>
          {{/each}}
        </ul>
        <p class="blog-description">{{description}}</p>
        <hr class="blog-divider" />
      </div>
    </li>
    {{/each}}
  </ul>
</main>
```

- 이 내용은 `{{body}}`에 들어갑니다.
- `index.html`에 표현될 내용입니다.
- 글목록 속에 태그가 중첩된 구조로 표현되어야 합니다.

```html
<ul class="tag-list">
  {{#each tags}}
  <li class="tag-item" data-id="{{this}}">
    <a href="#" data-tag="{{this}}" class="tag-text">#{{this}}</a>
  </li>
  {{/each}}
</ul>
<div id="content" class="markdown-body">{{content}}</div>
<aside id="toc">
  <ul class="toc-list">
    {{#each toc}}
    <li class="toc-item toc-level-{{level}}">
      <a href="#{{id}}">{{heading}}</a>
    </li>
    {{/each}}
  </ul>
</aside>
<nav class="post-navigation">
  {{#if previousPost}}
  <div class="previous-post">
    <span class="nav-label">← 이전 글</span>
    <a href="{{previousPostFilePath}}" class="nav-link">{{previousPostTitle}}</a>
  </div>
  {{/if}} {{#if nextPost}}
  <div class="next-post">
    <span class="nav-label">다음 글 →</span>
    <a href="{{nextPostFilePath}}" class="nav-link">{{nextPostTitle}}</a>
  </div>
  {{/if}}
</nav>
<div id="comments">
  <!-- giscus 댓글 기능 생략 -->
</div>
```

- 이 내용은 `{{body}}`에 들어갑니다.
- 상세 게시글의 템플릿입니다. 핵심은 `<div id="content" class="markdown-body">{{content}}</div>`입니다.
- 댓글은 SPA처럼 작성하게 될 것을 걱정할 것이 없습니다. 그냥 html로 붙이되기 때문에 상당히 단순합니다.
- `toc`와 이전 이후 글 보기도 추가를 했습니다. index로 나가서 다시 클릭하거나 검색을 누르고 이동하게 만드는 것은 액션코스트가 너무 높습니다.

## render

```ts
/**
 * 완전한 템플릿 렌더링
 * 조건문, 반복문, 일반 플레이스홀더를 모두 처리
 * @param template - 템플릿 문자열
 * @param data - 렌더링할 데이터
 * @returns 렌더링된 최종 문자열
 */
export const render = (template: string, data: Record<string, any>): string => {
  // 1. 조건문 처리
  // {{#if foo}} {{/if}}
  let result = renderConditional(template, data);

  // 2. 반복문 처리
  // {{#each bar}} {{/each}}
  result = renderEach(result, data);

  // 3. 일반 플레이스홀더 처리 (모든 값을 문자열로 변환)
  const stringData: Record<string, string> = {};
  Object.entries(data).forEach(([key, value]) => {
    if (Array.isArray(value)) {
      stringData[key] = value.join(', ');
    } else if (typeof value === 'object' && value !== null) {
      stringData[key] = JSON.stringify(value);
    } else {
      stringData[key] = String(value ?? '');
    }
  });

  // {{foo}}
  result = renderTemplate(result, stringData);

  return result;
};
```

- `render` 함수는 평문, 조건문, 반복문 3가지를 처리합니다.
- 로직도 테스트도 단순합니다.
- 위 랜더링 로직을 갖고 문자열을 하나로 만들어서 순서대로 파일쓰기를 하는 것이 전부입니다.

```ts
/** 블로그 글 목록 템플릿 */
const MainHtml = render(mainTemplate, { posts: metaJson });
/** topbar, 배경 등 고정 요소들 */
const AppHtml = render(appTemplate, { body: MainHtml, search: SearchHtml });
/** index.html 파일 저장 */
writeFileSync(join(process.cwd(), 'dist', 'index.html'), AppHtml, 'utf8');
```

## 메타데이터 처리

- 메타데이터는 마크다운 파일을 모두 1번 읽고 순서대로 처리합니다. 먼저 모든 메타데이터를 모으고 검색 템플릿에 처리하게 만드는 것이 의도입니다.
  - 이렇게 되면 마크다운 본문의 내용을 처리하면서 한번더 파일 읽기를 처리하게 됩니다. 다른 방법이 있는지 잘 모르겠습니다. 알고 있는 것이 있다면 알려주시기 바랍니다.

```ts
const metaJson: Metadata[] = [];

// ... (생략)

// /blogs의 모든 마크다운 파일 가져오기
const blogsDir = join(process.cwd(), 'blogs');
const markdownfiles = await listUpMarkdownFiles(blogsDir);

// 메타 정보와 마크다운 콘텐츠를 저장할 맵 (파일 경로 기준)
const contentMap = new Map<string, string>();

// 메타 정보 처리하기
for (const file of markdownfiles) {
  const content = await readMarkdownFile(file.filePath);
  const { metadata } = processMetaData(content, file.filePath, blogsDir);
  if (metadata.draft) {
    file.isProcessed = true;
    continue;
  }
  // 마크다운 콘텐츠도 함께 저장
  const { markdownContent } = splitMetadataAndContent(content);
  contentMap.set(file.filePath, markdownContent);
  metaJson.push(metadata);

  // ... (생략)
}
```

- `metaJson`에 메타정보들을 저장해야 합니다.
- 단순하게 파일들을 순서대로 읽고 메타정보들만 먼저 처리합니다.
- 이렇게 하는 이유는 결국에 검색 기능이 메타정보를 접근해야 하기 때문입니다.

```ts
export type Metadata = {
  title?: string; // 제목
  date?: string; // 발행일
  tags?: string[]; // 태그들
  description?: string; // 설명
  authors?: string[]; // 저자
  draft?: boolean; // 공개여부
  filePath?: string; // 파일 경로
};
```

- 타입선언은 위가 전부입니다.

```ts
// ... (생략)

// 태그 정보 수집 (태그별 개수 포함)
const tagMap = new Map<string, number>();
metaJson.forEach((meta) => {
  if (meta.tags) {
    meta.tags.forEach((tag) => {
      tagMap.set(tag, (tagMap.get(tag) || 0) + 1);
    });
  }
});

// 태그를 배열로 변환 (count 포함)
const tags = Array.from(tagMap.entries())
  .map(([tag, count]) => ({ name: tag, count }))
  .sort((a, b) => a.name.localeCompare(b.name)); // 알파벳 순으로 정렬

// dist/meta.json 파일로 쓰기
writeFileSync(join(process.cwd(), 'dist', 'meta.json'), JSON.stringify(metaJson.reverse(), null, 2), 'utf8');

// 검색 템플릿 렌더링
const SearchHtml = render(searchTemplate, { tags, posts: metaJson });

// ... (생략)
```

- 이렇게만 하면 검색 로직은 모두 처리가 된 것입니다.
- 이 검색 로직은 문자열만 만들고 직접 저장하는데 활용하지 않습니다.

## 마크다운 처리

```ts
const build = async () => {
  // ... (생략)

  // 마크다운 파일 쓰기
  for (const file of markdownfiles) {
    // 이런저런 경로 찾는 로직
    // 이런저런 마크다운 파일 주소 알아내고 본문 파일하는 로직
    const targetMeta = metaJson[targetMetaIndex];

    // 이전/다음 글 정보 계산 (metaJson은 최신순으로 정렬되어 있음)
    let previousPost: PostNavigation | undefined;
    let nextPost: PostNavigation | undefined;

    // 이전 글 (더 오래된 글 = 인덱스가 더 큼)
    if (targetMetaIndex < metaJson.length - 1) {
      const prevMeta = metaJson[targetMetaIndex + 1];
      previousPost = {
        filePath: prevMeta.filePath,
        title: prevMeta.title,
      };
    }

    // 다음 글 (더 최신 글 = 인덱스가 더 작음)
    if (targetMetaIndex > 0) {
      const nextMeta = metaJson[targetMetaIndex - 1];
      nextPost = {
        filePath: nextMeta.filePath,
        title: nextMeta.title,
      };
    }

    const htmlContent = await processMarkdownFile(
      markdownContent,
      targetMeta,
      appTemplate,
      postTemplate,
      SearchHtml,
      previousPost,
      nextPost,
    );
    await writeHtmlFile(file.filePath, htmlContent, blogsDir);
    file.isProcessed = true;
  }

  // ... (생략)
};
```

- 위는 각각의 게시물 파일쓰기입니다.
- 메타정보로 이전 이후 파일 순서를 알고 있습니다.
- 검색 템플릿을 문자열로 전달합니다. 물론 다른 템플릿문자열도 일단 전달만 합니다.

```ts
/**
 * 마크다운 콘텐츠를 HTML로 변환하고 템플릿에 렌더링하는 함수
 *
 * @param markdownContent - 마크다운 콘텐츠 (frontmatter 제외)
 * @param metadata - 이미 파싱된 메타데이터
 * @param appTemplate - 앱 템플릿
 * @param postTemplate - 포스트 템플릿
 * @param searchTemplate - 검색 템플릿
 * @param previousPost - 이전 글 정보
 * @param nextPost - 다음 글 정보
 * @returns 렌더링된 HTML 콘텐츠
 *
 * @example
 * const markdownContent = `# Test Title\n\nThis is content.`;
 * const metadata = { title: 'Test Title', date: '2021-01-01' };
 * const htmlContent = await processMarkdownFile(markdownContent, metadata, appTemplate, postTemplate, searchTemplate, previousPost, nextPost);
 */
const processMarkdownFile = async (
  markdownContent: string,
  metadata: Metadata,
  appTemplate: string,
  postTemplate: string,
  searchTemplate: string,
  previousPost?: PostNavigation,
  nextPost?: PostNavigation,
) => {
  const { html: htmlContent, toc } = await convertMarkdownToHtml(markdownContent);

  const bodyHtml = render(postTemplate, {
    content: htmlContent,
    tags: metadata.tags ?? [],
    toc,
    previousPost: !!previousPost,
    previousPostFilePath: previousPost?.filePath ?? '',
    previousPostTitle: previousPost?.title ?? '',
    nextPost: !!nextPost,
    nextPostFilePath: nextPost?.filePath ?? '',
    nextPostTitle: nextPost?.title ?? '',
  });
  const appHtml = render(appTemplate, {
    body: bodyHtml,
    title: ` - ${metadata.title ?? ''}`,
    description: metadata.description ?? '',
    tags: metadata.tags?.join(', ') ?? '',
    authors: metadata.authors?.join(', ') ?? '',
    date: metadata.date ?? '',
    search: searchTemplate,
  });

  return appHtml;
};
```

- 한 계층 내부를 보면 상당히 단순합니다. body를 먼저 만들고 app을 다음으로 만드는 것이 전부입니다.
- 실제 내용을 만드는 것은 `htmlContent`와 `toc` 뿐입니다.

```ts
/**
 * 마크다운 콘텐츠를 HTML로 변환 (shiki 코드 하이라이팅 적용)
 * @returns HTML 문자열과 TOC 데이터를 포함한 객체
 */
export const convertMarkdownToHtml = async (markdownSource: string): Promise<{ html: string; toc: TocItem[] }> => {
  const toc: TocItem[] = [];

  const htmlText = await unified()
    .use(markdown)
    .use(remarkGfm)
    .use(remarkDirective)
    .use(remarkCallout)
    .use(remark2rehype)
    .use(rehypeSlug)
    .use(rehypeExtractToc, { toc })
    .use(rehypeShiki, {
      theme: 'catppuccin-mocha',
    })
    .use(html)
    .process(markdownSource);

  if (typeof htmlText.value === 'string') {
    // 템플릿 문법을 이스케이프하여 템플릿 엔진에서 처리되지 않도록 함
    return { html: escapeTemplateSyntax(htmlText.value), toc };
  }

  return { html: '', toc: [] };
};
```

- 의존성을 많이 사용하는 부분이 이분분입니다. 단순하게 마크다운 문자열을 받아 html 문법으로 변환하는 것이 전부입니다.
- 여기서 toc를 따로 접근하기 위해 추가 플러그인만 설치했습니다. 굳이 정규표현식으로 탐지하지 말고 AST로 접근하는 것이 더 신뢰할 수 있을 것이라고 봤습니다.

## 메인페이지

```ts
// ... (생략)
const MainHtml = render(mainTemplate, { posts: metaJson });
const AppHtml = render(appTemplate, { body: MainHtml, search: SearchHtml });
writeFileSync(join(process.cwd(), 'dist', 'index.html'), AppHtml, 'utf8');
// ... (생략)
```

- `index.html` 파일을 저장하는 로직입니다.
- 복잡하게 처리될 로직이 없습니댜. 이미 글의 순서를 담고 있는 배열이 있습니다. 그냥 그 순서 그대로 보여주면 됩니다.

## 404 로직

```ts
const NotFoundHtml = render(appTemplate, {
  body: '<h1 style="text-align: center; margin-top: 100px; color: #D1D7E0;">404 - Page Not Found</h1>',
  search: SearchHtml,
});
writeFileSync(join(process.cwd(), 'dist', '404.html'), NotFoundHtml, 'utf8');
```

- 이거도 중요합니다. 없는 페이지를 접근하는 예외처리를 잘했는지 확인하는 부분입니다.
- 여전히 `appTemplate`에 감싸져야 합니다.
- 아주 귀찮아서 인라인으로 css를 작성했습니다.

---

<!--
## 세이브 원고
## 초기화 시점에 실행할 로직들

```ts
const metaJson: Metadata[] = [];

const appTemplate = await readFile(join(process.cwd(), 'app', 'templates', 'app.html'), 'utf8');
const postTemplate = await readFile(join(process.cwd(), 'app', 'templates', 'post.html'), 'utf8');
const mainTemplate = await readFile(join(process.cwd(), 'app', 'templates', 'main.html'), 'utf8');
const searchTemplate = await readFile(join(process.cwd(), 'app', 'templates', 'search.html'), 'utf8');

// /blogs의 모든 마크다운 파일 가져오기
const blogsDir = join(process.cwd(), 'blogs');

// dist 폴더 내용 초기화하기
await rm(join(process.cwd(), 'dist'), { recursive: true, force: true });
mkdirSync(join(process.cwd(), 'dist'), { recursive: true });

// asset 폴더 내용 복사하기
await cp(join(process.cwd(), 'app', 'asset'), join(process.cwd(), 'dist'), { recursive: true });

// client TypeScript를 JavaScript로 빌드하기
await esbuild.build({
  entryPoints: [join(process.cwd(), 'app', 'client', 'index.ts')],
  bundle: true,
  minify: true,
  outfile: join(process.cwd(), 'dist', 'script.js'),
  target: 'es2020',
  platform: 'browser',
});

// 메타 정보와 마크다운 콘텐츠를 저장할 맵 (파일 경로 기준)
const contentMap = new Map<string, string>();

// 깨진 이미지 링크 수집용 배열
const allBrokenImageLinks: BrokenImageLink[] = [];
const assetDir = join(process.cwd(), 'app', 'asset');
```

- 초기화는 극도로 단순합니다.
- 변수는 메타정보를 담을 배열 `metaJson`, 마크다운 문자열을 파일 경로랑 맵핑할 `contentMap`, 깨진 링크를 저장할 배열 `allBrokenImageLinks`를 선언합니다. 이 변수들은 데이터를 처리하면서 담기 위한 용도입니다.
- 빌드를 처리하면서 읽기만을 위해 템플릿으로 활용할 html 파일을 읽고 마크다운과 `asset` 경로에 해당하는 문자열을 초기화 합니다.
- 처리하는 행위는 `dist` 폴더를 비워버리고 `asset` 폴더의 이미지를 복사하고 클라이언트 런타임에서 실행할 로직을 타입스크립트에서 자바스크립트로 변환하고 `script.js`로 저장합니다.
- 여기서는 모두 node.js에서 제공하는 함수와 설차힌 esbuild 라이브러리 정도 활용했습니다.

## 마크다운과 이미지 경로 리스트업

```ts
// /blogs의 모든 마크다운 파일 가져오기
const blogsDir = join(process.cwd(), 'blogs');
const markdownfiles = await listUpMarkdownFiles(blogsDir);

// blogs 폴더의 이미지 파일들을 dist로 복사 (폴더 구조 유지)
const imageFiles = await listUpImageFiles(blogsDir);
for (const imagePath of imageFiles) {
  // blogs/ 기준 상대 경로 유지
  const relativePath = imagePath.replace(`${blogsDir}/`, '');
  const destPath = join(process.cwd(), 'dist', relativePath);
  mkdirSync(dirname(destPath), { recursive: true });
  await cp(imagePath, destPath);
}
```

- 처리할 리스트업은 2가지입니다. 마크다운의 목록과 처리할 이미지 목록 정도 가져오고 처리하면 됩니다.
- 이미지 복사는 단순해서 바로 작성했습니다.
- 더 높은 수준을 갖게 만들고자 했으면 webp로 변환처리하는 로직을 넣는 것이지만 지금 굳이 하고 싶지 않습니다.

### 폴더 구조

- 여기서 알아둘 점은 마크다운이 있는 폴더에 같이 활용할 이미지를 같이 넣었습니다. 빌드할 때 같은 폴더 구조를 유지하게 만들었습니다.
- 이것은 의도를 갖고 있습니다. 기존 프레임워크들은 마크다운과 이미지를 서로 다른 폴더에 넣어서 관리하도록 강제했습니다. 개발하면서 마음에 안 든 것은 이미지추가를 할 때 폴더를 별도로 관리해야 한다는 것이 불필요한 복잡성을 줬다고 생각이 들었습니다.

```
/root
  /content
    /blogs
      /2025-12-14
        /foo.md

  ...(생략)

  /public
    /asset
    /blogs
      /2025-12-14
        /bar.png
```

- `content/blogs/2025-12-14/foo.md`에 마크다운 글이 있고 `public/blogs/2025-12-14/bar.png`가 있다는 것이 서로 동떨어졌습니다.

```
/root
  /blogs
    /2025-12-14
      /foo.md
      /bar.png
```

- `blogs/2025-12-14/foo.md`와 `blog/2025-12-14/bar.png`로 보면 더 편할 것입니다. 저는 실제로 이 글에서만 해당하는 이미지인데 굳이 다른 파일에서 관리하는 것이 번거롭습니다.
  - 저는 위와 같은 형태의 폴더링이 더 자연스럽다고 봅니다.

### 리스트업 로직

```ts
/**
 * @param dirPath 디렉토리 경로
 * @param baseDir 기본 디렉토리 경로
 * @returns 마크다운 파일 목록을 반환함
 */
const listUpMarkdownFiles = async (dirPath: string, baseDir: string = dirPath) => {
  const posts: { filePath: string; isProcessed: boolean }[] = [];

  const entries = await readdir(dirPath, { withFileTypes: true });

  for (const entry of entries) {
    const fullPath = join(dirPath, entry.name);

    if (entry.isDirectory()) {
      // 재귀적으로 하위 디렉토리 탐색
      const subPosts = await listUpMarkdownFiles(fullPath, baseDir);
      posts.push(...subPosts);
    } else if (entry.isFile() && path.extname(entry.name) === '.md') {
      posts.push({
        filePath: fullPath,
        isProcessed: false,
      });
    }
  }
  return posts;
};
```

- 마크다운 목록을 리스트업할 때는 DFS로 탐색을 합니다. stack 역할을 해주는 `post`도 있지만 `isDirectory` 메서드가 현재 본인이 경로라면 1 depth더 들어가라고 하는 로직이기 때문입니다.
- 하지만 파일이면 탐색을 중단하도록 만든겁니다.

```ts
// 이미지 확장자 목록
const IMAGE_EXTENSIONS = ['.png', '.jpg', '.jpeg', '.gif', '.svg', '.webp'];

/**
 * 지정된 디렉토리에서 이미지 파일을 재귀적으로 찾는 함수
 * @param dirPath 탐색할 디렉토리 경로
 * @returns 이미지 파일 경로 목록
 */
const listUpImageFiles = async (dirPath: string): Promise<string[]> => {
  const images: string[] = [];
  const entries = await readdir(dirPath, { withFileTypes: true });

  for (const entry of entries) {
    const fullPath = join(dirPath, entry.name);
    if (entry.isDirectory()) {
      images.push(...(await listUpImageFiles(fullPath)));
    } else if (IMAGE_EXTENSIONS.includes(extname(entry.name).toLowerCase())) {
      images.push(fullPath);
    }
  }
  return images;
};
```

- 이미지도 마크다운과 처리가 동일합니다.
- 물론 이미지 파일 이름을 이상하게 작성하면 push하지 말아야 할 것을 push하게 될 것입니다. 이런 버그는 상대할 가치가 없는 버그입니다.
  - 일반적이지 않은 행동 모두 대응해주는 것은 적절하지 않다고 봅니다.

## 메타 정보 처리

- 실험용으로 만들었던 레포에는 메타정보를 가져올 수 있는 `json`을 만들도록 했습니다.
  - 검색보다 더 많은 용도를 갖게 되었습니다.
- 제가 메타정보를 처리하는 이유는 모든 글에 동일하게 랜더링이 되어야 하는 검색 팝업 때문입니다.
  - `json`을 만들어서 검색에 찾도록 한 목적이 아닙니다. 지금은 제공은 하지만 용도가 특별히 없습니다.
- 메타정보를 처리할 때 깨진 이미지 링크도 알아내도록 하고 있습니다.

```ts
// 메타 정보와 마크다운 콘텐츠를 저장할 맵 (파일 경로 기준)
const contentMap = new Map<string, string>();

// 깨진 이미지 링크 수집용 배열
const allBrokenImageLinks: BrokenImageLink[] = [];
const assetDir = join(process.cwd(), 'app', 'asset');

// 메타 정보 처리하기
for (const file of markdownfiles) {
  const content = await readMarkdownFile(file.filePath);
  const { metadata } = processMetaData(content, file.filePath, blogsDir);
  if (metadata.draft) {
    file.isProcessed = true;
    continue;
  }
  // 마크다운 콘텐츠도 함께 저장
  const { markdownContent } = splitMetadataAndContent(content);
  contentMap.set(file.filePath, markdownContent);
  metaJson.push(metadata);

  // 이미지 유효성 검사 (빌드 후 dist에 복사될 이미지 기준)
  const brokenLinks = findBrokenImageLinks(markdownContent, file.filePath, blogsDir, assetDir);
  allBrokenImageLinks.push(...brokenLinks);
}

// 깨진 이미지 링크 출력
reportBrokenImageLinks(allBrokenImageLinks);

// 태그 정보 수집 (태그별 개수 포함)
const tagMap = new Map<string, number>();
metaJson.forEach((meta) => {
  if (meta.tags) {
    meta.tags.forEach((tag) => {
      tagMap.set(tag, (tagMap.get(tag) || 0) + 1);
    });
  }
});

// 태그를 배열로 변환 (count 포함)
const tags = Array.from(tagMap.entries())
  .map(([tag, count]) => ({ name: tag, count }))
  .sort((a, b) => a.name.localeCompare(b.name)); // 알파벳 순으로 정렬

// dist/meta.json 파일로 쓰기
writeFileSync(join(process.cwd(), 'dist', 'meta.json'), JSON.stringify(metaJson.reverse(), null, 2), 'utf8');

// 검색 템플릿 렌더링
const SearchHtml = render(searchTemplate, { tags, posts: metaJson });
```

- 최종적으로 루트에 해당하는 주소부터 각 하위 주소까지 `SearchHtml`을 문자열로 전달해줘야 합니다. 이 문자열을 만들기 위한 일렬의 과정입니다.
- 마크다운 파일 목록은 `markdownfiles` 변수에 담겨있습니다.
- `readMarkdownFile`은 마크다운 주소를 주면 해당파일을 읽고 문자열을 반환해주는 함수에 불과합니다.
- `processMetaData` 마크다운 상단의 yml 문법의 메타데이터를 읽고 처리하는 함수입니다. 이 로직은 의외로 복잡했습니다.

```ts
/**
 * metadata 파싱
 * 허용하지 않은 키가 있으면 에러를 발생시킴
 * 필수키가 없으면 에러를 발생시킴
 */
export const parseMetadata = (metadata: string) => {
  const metadataObject: Metadata = {};
  const metadataLines = metadata.split('\n');

  let i = 0;
  while (i < metadataLines.length) {
    const line = metadataLines[i].trim();

    // 빈 줄 스킵
    if (!line) {
      i++;
      continue;
    }

    const colonIndex = line.indexOf(':');
    if (colonIndex === -1) {
      i++;
      continue;
    }

    const key = line.slice(0, colonIndex).trim();
    let value = line.slice(colonIndex + 1).trim();

    // 배열 처리
    // 1. value가 빈 문자열이고 다음 줄이 [로 시작하는 경우
    if (value === '' && i + 1 < metadataLines.length) {
      const nextLine = metadataLines[i + 1].trim();
      if (nextLine.startsWith('[')) {
        i++; // 다음 줄로 이동
        value = nextLine;
      }
    }

    if (value.startsWith('[')) {
      // 한 줄에 배열이 완성된 경우
      if (value.endsWith(']')) {
        const arrayString = value.slice(1, -1); // [ ] 제거
        const items = arrayString.split(',').map((item) => {
          const trimmed = item.trim();
          // 작은따옴표 제거
          if (trimmed.startsWith("'") && trimmed.endsWith("'")) {
            return trimmed.slice(1, -1);
          }
          return trimmed;
        });
        metadataObject[key] = items;
        i++;
        continue;
      }

      // 여러 줄에 걸쳐 있는 배열
      let arrayString = value.slice(1); // [ 제거
      i++;
      while (i < metadataLines.length) {
        const nextLine = metadataLines[i].trim();
        arrayString += ` ${nextLine}`;
        if (nextLine.includes(']')) {
          break;
        }
        i++;
      }

      // 배열 파싱
      const closingBracketIndex = arrayString.indexOf(']');
      if (closingBracketIndex !== -1) {
        const arrayContent = arrayString.slice(0, closingBracketIndex);
        const items = arrayContent
          .split(',')
          .map((item) => {
            const trimmed = item.trim();
            // 작은따옴표 제거
            if (trimmed.startsWith("'") && trimmed.endsWith("'")) {
              return trimmed.slice(1, -1);
            }
            return trimmed;
          })
          .filter((item) => item !== '');
        metadataObject[key] = items;
      }
      i++;
      continue;
    }

    // 일반 문자열 값
    // 따옴표로 감싸진 경우 제거
    if ((value.startsWith('"') && value.endsWith('"')) || (value.startsWith("'") && value.endsWith("'"))) {
      metadataObject[key] = value.slice(1, -1);
    } else {
      metadataObject[key] = value;
    }
    i++;
  }

  return metadataObject;
};
```

- 여기서 중요한 부분은 테스트 케이스 같습니다.
- 테스트 케이스를 확인해야 코드를 이해할 수 있다면 그것은 나쁜 코드가 될 것입니다.
- 복잡한 코드에 테스트가 없었다면 더 나쁜 코드가 되었을 것입니다.

```ts
  it('should return the metadata object with multiple tags', () => {
    const metadata = `title: 원티드 프리온보딩 과제 - 6일차
authors: [arch-spatula]
tags:
  [
    'blog',
    'wanted',
    'pre-on-boarding',
    'Cannot use import statement outside a module',
    'Jest Mocking',
    'jest',
    'try-catch error type',
  ]
description: 원티드 과제 진행과정
date: 2023-04-15`;
    const metadataObject = parseMetadata(metadata);
    expect(metadataObject).toEqual({
      title: '원티드 프리온보딩 과제 - 6일차',
      authors: ['arch-spatula'],
      tags: [
        'blog',
        'wanted',
        'pre-on-boarding',
        'Cannot use import statement outside a module',
        'Jest Mocking',
        'jest',
        'try-catch error type',
      ],
      description: '원티드 과제 진행과정',
      date: '2023-04-15',
    });
  });
});
```

- 위가 가장 핵심적인 테스트 케이스입니다. 제가 원하는 메타정보가 위의 형태를 가져야 하기 때문입니다.
- 각각의 입력값을 가지고 디버거를 실행해보면 납득이 될 것입니다.

### 검색 템플린 랜더링

```html
<div id="search-popup">
  <div id="popup-container">
    <form id="search-form">
      <img id="search-icon" src="/search.svg" alt="search" /><input
        id="search-input"
        type="search"
        name="search-input"
        placeholder="Search"
        autocomplete="off"
      />
      <div></div>
    </form>
    <ul id="search-tag-list">
      {{#each tags}}
      <li class="search-tag-item">
        <a class="tag-link" href="#" data-tag="{{name}}">#{{name}} - {{count}}</a>
      </li>
      {{/each}}
    </ul>
    <ul id="search-blog-list">
      {{#each posts}}
      <li class="search-item">
        <a href="{{filePath}}" class="search-item-link">{{title}}</a>
      </li>
      {{/each}}
    </ul>
  </div>
</div>
<div id="overlay"></div>
```

- 위 템플릿은 모든 html 파일별로 붙어있어야 합니다.

## 파일 읽기

- 초안에는 단 한번의 디스크 io로 처리 가능할 것이라고 생각했습니다. 검색 기능을 넣기 위해 각 글의 메타 정보를 모두 받고 메타정보를 모두 공유하게 해주려면 결국 디스크 io를 두번 할 수 밖에 없었습니다.
- 작업처리를 할 때 어느정도 계층 구조를 갖게 만들고자 했습니다.
  - 가장 먼저 처리하는 단계는 초기화 단계입니다. 실질적인 단계라고 치기에 애매합니다.
    - 메타정보를 담을 배열을 선언합니다.
    - 템플릿으로 활용할 html 파일을 읽습니다.
    - dist를 한번 비워버립니다.
    - 모든 html 파일들이 사용할 스크립트를 빌드합니다. `index.ts`가 해당합니다.
  - 첫번째는 처리해야할 작업들을 목록으로 정리해주는 작업입니다. 이것은 파일의 내용이 아니라 파일들의 주소를 알아내는 단계입니다.
    - 여기서 `listUpMarkdownFiles.ts`를 호출하고 처리합니다.
  - 두번째는 각 파일의 주소를 활용해 메티정보를 얻고 콘텐츠를 얻어 처리합니다.
    - 파일을 읽고 처리하고 쓰기만하면 될 것이라고 생각했습니다.
    - 실제로 한 것은 파일을 읽고 메타정보를 저장합니다. 마크다운 문자열도 이때 저장합니다. 나중에 Map의 사이즈가 너무 커져서 문제가 된다면 저장 안 하고 파일 읽기를 1번더 할 것입니다.
- blogs 폴더 내에서 모든 마크다운 파일들과 파일이 속한 폴더 주소를 알아내는 것이 1단계입니다.
  - 여기서는 모든 마크다운 파일 목록들을 알아내야 합니다.
  - 템플릿들을 모두 가져와야 합니다.
- 2단계는 파일과 폴더 주소를 활용해서 3단계 과정을 거칩니다.
  - 마크다운 파일을 읽습니다.
  - 마크다운 파일을 처리합니다.
    - 가장 많은 테스트 코드는 여기에 배치해야 합니다.
    - 템플릿들을 읽고 처리를 해줘야 합니다.
  - 마크다운 파일을 HTML로 저장합니다.
    - 처리가 완료된 html은 파일로 저장합니다.
      - 메타정보도 html의 header로 활용합니다.
    - 메타정보를 활용해서 json으로 저장합니다.
- 소프트웨어를 설계할 때 경계를 나누는 것이 중요한 활동이 됩니다.

### 클라이언트에게 전달할 로직

- 페이지를 로딩하고 이벤트를 등록하는 방식으로 처리했습니다.
- 이번에는 상태를 최대한 url에 넣었습니다.

## 빌드 시점에 처리하는 특수한 로직

### 깨인 이미지 알아내기

- 이미지 링크가 깨질 수 있습니다. 이것을 테스트로도 알아낼 수 있지만 빌드 시점에 먼저 알아내는 것이 더 좋다고 보고 넣었습니다.
- 지금 마크다운파일과 이미지를 같은 폴더 내에 넣는 구조면 이런 실수할 여지가 상당히 낮습니다. 하지만 만약에 발생한다면 방지를 하는 것이 필요하다고 봤습니다.
- 이 글을 쓰는 시점에서는 오히려 필요없는 기능을 추가한 것 같습니다.

```ts
/**
 * 마크다운 콘텐츠에서 깨진 이미지 링크를 찾는 함수
 *
 * @param markdownContent - 마크다운 콘텐츠
 * @param markdownFilePath - 마크다운 파일의 절대 경로
 * @param blogsDir - blogs 디렉토리 경로
 * @param assetDir - app/asset 디렉토리 경로
 * @returns 깨진 이미지 링크 배열
 *
 * @example
 * const brokenLinks = findBrokenImageLinks(content, '/path/to/blog.md', '/path/to/blogs', '/path/to/app/asset');
 */
export const findBrokenImageLinks = (
  markdownContent: string,
  markdownFilePath: string,
  blogsDir: string,
  assetDir: string,
): BrokenImageLink[] => {
  const images = extractImageLinks(markdownContent);
  const brokenLinks: BrokenImageLink[] = [];

  for (const { alt, src } of images) {
    if (!checkImageExists(src, markdownFilePath, blogsDir, assetDir)) {
      brokenLinks.push({
        alt,
        src,
        markdownFilePath,
      });
    }
  }

  return brokenLinks;
};
```

- 코드를 하이레벨로 보면 극도로 단순합니다.

### code block syntax highlighting

- 코드 블럭을 실제로 보고 읽고 이해를 합니다. 하지만 변수, 함수, 클래스, 연산자 등 눈으로 보고 구별이 안 되면 가독성을 떨어지는 문제가 있습니다.
- 코드 블럭을 그냥 보여주면 상당히 간지가 안 납니다.
- 가능하면 최대한 빌드 시점에 처리되게 만들고 싶습니다.
  - 유저는 최대한 의존성이 없는 순수한 html 위주로 전달받아야 한다고 보고 있습니다.
- https://shiki.style/
  - nuxt content가 사용하는 것으로 보입니다.
  - 이 라이브러리를 그대로 도입하기로 했습니다. 처음 생각에는 클라이언트에게 전달해줘야 하는 의존성인가? 했는데 빌드 시점으로 개발 의존서으로 사용해도 충분했습니다.

## 바뀐 github action

- 이전에 nuxt로 작성했던 yml을 다시 작성해야 합니다. ~~트래픽도 없는 블로그 주제에 한번에 잘 작성하고 싶습니다.~~
- https://ko.vite.dev/guide/static-deploy 도 참고하기는 했습니다.
- ChatGPT에게 초안 작성을 요구했지만 RAG 모델이 아니라서 신뢰할 수 없었습니다. 하지만 좋은 초안은 맞는 것 같습니다.
- 이짓 거리를 할 때 쯤에 Opus에 빠른 요청을 보낼 수 있는 토큰을 소진했습니다. 한편으로 다행입니다. 돈을 더 쓰고 싶다는 생각이 들때가 있습니다.

```yml
# https://github.com/actions/deploy-pages#usage
name: Deploy to GitHub Pages
on:
  workflow_dispatch:
  push:
    branches:
      - main
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: corepack enable
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      # Pick your own package manager and build script
      - run: pnpm install
      - run: pnpm generate --preset github_pages
      - run: touch .output/public/.nojekyll
      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: ./.output/public
  # Deployment job
  deploy:
    # Add a dependency to the build job
    needs: build
    # Grant GITHUB_TOKEN the permissions required to make a Pages deployment
    permissions:
      pages: write # to deploy to Pages
      id-token: write # to verify the deployment originates from an appropriate source
    # Deploy to the github_pages environment
    environment:
      name: github_pages
      url: ${{ steps.deployment.outputs.page_url }}
    # Specify runner + deployment step
    runs-on: ubuntu-latest
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
```

- 이게 기존에 작성되어 있던 배포 yml입니다.
- nuxt와 관련된 내용을 제거하고 순수하게 node.js 정도만 남겨야 합니다.
- 작년에 작업하고 내용을 너무 많이 까먹어서 다시 찾아 봐야 합니다.

```yml
name: Deploy to GitHub Pages

on:
  push:
    branches:
      - main

permissions:
  contents: read
  pages: write
  id-token: write

concurrency:
  group: pages
  cancel-in-progress: true

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 24
          cache: pnpm

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 9

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Build
        run: pnpm run build

      - name: Upload Pages artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: dist

  deploy:
    runs-on: ubuntu-latest
    needs: build
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}

    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
```

- 이번에 해볼 활동은 라인바이 라인으로 해석하는 것을 시도할 것입니다.

### actions/checkout은 무엇인가?

- `actions/checkout@v4`이 무슨 의미인지 몰라 검색했습니다.
- https://www.daleseo.com/github-actions-checkout/

```sh
git init # 명령어를 통해 작업 디렉토리를 로컬 저장소로 만든다.
git config # 명령어를 통해 각종 인증 관련 정보를 설정한다
git fetch # 명령어를 통해 원격 저장소로 부터 코드를 받아온다.
git checkout # 명령어를 통해 주(main) 브랜치로 전환한다.
git log # 명령어로 마지막 커밋(commit)의 해시값을 확인한다.
```

- 위에 해당하는 명령들을 실행한다고 합니다. 지금 보여주는 것은 간략한 버전일 것입니다.
- `actions/setup-node@v4`인데 이것이 검색을 하면서 다음 내용들을 알아냈습니다.
  - https://github.com/marketplace/actions/setup-node-js-environment
  - https://github.com/actions/setup-node

```yml
- uses: actions/checkout@v5
- uses: actions/setup-node@v6
  with:
    node-version: 24
```

- `READMD.md`에 확인한 시점에는 위를 예시로 보여주고 있습니다.
- 위처럼 하면 일단 node.js와 npm이 설치 됩니다.

```yml
on:
  - push
  - pull_request

jobs:
  cache-and-install:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - uses: pnpm/action-setup@v4
        name: Install pnpm
        with:
          version: 10
          cache: true

      - name: Install dependencies
        run: pnpm install
```

- https://github.com/pnpm/action-setup
- https://github.com/marketplace/actions/setup-pnpm
- 위에 알려준 버전을 사용하면 pnpm 10 버전을 사용할 수 있습니다.

 -->
