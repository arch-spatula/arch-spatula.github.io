---
title: '이벤트 버스(EventBus)'
tags: ['javaScript', 'EventBus', 'EventTarget', '전역상태']
description: '자바스크립트 네이티브 한 방법으로 전역상태를 공유하는 방법'
---

## 이벤트 버스 단순 예시

:::info

이 방법은 옵저버 패턴으로 데이터를 공유하는 방법입니다. 프론트엔드 프레임워크를 사용하고 있으면 프레임워크에서 자주 사용하는 라이브러리를 사용할 것을 권장합니다.

:::

```ts
const EventBus = new EventTarget();

class ClassA {
  trigger() {
    console.log('A 동작');
    EventBus.dispatchEvent(new CustomEvent('A:done', { detail: 'A 실행 완료' }));
  }
}

class ClassB {
  constructor() {
    EventBus.addEventListener('A:done', (e) => {
      console.log('B: A 완료 이벤트 받음 →', e.detail);
    });
  }
}

const a = new ClassA();
const b = new ClassB();

a.trigger(); // B: A 완료 이벤트 받음 →A 실행 완료
```

[EventTarget](https://developer.mozilla.org/ko/docs/Web/API/EventTarget)을 응용해서 만든 가장 단순한 예시입니다. 별도의 3개의 객체이지만 `ClassB`는 `ClassA`의 `trigger`가 실행할 `dispatchEvent`로 구독하게 만들 수 있습니다. `EventBus`를 싱글튼 패턴으로 감싸고 `"A:done"` 같은 문자열을 상수 혹은 키로 관리를 하면 전역상태를 대체하게 만드는 것도 가능합니다. 저는 이런 로직 구현은 복잡한 랜더링 태스크 매니저[^1]가 없는 경우 한정해서 괜찮을 것 같습니다.

## 이벤트 버스 응용

:::info

실제 응용한 링크 전체 코드를 보고 싶다면 다음 3개의 링크를 보면 됩니다.

- [search popup bus 클래스 정의](https://github.com/arch-spatula/new-blog-2025/blob/main/src/search-popup-bus.ts)
- [search popup DOM 등록 및 이벤트 구독](https://github.com/arch-spatula/new-blog-2025/blob/main/src/search.ts)
- [nav 클릭시 이벤트 emit](https://github.com/arch-spatula/new-blog-2025/blob/main/src/nav.ts)

:::

- 이런 구현을 해야 하는 상황은 2026년 대부분의 프론트엔드 개발자에게 해당하지 않을 것입니다.

```ts
// src/search-popup-bus.ts
type Events = 'click';

class PopupBus {
  private static instance: PopupBus; // 싱글톤 인스턴스
  private EventBus: EventTarget;
  /**
   * 싱글튼이라 접근이 불가능해야 함.
   * 외부에서 new 불가능
   */
  private constructor() {
    const EventBus = new EventTarget();
    this.EventBus = EventBus;
  }
  // 항상 같은 인스턴스 반환
  public static getInstance(): PopupBus {
    if (!PopupBus.instance) {
      PopupBus.instance = new PopupBus();
    }
    return PopupBus.instance;
  }

  // 이벤트 발생 및 데이터 송신
  public emit<T>(event: Events, detail: T): void {
    const customEvent = new CustomEvent<T>(event, { detail });
    this.EventBus.dispatchEvent(customEvent);
  }

  // 이벤트 구독 및 데이터 수신
  public on<T>(event: Events, handler: (detail: T) => void): void {
    this.EventBus.addEventListener(event, (e) => {
      handler((e as CustomEvent<T>).detail);
    });
  }
}

export default PopupBus;
```

여기서 코드를 보면 먼저 파악해야 할 것은 싱글튼 패턴을 사용한다는 것입니다. 싱글튼 패턴을 굳이 사용하는 이유(항상 같은 메모리 주소를 보장해야 하는 이유)가 있습니다. 이 인스턴스는 각각 파일 2개에서 접근해야 합니다.

```ts
// src/nav.ts
import PopupBus from './search-popup-bus';

/**
 * nav를 동적으로 만들어서 다른 페이지 이동할 때 쿼리파라미터를 유지함.
 */
const nav = () => {
  const popupBus = PopupBus.getInstance();
  // ... (생략)
  popupBtn.addEventListener('click', () => {
    popupBus.emit('click', () => {});
  });
  // ... (생략)
};

export default nav;
```

Nav에 팝업을 활성화 할 수 있는 버튼입니다. `popupBtn`은 동적으로 생성한 DOM 요소입니다. 팝업을 활성화 하기위한 버튼입니다. 이 버튼을 누르는 이벤트는 pub sub 패턴으로 생각할 때 publish를 하는 부분입니다. `addEventListener`로 클릭이라는 이벤트가 발생하면 `emit`을 통해 이벤트가 발생했다는 사실을 전달합니다. 지금 예시의 경우 데이터를 전달해야 하는 상황이 아닙니다.

```ts
// src/search.ts
/**
 * @fileoverview ctrl + k로 볼 수 있는 창을 다룸
 */
import PopupBus from './search-popup-bus';

// ... (생략)
const search = async (data: Data) => {
  // ... (생략)
  const popupBus = PopupBus.getInstance();
  popupBus.on('click', () => {
    searchElem.appendChild(createPopup());
    searchElem.appendChild(createOverlay());
    focusSearchInput();
    // url에 search open 추가
    const url = new URL(window.location.href);
    url.searchParams.set('search', 'open');
    window.history.pushState({}, '', url);

    popupType = 'search';
  });
  // ... (생략)
};

export default search;
```

검색 팝업을 초기화하는 부분입니다. 여기서 pub sub 패턴으로 생각해보면 여기는 subscribe하는 곳입니다. 실제 팝업을 활성화하는 로직들이 있습니다. DOM 요소를 생성하고 url을 갱신합니다.

## 생각

- 제어흐름 자체는 문서화만 잘 하면 명확합니다.
- 타입 선언을 잘하면 자동완성으로 확장할 수 있습니다.
- 데이터는 어떻게 보관하게 만들지는 고민입니다. 순수하게 이벤트만 전달해주고 있습니다. 데이터를 전달하고 그 데이터를 인스턴스에 저장을 해야 한다면 어떻게 설계할지는 고민이 됩니다.

<!--

- 제어흐름이 명확하지 않을 수 있습니다. 하지만 핵심만 봅시다.


- 시스템 버스처럼 무슨 하드웨어적인 개념의 버스를 생각해볼 수 있지만 운영체제는 나중에 다룰 것입니다.
- 버스는 하나의 컴퓨터 구성요소에서 다른 컴퓨터 구성요소로 데이터를 주고 받는 통신 경로를 말합니다. 상당히 고급스러운 용어 느낌이 드는데 전공자는 이런거 고급스럽지 않아야 합니다.
- 저의 경우 이벤트가 발생하면 어떤 버스 경로를 통해 데이터를 전달한다는 의미입니다.
- 생각해볼 점이 있습니다. 싱글튼은 단 하나의 메모리주소로 어디서 선언해도 같은 주소를 향하도록 하는 방법으로 전역상태를 관리합니다. vue의 [pinai](https://pinia.vuejs.kr/)가 이렇다고 합니다. ~~사실 소스 내부를 잘 모릅니다.~~
- 우리가 알아볼 방법은 다른 방법입니다. 하나의 클래스 인스턴스를 만들고 그 클래스 인스턴스로 데이터를 주고 받는 경로를 만드는 것입니다.
  - 권장을 하나요? 본인이 바닐라 자바스크립트 혹은 타입스크립트를 추구한다면 괜찮을 것 같습니다. 하지만 다른 프레임워크는 그 프레임워크에 대응되는 전역상태관리 라이브러리를 권장하겠습니다.
- 전역으로 상태를 공유한다고 했지 상태의 라이프사이클을 갖고 관리를 한다고 말한적은 없습니다.

- javaScript 내에서 `EventTarget`랑 `CustomEvent`로 옵저버 패턴을 비슷하게 구현하는 방법을 알아냈습니다.
- 싱글튼 패턴과 섞으면 값과 상태를 상당히 자유롭게 사용할 수 있을 것 같습니다.
- 타입정의랑 활용만 잘하면 SPA 없는 개발도 해볼 수 있을 것 같습니다.

```ts
const EventBus = new EventTarget();

class URLBinding {
  // ... 생략
  /**
   * URL 변경 시 실행할 로직
   * this binding이 window로 변경될 것을 방지하기 위해 화살표 함수로 정의함
   * @todo 뒤로가기를 눌렀을 때 모든 상태 동기화
   */
  handleUrlChange = (e?: Event) => {
    EventBus.dispatchEvent(
      new CustomEvent("url:change", {
        detail: {
          tags: this.readTags(),
          isBackBtn: e instanceof PopStateEvent,
        },
      }),
    );
  };
}

class TagMediator {
  urlBinding: URLBinding;
  lookup: Lookup;
  constructor(urlBinding: URLBinding, lookup: Lookup) {
    this.urlBinding = urlBinding;
    this.lookup = lookup;
    EventBus.addEventListener("url:change", (e) => {
      const customEvent = e as CustomEvent<{
        tags: string[];
        isBackBtn: boolean;
      }>;
      if (!customEvent.detail) return;
      /**
       * 여기 값이 절대 진리 값
       * 순회하고
       * 동기화하고
       * ui에 내용 반영
       */
      const tags = customEvent.detail.tags;
      this.urlBinding.tags = new Set([...tags]);
      this.lookup.sycnTags(tags);

      const isBack = customEvent.detail.isBackBtn;
      if (isBack) {
        updateBlogListUIOnece();
      }
    });
  }
  // ... 생략
}
```

 -->

[^1]: vue의 tick 사이클 비슷합니다.
