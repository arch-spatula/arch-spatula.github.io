---
title: '2025년 AOC를 zig로 풀어보자'
authors: [arch-spatula]
tags: ['advent of code', 'zig']
description: '올해 advent of code는 zig라는 언어를 활용해서 풀어볼 것입니다.'
draft: true
date: 2025-12-01
---

# 2025년 AOC를 zig로 풀어보자

- 모든 풀이는 [여기 레포](https://github.com/arch-spatula/2025-aoc-zig)에 있습니다.

## zig라는 언어를 고른 이유

- [Advent Of Code](https://adventofcode.com/)는 개발자 매년 배워보고 싶은 언어를 배워보는데 활용하는 수단에 불과합니다.
  - 올해는 특이하게 13일까지 문제를 냅니다. 보통 1일부터 크리스마스 당일인 25일까지 50개의 문제를 출제했습니다.
  - 어떤 사람은 이것을 엑셀로 푼다고 합니다. 사고력은 프로그래머인데 사용하고자 하는 툴이 엑셀이라는 점에서 낭민이 미친 것 같습니다.
- c++는 언의 GOAT라고 하지만 이상한 부분이 많아 보여서 피하고 싶었습니다. 2024년에 c++로 문제를 풀어보려고 했는데 ai 사용하지 않고 풀려고 하니까 오히려 너무 어려웠습니다. 나중에 다시 볼 생각은 있습니다. 물론 AI의 많은 도움을 받아서 토큰을 상당히 많이 사용할 것 같습니다.
- 2023년에는 gleam을 시도했던 것 같습니다. 하지만 뭐 만들어보고 싶었던 것이 없어서 결국 익숙해지지 않았습니다.
- go 혹은 java는 이글을 작성해보기 전까지 사용해볼 생각을 안 하고 있었습니다.
- rust는 wokeism이 극단에 치달은 커뮤니티 때문에 피하고 싶었습니다. 저의 취향이 기득권이라고 어그로를 끌 가능성이 높아서 그렇습니다.
- swift도 이 글을 쓰기 전까지 특별히 생각하지 않았습니다.
- 계층이 낮은 언어를 1개 정도 배워야 진정한 개발자로 거듭난다고 무슨 유튜브 동영상을 본것이 있어서 zig를 생각했습니다. odin도 있지만 zig가 더 단순할 것 같아서 zig를 활용해보고자 합니다. odin도 언젠가 다룰지 고민해볼 것입니다.
- ai를 사용할 것인가요?
  - 네 사용할 것입니다. zig 문법을 질문하기 위해 사용할 것입니다.
  - 또 문제를 어떻게 풀어볼지 방향을 알려달라고 하기 위해 사용할 것입니다.

---

## 1일차

- 자주 느끼는 것 중 하나지만 여기서 어려운 것은 번역같습니다.

```txt
L68
L30
R48
L5
R60
L55
L1
L99
R14
L82
```

- 퍼즐의 예시 입력 값입니다. 이것부터 난관입니다. 여러개의 줄바꿈 문자열을 표현하는 것이 다릅니다.

```zig
// 줄바꿈이 있는 문자열 선언
    const input =
        \\L68
        \\L30
        \\R48
        \\L5
        \\R60
        \\L55
        \\L1
        \\L99
        \\R14
        \\L82
    ;
```

- 위처럼 선언해줘야 합니다.
- 이 문자열의 줄바꿈을 이렇게 표현하는데 이유는 무엇일까? 다양한 운영체제별로 줄바꿈 문자열처리의 난해함 때문에 이런 일이 있었을 것 같습니다.
  - 이 줄바꿈 문자열이 `\n`이라는 것은 당연한데 windows는 `\r\n`이라고 합니다. 회사에서 windows를 사용하면서 알게 된 충격적인 사실입니다.
  - 운영체제별로 이런 추상화는 C 언어를 통해서 알 수 있었을 것입니다.

```zig
const input = @embedFile("input.txt");
```

- 이렇게 하면 파일을 임베딩할 수 있다고 합니다.
- 컴파일을 하면서 프로그램이 얼만큼의 문자열 크기가 필요한지 알기 때문에 내부적으로 처리해주는 것 같습니다.
- 이렇게 되면 타입은 `[] const u8`이 됩니다.

```zig
var it = std.mem.tokenizeScalar(u8, input, '\n');
```

- 줄단위로 문자열을 분리할 때는 위처럼 합니다.
- `std.mem`는 메모리 관련된 표준라이브러리를 의미한다고 합니다.
- 아마 `u8`에 해당하는 각 원소를 얻는 것인지 `[] const u8`의 원소를 얻는 것인지 잘 모르겠습니다.

```zig
const std = @import("std");

pub fn process(input: []const u8) !i32 {
    var it = std.mem.tokenizeScalar(u8, input, '\n');
    var dial: i32 = 50;
    var countZero: i32 = 0;
    while (it.next()) |line| {
        // 문자열 첫 문자 판단
        const firstChar = line[0];
        switch (firstChar) {
            'L' => {
                // 첫번째 이후 문자열을 숫자로 변환
                var number = try std.fmt.parseInt(i32, line[1..], 10);
                while (number > 0) {
                    dial -= 1;
                    if (dial < 0) {
                        dial = 99;
                    }
                    number -= 1;
                }
                if (dial == 0) {
                    countZero += 1;
                }
            },
            'R' => {
                var number = try std.fmt.parseInt(i32, line[1..], 10);
                while (number > 0) {
                    dial += 1;
                    if (dial > 99) {
                        dial = 0;
                    }
                    number -= 1;
                }
                if (dial == 0) {
                    countZero += 1;
                }
            },
            else => {
                std.debug.print("Unknown\n", .{});
            },
        }
    }

    return countZero;
}
```

- `next`를 호출한다는 것을 봤을 때 언어가 루프돌 때 이터레이터를 돌고 있는 것으로 보입니다.
- 일단 이것이 정답으로 보입니다.
- `try`라는 것이 상당히 특이합니다. 컴파일 타임에 에러를 만들 가능성이 있는 것을 알려줍니다.
- 에러가 발생할 가능성이 있으면 반환 타입에 느낌표(`!`)를 붙여야 합니다.
- zig라는 언어에서 마음에든 것은 switch case 문같습니다.
