"use strict";(self.webpackChunkarch_spatula_github_io=self.webpackChunkarch_spatula_github_io||[]).push([[96840],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>g});var r=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=r.createContext({}),u=function(e){var n=r.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},c=function(e){var n=u(e.components);return r.createElement(l.Provider,{value:n},e.children)},m="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},f=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),m=u(t),f=a,g=m["".concat(l,".").concat(f)]||m[f]||p[f]||o;return t?r.createElement(g,s(s({ref:n},c),{},{components:t})):r.createElement(g,s({ref:n},c))}));function g(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,s=new Array(o);s[0]=f;var i={};for(var l in n)hasOwnProperty.call(n,l)&&(i[l]=n[l]);i.originalType=e,i[m]="string"==typeof e?e:a,s[1]=i;for(var u=2;u<o;u++)s[u]=t[u];return r.createElement.apply(null,s)}return r.createElement.apply(null,t)}f.displayName="MDXCreateElement"},99742:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>u});var r=t(87462),a=(t(67294),t(3905));const o={sidebar_position:4,description:"\ube48\ub3c4\uc218 \uc138\uae30",tags:["\ube48\ub3c4\uc218 \uc138\uae30","frequency counter","\ubb38\uc81c \uc720\ud615"]},s="\ube48\ub3c4\uc218 \uc138\uae30",i={unversionedId:"algorithms-and-data-structures/frequency-counter",id:"algorithms-and-data-structures/frequency-counter",title:"\ube48\ub3c4\uc218 \uc138\uae30",description:"\ube48\ub3c4\uc218 \uc138\uae30",source:"@site/diy-cs/algorithms-and-data-structures/frequency-counter.md",sourceDirName:"algorithms-and-data-structures",slug:"/algorithms-and-data-structures/frequency-counter",permalink:"/diy-cs/algorithms-and-data-structures/frequency-counter",draft:!1,tags:[{label:"\ube48\ub3c4\uc218 \uc138\uae30",permalink:"/diy-cs/tags/\ube48\ub3c4\uc218-\uc138\uae30"},{label:"frequency counter",permalink:"/diy-cs/tags/frequency-counter"},{label:"\ubb38\uc81c \uc720\ud615",permalink:"/diy-cs/tags/\ubb38\uc81c-\uc720\ud615"}],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4,description:"\ube48\ub3c4\uc218 \uc138\uae30",tags:["\ube48\ub3c4\uc218 \uc138\uae30","frequency counter","\ubb38\uc81c \uc720\ud615"]},sidebar:"tutorialSidebar",previous:{title:"\ubc31\ud2b8\ub808\ud0b9",permalink:"/diy-cs/algorithms-and-data-structures/backTrack"},next:{title:"\uad6c\ud604",permalink:"/diy-cs/algorithms-and-data-structures/implementation"}},l={},u=[{value:"\ucd5c\ube48\uac12 \uad6c\ud558\uae30",id:"\ucd5c\ube48\uac12-\uad6c\ud558\uae30",level:2},{value:"1\ucc28 \ub274\uc2a4 \ud074\ub7ec\uc2a4\ud130\ub9c1",id:"1\ucc28-\ub274\uc2a4-\ud074\ub7ec\uc2a4\ud130\ub9c1",level:2}],c={toc:u},m="wrapper";function p(e){let{components:n,...t}=e;return(0,a.kt)(m,(0,r.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"\ube48\ub3c4\uc218-\uc138\uae30"},"\ube48\ub3c4\uc218 \uc138\uae30"),(0,a.kt)("p",null,"\ube48\ub3c4\uc218 \uc138\uae30(frequency counter)\ub294 \ub4f1\uc7a5 \ud69f\uc218\ub97c \uae30\ub85d\ud558\ub294 \ubb38\uc81c \uc720\ud615\uc785\ub2c8\ub2e4. ",(0,a.kt)("inlineCode",{parentName:"p"},"Map")," \ubb38\uc81c\ub791 \uacb9\uce58\ub294 \uacbd\uc6b0\uac00 \ub9ce\uc2b5\ub2c8\ub2e4."),(0,a.kt)("h2",{id:"\ucd5c\ube48\uac12-\uad6c\ud558\uae30"},"\ucd5c\ube48\uac12 \uad6c\ud558\uae30"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://school.programmers.co.kr/learn/courses/30/lessons/120812"},"\ucd5c\ube48\uac12 \uad6c\ud558\uae30 - \ud504\ub85c\uadf8\ub798\uba38\uc2a4")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"/**\n * @param {number[]} array\n * @returns {number}\n */\nfunction solution(array) {\n  var answer = 0;\n  return answer;\n}\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"import solution from './playground';\nimport { test, expect, describe } from 'vitest';\n\n// array                result\n// [1, 2, 3, 3, 3, 4]   3\n// [1, 1, 2, 2]       -1\n// [1]                1\n\ndescribe('\ucd5c\ube48\uac12 \uad6c\ud558\uae30', () => {\n  test('\uc608\uc81c 1', () => {\n    expect(solution([1, 2, 3, 3, 3, 4])).toBe(3);\n  });\n  test('\uc608\uc81c 2', () => {\n    expect(solution([1, 1, 2, 2])).toBe(-1);\n  });\n  test('\uc608\uc81c 3', () => {\n    expect(solution([1])).toBe(1);\n  });\n});\n")),(0,a.kt)("details",null,(0,a.kt)("summary",null,"2023\ub144 09\uc6d4 01\uc77c"),(0,a.kt)("div",{markdown:"1"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"/**\n * @param {number[]} array\n * @returns {number}\n */\nfunction solution(array) {\n  const memo = new Map();\n\n  array.forEach((elem) => {\n    if (memo.get(elem) === undefined) memo.set(elem, 1);\n    else memo.set(elem, memo.get(elem) + 1);\n  });\n\n  let modeCount = 0;\n  let modeValue = 0;\n  memo.forEach((value, key) => {\n    if (modeCount < value) {\n      modeValue = key;\n      modeCount = value;\n    }\n  });\n\n  let maxDouble = 0;\n  memo.forEach((value, key) => {\n    if (value === modeCount) maxDouble += 1;\n  });\n  if (maxDouble >= 2) return -1;\n\n  return modeValue;\n}\n")))),(0,a.kt)("h2",{id:"1\ucc28-\ub274\uc2a4-\ud074\ub7ec\uc2a4\ud130\ub9c1"},"[1\ucc28]"," \ub274\uc2a4 \ud074\ub7ec\uc2a4\ud130\ub9c1"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://school.programmers.co.kr/learn/courses/30/lessons/17677"},"[1\ucc28] \ub274\uc2a4 \ud074\ub7ec\uc2a4\ud130\ub9c1")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"function solution(str1, str2) {\n  var answer = 0;\n  return answer;\n}\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"import solution, { getIntersection, getUnion } from './playground';\nimport { test, expect, describe } from 'vitest';\n\n// str1       str2        answer\n// FRANCE       french      16384\n// handshake    shake hands 65536\n// aa1+aa2    AAAA12        43690\n// E=M*C^2    e=m*c^2       65536\n\ndescribe('\ub274\uc2a4 \ud074\ub7ec\uc2a4\ud130\ub9c1', () => {\n  test('\uc608\uc81c 1', () => {\n    expect(solution('FRANCE', 'french')).toBe(16384);\n  });\n  test('\uc608\uc81c 2', () => {\n    expect(solution('handshake', 'shake hands')).toBe(65536);\n  });\n  test('\uc608\uc81c 3', () => {\n    expect(solution('aa1+aa2', 'AAAA12')).toBe(43690);\n  });\n  test('\uc608\uc81c 4', () => {\n    expect(solution('E=M*C^2', 'e=m*c^2')).toBe(65536);\n  });\n});\n")),(0,a.kt)("details",null,(0,a.kt)("summary",null,"\ucd94\uac00 \ud14c\uc2a4\ud2b8 \ucf54\ub4dc"),(0,a.kt)("div",{markdown:"1"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"describe('helper', () => {\n  test('getUnion - 1', () => {\n    expect(\n      getUnion(['fr', 'ra', 'an', 'nc', 'ce'], ['fr', 're', 'en', 'nc', 'ch'])\n    ).toEqual(['fr', 'ra', 'an', 'nc', 'ce', 're', 'en', 'ch']);\n  });\n  test('getUnion - 2', () => {\n    expect(getUnion(['aa', 'aa'], ['aa', 'aa', 'aa'])).toEqual([\n      'aa',\n      'aa',\n      'aa',\n    ]);\n  });\n  test('getIntersection - 1', () => {\n    expect(\n      getIntersection(\n        ['FR', 'RA', 'AN', 'NC', 'CE'],\n        ['FR', 'RE', 'EN', 'NC', 'CH']\n      )\n    ).toEqual(['FR', 'NC']);\n  });\n  test('getIntersection - 2', () => {\n    expect(getIntersection(['aa', 'aa'], ['aa', 'aa', 'aa'])).toEqual([\n      'aa',\n      'aa',\n    ]);\n  });\n});\n")))),(0,a.kt)("details",null,(0,a.kt)("summary",null,"2023\ub144 10\uc6d4 05\uc77c \uc2dc\ub3c4"),(0,a.kt)("div",{markdown:"1"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"/**\n * @param {string} str1\n * @param {string} str2\n * @returns {number}\n */\nfunction solution(str1, str2) {\n  // \ubaa8\ub450 \uc18c\ubb38\uc790 \ucc98\ub9ac\n  // 2\uac1c \ucabc\uac1c\uae30\n  const leftList = splitByTwo(str1.toUpperCase());\n  const rightList = splitByTwo(str2.toUpperCase());\n\n  // \uad50\uc9d1\ud569\n  const intersectionSet = getIntersection(leftList, rightList);\n\n  // \ud569\uc9d1\ud569\n  const unionSet = getUnion(leftList, rightList);\n\n  // \ubd84\ubaa8 \uc0ac\uc774\uc988 0\ub300\uc751\ud558\uae30\n  if (unionSet.length === 0) return 65536;\n  return parseInt((intersectionSet.length / unionSet.length) * 65536);\n}\n\n/**\n * @param {string} str\n * @returns {string[]}\n */\nfunction splitByTwo(str) {\n  const result = [];\n  for (let i = 0; i < str.length - 1; i += 1) {\n    const item = str.slice(i, i + 2);\n    // \uacf5\ubc31\uc774\ub098 \uc22b\uc790, \ud2b9\uc218 \ubb38\uc790 -> \ubb38\ub098\uc5f4\ub9cc \ud574\ub2f9\ud558\ub294 \uc815\uaddc\ud45c\ud604\uc2dd\n    if (/^[a-zA-Z]+$/.test(item)) result.push(item);\n  }\n  return result;\n}\n\n/**\n * @param {string[]} set1\n * @param {string[]} set2\n * @returns {string[]}\n */\nfunction getIntersection(set1, set2) {\n  // \ube48\ub3c4\uc218 \uce74\uc6b4\ud130\n  /** @type {Map<string, {left: number, right: number}>} */\n  const memo = new Map();\n  set1.forEach((elem) => {\n    const pointer = memo.get(elem);\n    if (pointer)\n      memo.set(elem, { ...pointer, left: pointer.left + 1, right: 0 });\n    else memo.set(elem, { ...pointer, left: 1, right: 0 });\n  });\n  set2.forEach((elem) => {\n    const pointer = memo.get(elem);\n    if (pointer) memo.set(elem, { ...pointer, right: pointer.right + 1 });\n    else memo.set(elem, { ...pointer, right: 1 });\n  });\n  const result = [];\n  memo.forEach((value, key) => {\n    const left = value.left;\n    const right = value.right;\n    if (left > right) result.push(...Array.from({ length: right }, () => key));\n    else result.push(...Array.from({ length: left }, () => key));\n  });\n\n  return result;\n}\n\n/**\n * @param {string[]} set1\n * @param {string[]} set2\n * @returns {string[]}\n */\nfunction getUnion(set1, set2) {\n  // \ube48\ub3c4\uc218 \uce74\uc6b4\ud130\n  /** @type {Map<string, {left: number, right: number}>} */\n  const memo = new Map();\n  set1.forEach((elem) => {\n    const pointer = memo.get(elem);\n    if (pointer)\n      memo.set(elem, { ...pointer, left: pointer.left + 1, right: 0 });\n    else memo.set(elem, { ...pointer, left: 1, right: 0 });\n  });\n  set2.forEach((elem) => {\n    let pointer = memo.get(elem);\n    if (!pointer || !pointer.left) memo.set(elem, { ...pointer, left: 0 });\n    pointer = memo.get(elem);\n    if (pointer.right) memo.set(elem, { ...pointer, right: pointer.right + 1 });\n    else memo.set(elem, { ...pointer, right: 1 });\n  });\n\n  const result = [];\n  memo.forEach((value, key) => {\n    const left = value.left;\n    const right = value.right;\n    if (left < right) result.push(...Array.from({ length: right }, () => key));\n    else result.push(...Array.from({ length: left }, () => key));\n  });\n  return result;\n}\n\nexport default solution;\n\nexport { getUnion, getIntersection, splitByTwo };\n")),(0,a.kt)("p",null,"\ubaa8\ubc94\uc815\ub2f5\uc774 \uc544\ub2d9\ub2c8\ub2e4."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"function solution(str1, str2) {\n  function explode(text) {\n    const result = [];\n    for (let i = 0; i < text.length - 1; i++) {\n      const node = text.substr(i, 2);\n      if (node.match(/[A-Za-z]{2}/)) {\n        result.push(node.toLowerCase());\n      }\n    }\n    return result;\n  }\n\n  const arr1 = explode(str1);\n  const arr2 = explode(str2);\n  const set = new Set([...arr1, ...arr2]);\n  let union = 0;\n  let intersection = 0;\n\n  set.forEach((item) => {\n    const has1 = arr1.filter((x) => x === item).length;\n    const has2 = arr2.filter((x) => x === item).length;\n    union += Math.max(has1, has2);\n    intersection += Math.min(has1, has2);\n  });\n  return union === 0 ? 65536 : Math.floor((intersection / union) * 65536);\n}\n")))))}p.isMDXComponent=!0}}]);