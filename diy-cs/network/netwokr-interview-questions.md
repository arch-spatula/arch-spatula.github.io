---
sidebar_position: 1
description: '네트워크 면접 질문'
tags: ['네트워크', '면접 질문']
---

# 네트워크 면접 질문

<!-- https://github.com/arch-spatula/technical-interview-for-FE/blob/main/%EB%A9%B4%EC%A0%91%EC%A7%88%EB%AC%B8/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC.md -->

## 🌟🌟🌟🌟🌟

<details>
<summary> https://naver.com을 주소창에 입력했을 때 일어나는 과정에 대해 아는 만큼 설명해주실 수 있을까요?</summary>

<div markdown="1">

답변일자: 2023.03.20.

브라우저는 URL 정보를 갖고 IP를 정보를 얻어야 합니다. 제일 먼저 브라우저의 캐시를 확인하고 캐시 미스가 발생하면 운영체제에 캐시된 정보를 찾습니다. 운영체제도 캐시 미스가 발생하면 인터넷 쿼리 요청을 보냅니다. 제일먼저 DNS 서버는 요청을 받으면 DNS lookup으로 도메인에 해당하는 IP있는지 확인합니다. 캐시미스가 발생하면 다른 DNS 서버로 캐시히트로 Resolve가 발생할 때까지 요청을 연쇄적으로 보냅니다. 캐시히트가 발생하고 브라우저가 IP 정보를 갖으면 브라우저는 해당하는 IP 주소의 서버와 TCP 통신을 연결하게 됩니다. 연결하기 위해 몇 회 왕복하는 과정을 보고 TCP 핸드 쉐이크라고 부릅니다. TCP로 연결에 성공하면 클라이언트는 서버로 http 요청을 보내게 됩니다. 여기서 https로 요청을 보내게 되면 보안을 추가 단계들이 생깁니다. 브라우저는 리소스를 응답받고 처리하는데 자바스크립트 번들이나 이미지처럼 추가 리소스는 이 과정을 반복합니다.

답변일자: 2023.03.19.

브라우저는 엔진은 요청을 보내게 됩니다. 인터넷 선 혹은 와이파이로 신호를 보냅니다. 와이파이 혹은 인터넷 선은 인터넷 제공 사업자의 망을 통해 DNS 서버를 접근합니다. DNS는 도메인을 확인하고 IP로 변환하는 서버입니다. 또 DNS 서버는 자주 오는 요청을 캐싱하고 캐시힛이면 응답을 합니다. 하지만 캐시미스가 되면 다음 DNS 서버로 접근합니다. 계속 캐시미스가 발생하면 IP에 해당하는 서버에 도착하게 됩니다. 요청을 받은 서버는 요청 내용을 확인하고 클라이언트 IP로 응답을 보냅니다.

[What happens when you type a URL into your browser?](https://www.youtube.com/watch?v=AlkDbnbv7dk)

http 요청과 응답과정입니다.

먼저 사용자가 브라우저에 입력한 것은 URL입니다. URL은 Universal Resource Locator의 약어입니다. 크게 4부분으로 나눌 수 있습니다.

프로토콜 혹은 스키마입니다. http, https가 존재합니다. https는 연결시 보안됩니다. 다음은 도메인입니다. 세번째 부분은 path이고 네번째 부분은 Resource입니다. 이 관계는 파일시스템의 디렉토리와 유사합니다.

브라우저는 서버를 접근하는 법을 알아야 합니다. 이 이 과정은 DNS look업의 과정을 거칩니다. DNS는 도메인 네임 시스템의 약어입니다. 인터넷의 전화번호부와 같습니다. 도메인을 IP와 짝으로 확인합니다. DNS만 따로 다뤄야 할 서비스가 될 정도로 나중에 다룹니다. DNS lookup은 최대한 속도를 높이기 위해 캐싱이 많이 되어 있습니다. 먼저 브라우저도 짧은 시간동안 캐싱을 합니다. 캐시미스가 발생하면 운영체제에서 저장하고 있는지 접근합니다. 운영체제도 캐시가 또 있습니다. 운영체제도 없으면 인터넷으로 쿼리 요청을 보냅니다. DNS Resolver에 요청을 보내게 됩니다. 해당하는 IP를 찾을 때까지 연쇄적으로 요청을 보냅니다. DNS 인프라의 여러 서버들과 상호작용하고 접근하는 과정입니다. 접근하는 DNS 마다 응답을 캐싱하게 됩니다. 결국 브라우저는 DNS를 통해 IP 주소를 얻게 됩니다. 다음은 브라우저는 해당하는 서버와 TCP 통신을 연결합니다. TCP 통신을 연결할 때는 필요한 핸드쉐이크가 있습니다. 몇회의 네트워크 왕복이 필요합니다. 로딩 시간을 빠르게 하기 위해 현대 브라우저들은 keep alive connection을 활용합니다. 이미 서버랑 설정되었던 TCP 연결을 최대한 재사용하는 것입니다. 알아야할 것은 https는 TCP 연결을 하는 단계가 늘어납니다. SSL/TLS 핸드 쉐이크 과정이 필요합니다. 암호화된 연결을 브라우저와 서버 사이 만들어내기 위한 핸드 쉐이크 연산비용이 비쌉니다.

브라우저는 SSL 세션 재개를 활용해서 비용절약에 활용합니다. 마지막으로 브라우저는 연결 TCP 연결이 된 서버에 HTTP 요청을 보내게 됩니다. HTTP 자체는 비교적 단순한 프로토콜입니다.

서버는 요청을 처리하고 응답을 보냅니다.

브라우저는 응답을 받고 HTTP로 받은 리소스를 처리 및 랜더링합니다. 가끔은 추가로 처리할 리소스들이 있습니다. 자바스크립트 번들 및 이미지 같은 것들입니다. 남은 리소스를 얻기 위해 브라우저는 이 과정을 또 반복하게 됩니다.

---

[Everything You Need to Know About DNS (Domain Name System)](https://www.youtube.com/watch?v=27r4Bzuj5NQ)

DNS는 인터넷의 디렉토리입니다. 사람이 읽이 편한 네이버를 기계가 읽기 편한 IP 주소로 변환합니다. DNS 서버는 각각 다른 위계를 갖고 있습니다.

</div>
</details>

<details>
<summary>인터넷은 무엇인가?</summary>
<div markdown="1">

가장 큰 규모의 네트워크를 지칭하는 말입니다. WAN의 연결관계를 인터넷이라고 부를 수 있습니다. 가장 짧은 버전입니다.

</div>
</details>

<details>
<summary>OSI 7계층에 대해서 설명해주세요.</summary>
<div markdown="1">

OSI 7계층은 TCP/IP의 세분화된 것입니다. 각 계층의 역할을 이해할 수 있습니다. 각 계층의 역할 파악하면 문제를 더 쉽게 파악하는 것은 물론 다른 네트워크 및 클라우드 서비스 제공자와 커뮤니케이션하는 것도 쉬워집니다. OSI 7계층은 응용, 표현, 세션, 전송, 네트워크, 데이터 링크, 물리 계층으로 구분합니다. 물리 계층은 raw bit를 전기 신호로 전달하는 계층입니다. raw bit를 전기 신호로 인코딩과 디코딩합니다. 데이터 링크 계층에서는 hop을 위해 MAC Header로 출처와 목적지를 담고 frame을 캡슐화하고 전달합니다. 목적지는 다음 hop이고 hop마다 출처와 목적지가 갱신됩니다. MAC 주소는 기계의 주민등록 번호처럼 기계가 갖는 고유한 번호입니다. 네트워크 계층은 IP Header에 출처 IP와 도착지 IP를 담고 패킷으로 캡슐화하고 전달합니다. 여기서 IP는 비유적으로 전입신고한 주소에 해당합니다. MAC 주소는 기계마다 고유하지만 IP 주소는 기계를 이동하면 이사처럼 갱신됩니다. 물론 DHCP으로 설정되어 있을 때만 해당합니다. 전송 계층은 TCP/UDP로 TCP Header 혹은 UDP Header를 추가하고 세그먼트로 캡슐화하고 전달합니다. 출처의 포트, 목적지의 포트, 패킷 시퀀스 번호를 담습니다. 또 로드 벨런싱도 처리하게 하는 경우도 있습니다. 세션 계층은 SSH, TLS같은 통신방식과 통신여부 처리합니다. 표현계층은 인디코딩과 디코딩을 처리하고 인코딩과 디코딩을 위한 바이너리 데이터를 전달합니다. 응용계층에서는 프로그램에 해당하는 프로토콜을 주고 받게 되는 계층으로 사용자의 최초 정보가 해당합니다.

응용, 표현, 세션 계층은 사용자를 지원하는 계층입니다. 네트워크, 데이터 링크, 물리 계층은 네트워크를 지원 계층입니다. 중간 전송 계층은 사용자와 네트워크 지원 계층을 연결합니다.

---

[What is OSI Model | Real World Examples](https://www.youtube.com/watch?v=0y6FtKsg6J4)

인터넷은 어떻게 데이터를 보내고 OSI 7계층과 무슨 연관이 있는가? 그리고 TCP/IP는 어떻게 중간에 들어가는가? OSI 7계층은 네트워크를 다루는 표준 모델입니다. 2개의 기기의 통신과정을 7단계로 추상화한 것입니다. 1계층은 물리 계층입니다. 바이너라 같은 raw 데이터를 전달합니다. 2계층은 데이터 링크 계층입니다. raw 데이터를 받아 MAC Header, IP Header, TCP Header, HTTP Header, Data 같은 프레임으로 변환합니다. 프레임이 올바른 곳으로 전달되도록 보증합니다. 이 계층에 이더넷이 위치합니다. 3계층은 네트워크 계층입니다. 다양한 네트워크에 따라 데이터 프레임을 라우팅하는 책임을 집니다. 이부분의 TCP/IP 중 IP 부분이 여기 해당합니다. 4계층은 전송 계층입니다. 2개 Node 사이 E2E 커뮤니케이션을 보장합니다. 이 계층에 TCP/UDP가 속합니다. TCP 통신은 2 기계사이 E2E 통신을 신뢰할 수 있게 해줍니다. 데이터를 전송할 때 세그먼트로 작게 쪼개서 전달합니다. 세그먼트 각각 독립적으로 전달합니다. 또 세그먼트마다 고유한 시퀀스번호도 붙입니다. 받은 쪽은 전달받은 데이터의 순서를 올바르게 정리하기 위해 활용합니다. TCP는 또 전송 중에 데이터에 손상이 있었는지 에러 체크도 처리합니다. UDP는 전송계층에서 사용하는 또 다른 프로토콜입니다. TCP와 비슷하지만 더 단순하고 더 빠릅니다. TCP랑 다르게 높은 수준의 에러체킹과 신뢰성 검증을 하지 않습니다. 단순히 하나의 기계에서 다른 기계로 패킷을 전달해 줍니다. 전달 받은 쪽이 올바르게 받았는지 검토하는 책임만 갖고 있습니다. 에러가 있으면 받는 쪽이 단순히 패킷을 버리기만 합니다. 남은 계층은 세션, 프레젠테이션, 어플리케이션 계층입니다. 여기서 OSI 모델의 유용성을 실무에서 잃는 부분입니다. 더무 디테일하게 정해져있지만 현실을 잘 반영하지 않습니다. 일반적으로 하나의 계층으로 합치는 경우가 많습니다. 마지막 7계층 어플리케이션 프로토콜 계층으로만 취급하는 것이 현실적입니다.

사용자 네트워크로 HTTP요청을 보내면 HTTP Header가 어플리케이션 계층에서 데이터의 Header에 추가됩니다. 그 후 TCP Header가 4계층에서 추가됩니다. TCP Header는 TCP 세그먼트로 캡슐화되어 있습니다. TCP Header 속에는 출처 포트, 목적지 포트, 시퀀스 번호를 저장합니다. 이 세그먼트들은 3계층 네트워크 계층에서 IP Header로 캡슐화합니다. IP Header는 출처와 목적지 IP를 담습니다. MAC Header는 2계층 데이터 링크 계층에서 추가됩니다. 출처와 목적지 MAC 주소를 담습니다. MAC 주소는 현실세계에서 약간 미묘하게 다릅니다. 사실 출처와 목적지 MAC 주소를 담지 않습니다. 다음 hop을 하게될 MAC 주소입니다. 캡슐화된 프레임은 raw bit로 1계층 물리계층에서 전송이 됩니다. 응답을 받은 기계는 이 순서의 역순으로 처리합니다.

OSI 계층은 네트워크를 하나의 방향으로 생각할 수 있는 모형입니다. 주목적은 교육용입니다. 클라우드 및 네트워크 서비스 제공자들이 어느 단계에 서비스를 제공하는지 간단하게 알려줄 수 있는 모형입니다. 예를 들어 클라우드 로드 벨런서는 2개로 분류할 수 있습니다. L4, L7이 있는 L7은 HTTP, HTTPS 같은 어플리케이션 계층에서 로드 벨런싱을 처리한다는 의미로 보면 됩니다. L4는 TCP 프로콜에서 로드 벨런싱을 처리한다는 의미입니다.

- 각 계층 장비는 아래 레이어를 포함하는 구조

  - 1계층(L1) 장비는 1계층 기능만 가진 장비이다. (인코더/디코더)
  - 2계층(L2) 장비는 1~2계층 기능을 모두 가진 장비이다. (L2스위치 / MAC주소)
  - 3계층(L3) 장비는 1~3계층 기능을 모두 가진 장비이다. (라우터 = 중계노드 / IP주소)
  - 4계층(L4) 장비는 1~4계층 기능을 모두 가진 장비이다. (L4로드밸런서 / 포트)
  - 7계층(L5) 장비는 1~7계층 기능을 모두 가진 장비이다. (컴퓨터, 핸드폰)

- 프로토콜 서비스 별 포트 번호
  - 웹 서비스 **(HTTP, HTTPS) : 80, 443**
  - 파일 전송 서비스**(FTP): 21**
  - 이메일 서비스**(SMT, POP3): 25, 110**
  - 도메인 서비스**(DNS): 53**

1. 📡 물리 계층
   - 🚦규칙 : Hub, Repeater
   - 🧩단위 : 비트 (Bit)
2. ⛓️ 데이터 링크 계층
   - 🚦규칙 : MAC 주소
   - 🧩단위 : 프레임 (Frame)
3. 🎯 네트워크 계층
   - 🚦규칙 : IP
   - 🧩단위 : 패킷 (Packet)
4. 🔐 전송 계층
   - 🚦규칙 : TCP, UDP
   - 🧩단위 : 세그먼트(Segment)
5. ⛳️ 세션 계층
   - 🚦규칙 : OS
   - 🧩단위 : 데이터(Data)
6. 🗂️ 표현 계층
   - 🚦규칙 : JPG, MPEG
   - 🧩단위 : 데이터(Data)
7. 👩‍💻 응용 계층
   - 🚦규칙 :
     - HTTP = 웹 접근 프로토콜
     - FTP = 파일 전송 프로토콜
     - Telnet = 통신 프로토콜 (단말 접속용)
   - 🧩단위 : 데이터(Data)

![image](https://user-images.githubusercontent.com/84452145/227761621-82b86370-75da-44f0-9961-5df85342a139.png)

</div>
</details>

## ⭐⭐⭐⭐

## ⭐⭐⭐

## ⭐⭐

## ⭐

<details>
<summary>네트워크란 무엇이고 인터넷, LAN, WAN 이외에 다른 네트워크는 무엇이 존재하는가?</summary>
<div markdown="1">

네트워크란 2대 이상의 컴퓨터의 연결을 말합니다.

MAN, 블루투스 네트워크, 셀룰러 네트워크

</div>
</details>

## ❓

통신에서 프로토콜 혹은 스키마란 무엇인가? 그리고 각각 대표적인 특징을 알려주세요.

## CDN이란 뭔가요?

CDN은 유저의 요청에 대한 캐시와 비슷합니다. HTTP 요청을 활용하고 있다면 동일한 콘텐츠에 대해서 캐싱을 시키고 동일한 콘텐츠 요청이 또 발생하면 엣지 서버(POP)에서 바로 응답하게 됩니다.

[What Is A CDN? How Does It Work?](https://www.youtube.com/watch?v=RI9np1LWzqw)

- CDN이란 무엇이고 왜 사용하는가?
- 놀랍게도 1998년대에도 사용중이었습니다. 원래 정적인 HTML 페이지를 빠르게 전달하기 위해 만들어졌습니다.
- CDN은 엄청나게 발전했습니다. CDN은 HTTP로 트레픽이 발생하면 자주 활용합니다.
- 모던 CDN은 근본적으로 또 물리적으로 사용자에게 콘텐츠를 더 가까운 곳에서 제공합니다. 웹 서비스 성능이 좋아집니다.
- CDN은 세계적으로 서버가 많이 위치하고 있습니다. 이런 서버들을 보고 Pop(Point of Presence)라고 합니다. Pop 속에 있는 서버를 흔히 엣지 서버라고 부릅니다.
- 글로벌 단위 제품에서 Pop을 다양한 곳에 위치시켜야 유저가 빠르게 접근할 수 있게 해줍니다.
- CDN마다 사용하는 기술은 모두 다릅니다. 하지만 공통적으로 가장 가까운 Pop으로 가도록 하는 결과만 같습니다.
- 많이 사용하는 요청은 DNS 기반 라우팅과 Anycast입니다.
  - DNS 기반라우팅은 각각의 Pop이 각각 IP 주소를 갖습니다. 사용자가 CDN IP를 조회하면 DNS는 가장 가까운 Pop IP를 반환합니다.
  - Anycast에서는 모든 Pop들이 같은 IP 주소를 공유합니다. 만약 요청이 Anycast 네트워크로 발생하면 네트워크는 가장 가까운 Pop으로 보냅니다.
- 각각의 엣지서버는 콘텐츠 캐시를 보유하면서 리버스 프록시처럼 행동합니다.
  - 정적인 콘텐츠는 엣지서버에 캐싱시킵니다. 이것은 콘텐츠 캐시입니다. 만약 캐싱이 되어 있으면 유저가 빠르게 받을 수 있습니다.
  - 하지만 엣지서버는 콘텐츠 캐시의 복사본만 갖고 있습니다. 이렇게만 해도 오리진 서버의 로드와 대역폭을 줄입니다.
- 모던 CDN은 더 최적화된 형태로 보관할 수 있습니다. 자바스크립트 번들, 이미지 확장자 변경 등을 수행할 수 있습니다.
- 엣지서버는 현대 http 스택에 중요한 역할을 합니다.
- 모든 TLS 연결은 엣지에서 끊습니다. TLS 핸드쉐이크는 비쌉니다. 엣지에서 끊으면 유저에게 지연시간이 덜 발생합니다.
  - 이런 이유로 캐싱할 수 없고 동적인 콘텐츠도 캐싱하려고 합니다.
- 성능 이외의 이점도 존재합니다. 대규모 DDos 공격으로부터 방어가 가능합니다.
  - Anycast 네트워크 기반 CDN에 특히 더 효율적입니다. 공격 트레픽을 여러 서버로 나눌 수 있습니다.
- 안정성에서도 유리합니다. 하나의 하드웨어 서버 문제가 발생해도 그 다음으로 가까운 Pop에서 처리할 수 있습니다.
- 모던 CDN은 다양한 이점이 있습니다. HTTP로 트레픽이 발생하면 충분히 고민해볼만 합니다.

[What is a Content Delivery Network (CDN)?](https://www.youtube.com/watch?v=Bsq5cKkS33I)

- 아주 짧게 요약하자면 CDN은 콘텐츠 전달을 가속화하는 서비스입니다.
- 동작방식을 이해하기 전에 전세계에 유저가 있지만 서버는 없던 시대부터 다루겠습니다.
  - 물리적으로 서버 위치와 멀수록 요청과 응답시간이 더 걸릴 것입니다. CDN은 이런 상황에 필요합니다.
- 세계적유저가 이용하고 있으면 CDN의 종담점을 유저가 있는 곳마다 배치해야 합니다.
- 유저가 어떤 콘텐츠를 접근하려고 CDN 서비스로 먼저 접근합니다. 아직 CDN 서버로 받은 것은 아닙니다. 최초 요청이 있으면 오리진 서버는 엣지서버에게 유저가 요청한 콘텐츠를 캐싱시키도록 합니다. 이렇게 되면 동일한 콘텐츠를 요청한 유저는 캐시를 통해 확인하게 됩니다.
  - 여기서 생기는 장점은 엣지서버가 요청과 응답을 캐시하고 처리하기 때문에 오리진 서버의 부하가 덜 발생합니다.
  - 하나의 요청이 다른 엣지서버에 배포를 하게 됩니다.
- 오리진 서버의 부담이 덜하기 때문에 로드가 덜합니다. 또 가동시간도 처리량이 줄어서 좋아집니다. 또 모호함을 통해 보안상 보호도 받게 됩니다.
