---
layout: ../../layouts/MarkdownPostLayout.astro
title: "Redux is The Enemy"
pubDate: 2022-12-01
description: "저의 주적은 Redux입니다. 그리고 적을 제거하기 위해서 적을 공부하는 아티클입니다. 리덕스를 테스팅하고 리팩토링하는 방법론을 다루겠습니다."
author: "Arch Spatula"
tags: ["Redux", "Refactoring", "Testing"]
draft: true
---

# 리덕스는 왜 적이 되는가?

최소한 저의 코드 취향에 대한 적입니다. 이 글에서 정의한 문제 정하는 기준은 저의 주관입니다. 리덕스의 보일러 플레이트를 좋아하는 취향은 존재합니다. 그런 분들은 Java와 C++를 또 엄청나게 사랑합니다. 상당히 뛰어난 언어입니다. 하지만 새롭게 프로젝트를 시작하면 사용할 이유가 시니어 엔지니어가 익숙한 언어라는 것만이 이유가 될 것입니다. 당연히 이 이유도 엄청난 이유가 됩니다. 시니어 엔지니어의 노하우를 얻고 효율적으로 활용하는데 효율을 상당히 많이 포기하게 되는 것입니다. 이런 부분은 존중할 수 있습니다.

저는 연약한 유사개발자여서 리덕스를 상당히 싫어합니다. 또 이 리덕스 생태계의 성장을 최대한 대항하고자 합니다. 하지만 리덕스는 2022년 기준 산업 표준입니다. 이것은 사실입니다.

# 리덕스의 이유

## 리덕스를 사용했던 이유

State Management를 할 때 prop drilling의 한계를 극복하기 위해 사용합니다. 물론 리액트를 출시하면서 이런 제약을 극복할 프레임워크는 같이 탄생했을 것입니다.

당시 생태계에 대한 자료를 추가로 조사하겠습니다.

## 지금도 사용하는 이유

## 앞으로도 사용할 이유

이미 너무 많은 코드를 리덕스로 작성했고 복잡성의 규모가 너무 거대해서 리팩토링하기 어려워 그 복잡성을 수용하기로 결정했다면 어쩔 수 없을 것입니다. 아직도 네이버에 제이쿼리가 남은 것과 비슷한 이치입니다.

많은 교육기관은 리덕스가 산업표준인 것을 알고 리덕스로 교육합니다.

# 리덕스 현실의 유스케이스

현실에서 다루는 리덕스 유스케이스는 상당히 복잡합니다.

동일한 기능을 다른 라이브러리로 대체할 수 있습니다. 당연히 가능합니다. 고려사항이 순수한 개발경험이라면 본인의 사이드 프로젝트가 아닌 이상 권장하지 않습니다. 하지만 코드의 확장성상 갖을 수 있는 한계가 너무 많이 보이고 시기적으로 신기능 추가에 대한 요구사항이 줄어들었다면 적절할 것입니다. 리덕스도 당연히 확장가능하지만 확장성과 얻게 되는 코드의 복잡성의 증가량은 선형시간복잡성과 동일한 그래프를 그립니다. 다른 상태관리라이브러리를 활용하면 로그시간복잡성, 상수시간복잡성으로 점진적으로 낮출 수 있습니다.

리팩토링을 위한 테스트 전략입니다.
