---
title: '5월 원티드 챌린지'
authors: [arch-spatula]
tags: ['특강']
description: '????'
toc_max_heading_level: 6
draft: true
date: 2023-05-31
---

# 5월 원티드 챌린지

주제는 모노레포입니다.

<!--truncate-->

[React 프로젝트 설계 w 모노레포(MonoRepo) 시스템 - 5월 프론트엔드 챌린지](https://www.wanted.co.kr/events/pre_challenge_fe_9?category=tag.gaebal)

<!-- :::caution

저의 필기는 주관적이고 불친절합니다. 그리고 저만의 용어를 사용해서 부정확한 내용이 있을 것입니자. golang 기본문법과 아주 약간의 고루틴 개념만 갖고 있는 사람이 작성한 글입니다.

::: -->

# 강의

모노 레포란 무엇인가?

단단한 하나의 git 저장소

글이 많으면 노잼입니다.

nvm은 실무할 때 은근히 유용합니다. node의 다양한 버전에 따라 동작 여부가 달라질 수 있습니다. 시작은 NVM입니다. 사실 실습에는 문제는 없습니다.

yarn berry 실무에 유용합니다.

오늘 기준으로 yarn 버전은 1.22.19 나오면 괜찮습니다. 프로젝트를 만들면 버전이 달라집니다.

```sh
cd
```

```
.yarn
.pnp.cjs
.pnp.loader.mjs
.yarnrc.yml
yarn.lock
```

처음에 설정 잘못하면 위에 것들을 삭제해야 합니다.

`abumalick.vscode-nvm` 익스텐션을 받으면 `.nvmrc`에서 `lts/hydrogen`을 작성하면 18버전으로 자동 설정될 것입니다. 상당히 좋습니다. 로고가 없어서 id를 활용하도록 합니다.

yarn 2에서부터 모노레포를 지원하는 기능이 강해졌습니다. 1은 원래 지원하고 있었습니다.

`yarn init -w` 워크 스페이스 생성 명령입니다.

`packages`는 같이 공유할 패키지를 넣습니다. 관습은 `packages`라고 합니다. 그래서 자동생성됩니다.

`apps`는 이름을 무조건 따를 필요는 없습니다. `docs`로 문서화도 하는 경우도 있습니다.

설치한 json에 `"name": "@wanted/web",`으로 설정합니다. 이렇게 설정하면 `yarn workspace @wanted/web run dev` 으로 명령하면 모노레포에서 실행할 수 있습니다.

프로젝트 관리는 pnp.cjs에 보관합니다. apps 폴더에 설치 뒤에는 루트로 돌아와서 yarn 명령을 해야 합니다.

타입스크립트 lsp가 적용될 수 있도록 2가지 명령만 모노레포 루트에서 처리하면 됩니다.

순서는 설치 -> package.json 이름 변경 -> 루트에서 yarn 명령

```sh
yarn add -D typescript
yarn dlx @yarnpkg/sdks vscode
```

이렇게 VScode에 명령하고 타입스크립트를 감지할 수 있습니다.

arcanis.vscode-zipfs 이 익스텐션 추가도 권장합니다.

pnp.cjs는 중요한 파일입니다.

zero-install 전략도 있습니다.

.vscode 폴더는 설치 권장을 알려주게 만들 수 있습니다.

package 폴더 속에는 다른 레포들이 공유할 리소스를 담습니다.

lib 폴더를 만들고 yarn init을 합니다.

src는 공유할 파일을 담습니다. 프로젝트 사이 의존성을 만들 수 있습니다.

yarn workspace @wanted/web add @wanted/lib 이런 명령으로 하위 레포에 패키지를 전달할 수 있습니다.

yarn은 pnp의 반영명령입니다.

모노레포에서 어드민과 어플리케이션을 같이 만들 수 있습니다. 공통 라이브러리와 API 모델, 비즈니스로직 공유가 가능해집니다.

이제 이론입니다. 모노레포를 사용하는 케이스 대표적으로 3가지입니다. 개인적인 경험입니다.

1. 라이브러리 개발할 때 유용합니다. 바벨이 대표적입니다. 바벨 하위 프로젝트를 개별 설치하는 것이 가능합니다. 라이브러리 관리에 유용합니다. 또 디자인 시스템 도입도 모노레포로 많이 만듭니다.

radix-ui 라이브러리를 볼 수 있습니다.

2. 서비스 운영하는 예시입니다. B2B, B2C 어드민 하나로 합칠 때 유용합니다. 현재 원티드는 놀랍게도 폴리레포입니다. api 모델, 인증로직 중복작성하게 될 가능성이 있습니다.

배달의 민족에서 어드민, 오피스, 모바일 오피스로 구성하는 것처럼 적용하고 있습니다. 배달의 민족은 인싸라 pnpm을 활용하고 있습니다.

3. 마이크로 프론트엔드와 마이크로 서비스로 전향하기 유용합니다.

마이크로 서비스의 시대입니다. 최소한 성장한 기업입장에서는 맞습니다.

토스에는 30개의 서비스가 있었습니다. 하나의 모놀리스를 쪼갰습니다. 토스는 yarn workspace를 활용했습니다.

리액트앱을 마이크로 프론트엔드로 쪼개는데 모노레포를 활용했습니다.

모놀리스입니다.

단일 레포에서 여러 프로젝트로 쪼개는 전략입니다.

모노레포란 여러 개의 프로젝트를 개별 프로젝트를, 잘 정의된 관계를 통해서 하나의 레포에 담은 것입니다. 긱스 뉴스를 참고하기 바랍니다.

모놀리스랑 다르게 자율성이 있습니다. 각자 프로젝트가 원하는 라이브리를 자유롭게 사용할 수 있습니다. 폴리레포는 코드공유가 어렵습니다. 패키지 신버전 반영이 쉽습니다. 라이브러리의 파괘적인 반영을 지연시킬 수 있습니다. 라이브러리 변경에 참조파악이 쉽습니다. 대규모 리팩토링을 어디에 해야 할지 파악하기 수월합니다.

만약에 폴리레포는 매개변수가 추가되는 파괘적인 변경이 발생하면 연락을 일일이 취해야 합니다. 하지만 모노레포는 변경을 가한사람이 모두 변경해서 진행할 수 있습니다. 라이브러리 버전 변경 요청이 간소해진 점이 좋습니다.

모노레포의 장점 위주로 이야기했지만 단점도 있습니다.

- 개발환경을 구성하는데 초기투자를 해야 합니다. 배포를 어떻게 할지 이런 부분도 어렵습니다.
- 코드 소유권 개념이 모호해집니다. 담당자가 누구인지 애매해지는 상황이 쉽게 발생합니다.
  - 소스에 대한 책임과 무결성 문제가 될 수 있습니다.
- 리팩토링이 쉬워집니다. 이점이 장점이자 단점입니다. 너무 쉽게 변경을 가할 수 있으면 문제가 됩니다.
  - 대규모 리팩토링의 잘못된 관행을 조장합니다.

구글이 세계에서 제일큰 모노레포를 보유하고 있습니다.

깃허브가 풀 마이크로서비스로 전향한 점이 실수였다고 합니다.

서비스가 너무 많으면 소유권문제가 됩니다. 또 도구를 너무 많이 추가해야 합니다.

가능하면 모놀리스로 유지하고 모노레포로 분리를 시작하믄 큰것부터 쪼갭니다.

명령 파레트로 ts 서버 재시작으로 타입스크립트 lsp를 구동시킬 수 있습니다. 더이상 세팅 문제가 없으면 활용해보기를 권장합니다.

ESlint 서버도 재시작 구동이 가능합니다.

구성해볼 수 있는 전략은 apps에 프로젝트를 넣습니다. 그리고 디자인시스템, 타입스크립트의 타입, React-hook과 공통라이브러리를 packages에 넣습니다.

내일은 조금더 특이한 것을 시도합니다. 오늘 구성한 것을 베이스로 활용합니다. ESlint를 적용하고 타입스크립트 설정 컨벤션을 같이 가져갑니다. 모노레포의 장점을 활용합니다.

개발팀이 바뀌어도 어색하지 않게 적응할 수 있게 해줍니다.

개발팀이 바뀌어도 바로 진행할 수 있게 컴포넌트 공유도 시도해볼 것입니다. yarn barry를 활용하는데 다음주에는 타입체킹과 빌드하고 배포하고 github 액션 코드 공유도 진행합니다.

turborepo도 시도합니다. 세팅할 것이 없습니다. 세팅이 없어서 간편하고 그 편안함과 원리를 이해하기 위해 이렇게 설치하는 방법을 배워봅니다. 또 원리를 알아야 디버깅하기 쉽습니다.

yarn 1으로 workspace를 구성하는 것은 대부분 찾기 힘들어서 제외했습니다. 1에서 발생하는 차이는 의존성 주입할 때 cli로 주입할 수 없었습니다.

잘 알면 어렵지 않습니다. 잘못하면 세팅 지옥이 됩니다. 프로필 루트에서 명령하면 버전이 꼬일 수 있습니다. 공식문서는 쉽다는 쉽지 않습니다.

.yarnrc.yml에 nodeLinker를 pnp으로 설정하면 자동 지원됩니다. pnp 모드가 기본으로 지원됩니다. 지원하지 않으면

```yml
nodeLinker: 'pnp'
```

기본 설정입니다.

```yml
nodeLinker: 'node-modules'
```

원래 익숙한 node 모듈이 됩니다.

모노레포랑 웹성능은 당연히 관련이 없습니다. 그냥 레포관리법입니다.

모노레포에는 Nest.js를 같이 넣는 경우도 많이 있습니다. OpenAPI로 만든 레포노 넣는 경우도 있습니다. 정성적인 장점은 본인이 담당하는 프로젝트가 아니여도 개선의 여지를 발견하면 바로 수정을 시도 해볼 수 있습니다. 또 다른 장점은 10x 개발자의 PR을 보고 배울 수 있습니다. 다른 팀에 있으면 보고 배우기는 애매합니다. 공식문서에서 간단하게 풀었던 것을 보고 배울 수 있습니다.

같은 도메인을 공유하면 유용할 수 있습니다. 런타임 통합은 다릅니다. 그것은 별도입니다.

비즈니스 결합도가 높으면 런타임을 통합하면 될 것 같지만 모노레포와 무관해집니다.

리액트 네이티브가 상당히 적절한 케이스입니다. custom hook을 공유하는 것으로 비즈니스 로직을 공유하는 것이기 때문에 좋습니다.

모노레포는 빌드시간이랑 연관이 없습니다. github 액션에 빌드 결과를 보고 아티팩트라고하는데 이 아티팩트 캐싱을 공유하는 법을 나중에 배울 것입니다. 그래서 다른 프로젝트가 덕을 볼 수 있게 할 수 있습니다.

github가 모노레포를 많이 이용해서 모노레포 관련된 다양한 기능을 지원받을 수 있습니다. github 공식 블로그를 보면 알 수 있습니다. 코드 소유권을 지정할 수 있습니다.

- 여기를 참고하기 바랍니다. https://docs.github.com/ko/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners

모노레포는 패키지 매니저가 다르면 의미가 퇴색됩니다. 하지만 이것도 통합하는 라이브러리도 존재합니다. monorepo tools에서 가능합니다.

모노레포는 면접질문으로 나오려면 이력서에 포함해야 나옵니다. 왜 하게 되었는지 기술을 활용했던 경향을 질문합니다. 장학퀴즈는 지향합니다. 내일은 타입스크립트와 린트 공유와 시간이 남으면 공용컴포넌트 공유도 진행합니다.

---

https://www.itworld.co.kr/insight/214234

https://news.hada.io/topic?id=6061

https://news.hada.io/topic?id=7839

https://docs.google.com/presentation/d/1UwpWGEdVpRzERNrpfXNf-48kOS7uZzE4OjkY_kPJ6is/edit#slide=id.g1a2a6c89ca9_0_183

https://lean-mahogany-686.notion.site/5-d759234b0bf14936bcf4981d3505f86d

## 모노레포 특강

https://github.com/sungkwangkim/yarn-berry-test

지난주 tsconfig 공유를 배웠습니다. eslint도 배웠습니다. 리액트 컴포넌트를 만들어서 공유하는 것도 배웠습니다.

typecheck 스크립트도 넣어봤습니다. 파괴적인 변경이 발생하면 확인하는 방법을 배웠습니다. `yarn plugin import workspace-tools`를 활용해야 한다는 것을 배웠습니다.

지난주는 대규모 리팩토링할 때 다루었습니다. 모노레포에서 대규모 리팩토링을 안전하게 진행하는 방법이 있습니다. jscodeshift라는 툴이 있습니다. 대규모로 어떤 패턴을 입력하면 패턴을 강제로 수정해주는 도구입니다. 토스는 기술 부채를 상환할 때 활용한 툴입니다. 이 툴은 오픈 소스에서도 사용하고 있습니다. React-Query도 최근에 업데이트 되었습니다. import 문이 변경되었는데 jscodeshift로 리팩토링할 수 있습니다.

오늘은 모노레포 환경에서 github action을 활용해서 배포하는 법을 배웁니다. github-action을 실행해보기 위해서는 레포에 올려져 있어야 합니다.

apps에서 어드민을 추가하고 선택적으로 배포하는 방법을 알아봅니다.

변경된 워크스페이스를 감지하게 만들 수 있습니다.

수동으로 배포하면 누락이 발생할 가능성이 있습니다.

```sh
yarn workspaces since run build main 6-deploy
```

평소 테스트를 자주 하면 구현할 수 있습니다.

`.github` 폴더를 만들고 yml을 시스템별로 만드는 방법도 있습니다.

yml은 name으로 시작해야 합니다. on은 실행을 언제 할지 정의하는 것입니다. on에 조건이 해당(트리거)하면 jobs를 실행합니다. on은 상당히 다양합니다. push 시점에 실행도 할 수 있습니다.

https://docs.github.com/ko/actions/using-workflows/workflow-syntax-for-github-actions

PR에 테스트를 실행하도록 하는 것이 국룰입니다. workflow dispatch로 수동 명령도 가능합니다.

composite actions는 yml은 결국 코드인데 이것을 공통으로 조합하도록 할 수 있습니다. CI/CD 환경을 구축하기 위해 모노레포 환경에서 모두 동일한 패키지매니저를 사용하지 않으면 각각 구현되어야 합니다.

공통으로 적용할 수 있게 slack 알림이 가게 만들 수 있습니다.

배포 명령을 추가하면 어떻게 응용할 수 있는지 추론할 수 있습니다.

```yml
name: 'Monorepo install (yarn)'
description: 'Run yarn install'

runs:
  using: 'composite'

  steps:
    - name: Expose yarn config as "$GITHUB_OUTPUT"
      id: yarn-config
      shell: bash
      run: |
        echo "CACHE_FOLDER=$(yarn config get cacheFolder)" >> $GITHUB_OUTPUT

    - name: Restore yarn cache
      uses: actions/cache@v3
      id: yarn-download-cache
      with:
        path: ${{ steps.yarn-config.outputs.CACHE_FOLDER }}
        key: yarn-download-cache-${{ hashFiles('yarn.lock') }}
        restore-keys: |
          yarn-download-cache-

    - name: Restore yarn install state
      id: yarn-install-state-cache
      uses: actions/cache@v3
      with:
        path: .yarn/ci-cache/
        key: ${{ runner.os }}-yarn-install-state-cache-${{ hashFiles('yarn.lock', '.yarnrc.yml') }}

    - name: Install dependencies
      shell: bash
      run: |
        yarn install --immutable --inline-builds
      env:
        YARN_ENABLE_GLOBAL_CACHE: 'false'
        YARN_INSTALL_STATE_PATH: .yarn/ci-cache/install-state.gz # Very small speedup when lock does not change
```

name 부분이 중요합니다. apps에서 wanted에 해당하는 파일을 수정하면 action이 발생할 것입니다. 모노레포 환경에서 공통화된 yml을 만들 수 있습니다.

```yml
name: CI-deploy-manual

on:
  workflow_dispatch:
    inputs:
      service_name:
        description: '배포할 서비스명을 선택해주세요.'
        required: true
        default: 'wanted'
        type: choice
        options:
          - wanted
          - admin

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [16.x]
    steps:
      - uses: actions/checkout@v3

      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v3
        with:
          node-version: ${{ matrix.node-version }}

      - name: 📥 Monorepo install
        uses: ./.github/actions/yarn-install

      - name: Build web-app
        working-directory: apps/${{ inputs.service_name }}
        run: |
          yarn build
```

위 yml은 default 브랜치에 있어야 합니다.

모노레포 환경에서는 ci 툴을 활용해서 여러개의 서비스를 배포할 수 있습니다.

gitlab도 CI/CD 툴을 제공하고 있습니다.

이런 것을 경험해봐야 쉽게 문서를 이해하고 다른 곳에도 적용해볼 수 있습니다. pnpm에도 적용할 수 있습니다.

toss 플러그인을 여기 넣고 활용해볼 수 있습니다.

https://github.com/toss/yarn-plugin-workspace-since

이번에는 turborepo를 다룹니다.

https://turbo.build/

강의자료를 따로 만들게 많지 않습니다. yarn, pnpm은 패키지매니저로 만드는 모노레포이고 monorepo tool에서 다양한 모노레포를 위한 도구를 비교해볼 수 있습니다.

turborepo는 yarn workspace를 더 쉽게 다룰 수 있게 해줍니다. 버저닝도 자동화할 수 있습니다. 현재 실습에서는 추가되는 의존성이 많습니다. 자바스크립트는 Lerna, Nx, turbo를 많이 활용합니다. local computation cashing은 빌드를 하면 빌드에 사용했던 리소스를 재사용합니다.

turbo는 미리 설정된 것이 많아서 좋습니다. 하지만 yarn을 사용하면 pnp를 사용할 수 있습니다. 하지만 환경 구축을 위한 리소스를 지불해야 합니다.

인력이 많지 않은 상황에서 모노레포가 필요하면 turbo가 좋을 수 있습니다. 예시 문서도 꽤 많아서 상당히 유용합니다. vercel 인프라를 활용하면 개발이 상당히 쉽고 편해집니다.

취업 준비 중이면 turbo 단일 레포에 담아서 프로젝트를 만들어 보는 것도 이력서에 담아볼만합니다. 파편적으로 레포 개수가 많으면 그렇게 보기 좋은 것은 아닙니다.

내일은 오픈 소스를 탐구해봅니다.

vue 라이브러리도 모노레포로 구성되어 있습니다.

---

크로스 브라우징 팁입니다. JS, CSS 2가지가 문제인데 라이브러리로 대응합니다. 자브스크립트는 경우 babel의 브라우저 리스트 설정으로 제어합니다. 자바스크립트는 충분합니다. CSS-in-CSS 전략에서는 PostCSS로 처리합니다. CSS의 babel입니다.

docker 파일을 서비스별로 만들어서 해결해 볼 수 있을 것 같습니다.

s3 cloudfront 정도로는 리액트까지만 처리할 수 있습니다. 서버가 필요한 ecs만 next로 배포하합니다.

크롬은 15일, 사파리는 7일에 만료합니다. 이런 경우 정책은 7일 하나로 통합합니다. 사파리 예외처리는 오히려 복잡해질 수 있습니다.

면접에서 세션은 많이 물어봅니다. 코딩애플에서 설명잘 참고하도록 합니다.

주관적인 프론트엔드 덕목? JS는 기본입니다. 네트워크, 브라우저에 대한 이해가 잘 되었을 때 js, css, html, 브라우저의 작동방식, 네트워크 지식이 최소입니다. 모노레포 같은 기술은 기술이지만 언제든지 바뀔 수 있습니다. 오래가는 것은 아니지만 알아둬서 선택지를 넓힐 필요는 있습니다. 폴리레포로도 서비스는 충분히 만들 수 있습니다. 기초의 깊은 이해가 적절합니다.

신입개발자 취준에 대해서... 최근 취업 시장이 안 좋습니다. 뽑을 곳은 계속 뽑습니다. 열심히는 못해도 꾸준히라도 합니다.

https://youtu.be/QiS9ok0Gc0E

입사하고 편해지면 열심히 안 하기 시작합니다. 하지만 열심히 안해도 꾸준히라도 합니다. 회사에 왔을 때 잘할지 확률 게임입니다. 뽑았는데 별로인 경우도 있습니다. 꾸준함을 어필하기 위해 블로그를 잘 작성하도록 합니다. 꾸준히 쌓아놓는 것이 중요합니다.

경기는 순환합니다. 잘 버티도록 합니다.

프론트엔드가 알아야 할 최소한의 보안지식입니다. https://frontendmastery.com/ 여기 글을 적극적으로 활용합니다. 여기서 프론트엔드 보안 지침서를 읽고 진행하도록 합니다. 많은 취약점이 있지만 프론트엔드는 크로스사이트 스크립팅과 쿠키관리 2가지가 핵심입니다. 물론 백엔드 엔지니어가 보안, 인증에 대한 지식이 많으면 백엔드말 잘 들으면 됩니다. 하지만 가끔 클라이언트에서 쿠키를 굽게 만드는 경우도 있습니다. 웹에서 인증 토큰을 로컬 스토리지에 저장 시키면 보안 취약점입니다. 쿠키를 굽는데 httpOnly가 체크가 되어 있으면 자바스크립트로 쿠키를 볼 수 없습니다. 이 쿠키가 노출 되어 있으면 크로스사이트 스크립팅 공격을 할 수 있습니다. 프론트엔드는 인증 토큰을 httpOnly로 굽기 위해서는 자바스크립트로 구울 수 없습니다. 서버의 응답 해더로 set-cookies로 굽습니다. 서버에서 처리하고 시키는데로 잘 따릅니다.

신입 프론트엔드가 많이 하는 실수는 무엇인가? 치명적인 실수 문제보다는 조금만 알려주면 금방 알 수 있는 일을 공유 안해서 생산성이 떨어지는게 아쉽습니다. 그런 부분을 깰 수 있어야 합니다. 혼자 앓고 시간 지나는 문제가 있습니다. 본인이 모르는 것을 모른고 모르는 점이 무엇이 어떻게 문제가 되는지 잘 이야기하도록 합니다.

원티드 채용 프로세스는 사업부마다 다릅니다. 과제를 요구합니다. 급하면 면접난이도를 높이고 과제를 생략합니다.

다음시간에는 모노레포로 된 오픈소스를 탐구할 것입니다. 라이브러리의 소스코드에 분석을 시도해볼 수 있습니다. 구성방식을 조사해볼 것입니다.

프로젝트에서만 퍼블리싱하기 때문에 모노레포 라이브러리 퍼블리싱할 때 특별한 주의사항은 없습니다.

## 모노레포 특강

오늘은 실습이 없습니다. 오픈 소스를 보는 시간이 될 것입니다.

평소에 오픈소스를 자주 보는가? 이번 시간을 계기로 오픈소스를 많이 읽는 연습을 하도록 합니다.

오픈소스에서 다른 사람들이 작성한 패턴화된 코드를 볼 수 있습니다. 공부에 상당히 좋습니다.

작업하다가 막히면 오픈소스를 탐구하는 것도 한계를 극복하는데 상당히 도움됩니다.

어제 배운 부분을 간단하게 복습하겠습니다.

toss yarn barry workspace 플러그인을 활용해봤습니다. 변경이 있으면 해당하는 워크 스페이스를 추출하고 빌드하는 명령을 배웠습니다.

이 방식은 많은 프로젝트가 있으면 사람이 의식해서 배포하는 것이 아니라 변경 전후를 기계가 비교하게 만들어서 배포합니다.

해당 프로젝트마다 배포하는 전략도 배웠습니다.

작업 트리거는 on을 확인하면 됩니다. 아티팩트 캐싱하는 것도 볼 수 있었습니다.

manual은 동일한 빌드를 수동으로 github action을 트리거하도록 하는 방법을 배웠습니다.

마지막에는 turbo repo를 배웠습니다. 이미 모든 것들이 설정되어 있기 때문에 설정이 쉽고 간단합니다. 상황에 따라 세팅하는데 리소스가 별로 없으면 좋은 선택지인 것을 봤습니다.

오늘은 오픈소스를 한 번 보는 시간입니다. 개인적으로 오픈소스를 자주 보는 습관을 들여야 합니다. github action 세팅도 오픈소스로 배울 수 있습니다.

오늘은 vue를 확인합니다. vue는 pnpm을 사용하고 있습니다. vitest를 활용해서 테스트를 하고 있습니다.

오픈소스를 분석하기 시작할 때는 package.json부터 보는 것이 좋습니다. vite답게 rollup을 번들러로 활용하고 있습니다. 여기서부터 세팅도 공부해볼 수 있습니다.

최근에 src 활용여부를 논의하고 있습니다. 이처럼 src 활용여부를 오픈소스는 어떻게 실천하는지 보고 배울 수 있습니다.

pnpm도 workspace를 지원하는데 개별 yml을 만드는 방식이 다릅니다. 설정을 어떻게 하는지 검색하고 보고 배울 수 있습니다.

당근마켓의 github도 공개되어 있습니다. 당근마켓은 yarn barry를 사용하고 있고 pnp모를 사용하지 않고 있습니다.

공개된 명령어도 보고 무엇을 실행하는지 탐구해볼 수 있습니다.

번들러 중에 roma 도 볼 수 있습니다. ultra 명령도 있습니다. clone하고 공부해볼 수 있습니다. local에서 실행시켜보도록 합니다.

공부하기 위해 분석해보는 시간을 갖도록 합니다.

당근마켓은 프론트엔드 관련 레포들이 많이 있습니다. 보고 공부하도록 합니다.

문법도 보고 배울 수 있습니다.

toss에서 slash 라이브러리를 공개했습니다. node version은 개발에서 중요하기 때문에 주의하도록 합니다.

build 할때 jest, test, storybook은 컴파일할 때 읽지 않도록 만들 수 있습니다.

esm은 esm 빌드로 따로 하도록 합니다.

라이브러리 만들 때 설정들이 중요합니다.

peerDependencies는 라이브러리를 사용하기 위해 설치되어 있는데 최소버전을 알려주는 정보입니다.

toss는 yarn을 아주 잘 사용합니다. zero-install 전략을 활용하고 있습니다.

github를 사용하는데 빌드처리하는 것이 없습니다.

기여 가이드 문서도 제공하고 있습니다. 배포는 circle ci를 활용하고 있습니다. github action과 유사합니다. yarnrc와 yarnrc.yml 2개를 두는 이유가 의문이 들 수 있습니다.

토스는 packages를 설계하는 것도 특이합니다. 정리가 잘 되어 있습니다. 목적별로 분류가 가능합니다.

rooks 라이브러리는 특이합니다. 모노레포로 되어 있습니다. turbo로 되어 있습니다. rooks 폴더에 핵심 비즈니스 로직들을 모았습니다.

IntersectionObserver를 활용하고 특이한 hook들을 어떻게 적용하는지 보고 배울 수 있습니다.

JSDoc 활용도 볼 수 있습니다. JSDoc 공식 문서 가독성이 상당히 떨어집니다. 개인프로젝트에서라도 도움이 많이 됩니다.

보고 배울 때 무엇이 무엇을 하는지 파악하기 위에 조각단위로 가져와보도록 합니다.

테스트 코드를 보면서 테스트 설계도 배울 수 있습니다.

공개된 자료를 보고 배울 수 있습니다. 초보 개발자들의 아티클에 덜 의존해볼 수 있습니다.

dayjs, date-fns, recoil

recoil입니다. 타입스크립트는 기초입니다. 하지만 과거 페이스북에서는 flow를 활용했습니다.

설치할 때 yarn barry도 peerDependencies가 안 맞으면 경고만 하고 있습니다. 모노레포 설정은 없습니다. recoil은 모노레포이지만 workspace로 공유하고 있지는 않습니다. 구조가 상당히 특이합니다.

esm과 cjs를 섞어 사용했습니다.

차크라 ui는 들어봤을 것입니다. 차크라 ui가 zag를 만들었습니다. 라이브러리를 어떻게 배포하고 관리하는지 package.json을 각 workspace마다 확인하면서 공부할 수 있습니다.

오픈소스에서 ci 테스트를 어떻게 다르게 하는지 보고 배울 수 있습니다.

문서에서 changeset 라이브러리로 작업내역을 로컬에서 볼 수 있게 할 수 있습니다. slack api를 활용해서 통지가 가게 만들 수 있습니다.

노티, 문서화를 자동화할 수 있게 작업 구성할 수 있습니다.

라이브러리 혹은 서비스 만들때 빌드단계에서 사이즈를 알려주도록 만들 수 있습니다. 컴파일된 사이즈를 알 수 있습니다. 사이즈 초과하면 알림이 가게 만들 수 있습니다.

모노레포를 사용해도 버저닝을 하고 있으면 외부참조를 하고 있는 것입니다. 패키지 만들 때 설정보면서 npm 등록에 설정이 중요합니다.

tailwind는 turbo를 활용하고 있습니다. 그리고 npm을 사용하고 있는 것으로 보입니다. root에 이런저런 패키지를 설치하고 src에 담는 방식입니다. 정리가 잘 안된 느낌입니다.

관심사 분리가 덜 되어 있기 때문에 그렇습니다.

오픈소스를 분석하면 성장효율이 좋습니다. 어려우면 작거나 옛날 코드베이스에서 출발하는 것도 전략입니다.

마무리입니다.

모노레포는 트렌디하고 화려해보일 수 있는 기술입니다. 하지만 더 중요한 것은 어떻게 문제를 잘 해결할 수 있는 도구로 바라봐야 합니다. 발전된 개인 프로젝트를 추가하고 발전시키는 모습을 보여주는 것이 전략입니다. 하나의 레포로 관리해서 사이드 프로젝트, 토이프로젝트를 시도해보는 것도 좋은 방법입니다.

실무에서는 B2B, B2C, 어드민 통합에 유용합니다.

toss는 빌드 배포문제 때문에 마이크로서비스로 쪼개면서 전환을 위해 사용합니다.

모노레포는 잘 정의된 관계를 하나의 Repo에 담은 것입니다. 정의는 비즈니스, 도메인의 문제입니다.

turbo를 활용하기 전에 수동으로 해보는 경험이 있어야 효용을 체감할 수 있습니다.

feature flag로 운영 맛보기도 해볼 수 있습니다. trunk base 전략입니다.

실무에서는 여러명의 프론트엔드 개발자들과 협업해야 하는 환경입니다. 모노레포를 구성하면 상호작용하면서 성장할 환경이 제공됩니다. 장점이자 단점으로 가변성이 높습니다. 여러 프로덕트에서 올라오는 코드를 볼 수 있어서 다른 프로덕트를 보고 배울 수 있고 의견을 잘 주고 받을 수 있습니다. 자유롭게 코드를 기웃거릴 수 있는 환경이 좋습니다. 잘 몰랐던 것을 더 깔끔하게 처리할 수 있게 됩니다. 전체 레포에 대해서 주인의식이 생겨서 전체적으로 개선되는 이점이 있습니다. 기술적, 비즈니스적으로 성장할 수 있습니다. 혼자 개발할 때는 재미없기 쉽습니다. 기술적으로 이야기할 것들이 있어야 합니다.

SOT를 구축할 수 있습니다. lint, prettier, 공통패키지를 사용하면 됩니다. CI/CD 파이프라인도 통합됩니다. 새로운 프로젝트를 시작하는데 세팅에 들여야 할 수고가 덜어집니다.

1년 전에 작성했던 코드는 부끄러운 코드가 많을 것입니다. 처음에는 기능추가할 때는 부족한 부분이 나올 수 있습니다. 간간히 리팩토링할 때가 많습니다. 회사에서 리팩토링을 계속합니다. 리팩토링을 해둬야 소프트웨어의 수명이 늘어납니다. 기능을 개선하고 추가하기 쉽습니다. 리팩토링관점에서도 모노레포는 상당히 유용합니다. 브레이킹 체인지 감지도 쉽습니다. 대규모 리팩토링이 가능한 부분이 장점이자 단점입니다.

여러 팀이 모노레포에서 개발하고 있으면 공통 라이브러리의 API를 쉽게 업데이트를 진행할 수 있는 환경이 조성됩니다.

모노레포 업그레이드 할 때 중요한 것은 테스트입니다. 모노레포로 되어 있으면 다른 프레임워크로 가도 크게 상관없습니다. 모노레포 환경이면 다른 프레임워크 혹은 라이브러리를 설치하는 것도 전략입니다.

swagger를 API로 현재 기술부채이기는 하지만 codegen을 활용하기는 해야 하는데 수동으로 정의하고 있습니다. 레거시는 이렇고 최근 라이브러리의 혜택이 필요한 경우가 많습니다.

E2E 테스트도 원래 프론트엔드가 작성하기는 합니다. 최근 playwrigth를 추천합니다.

동시에 띄워야 하는 상황이 생기면 root에서 보통 자동으로 3000으로 뜹니다. 많이 띄워도 2 ~ 3개정도 띄웁니다. next는 자동으로 3001로 알아서 처리합니다. 물론 사전에 미리 port 번호를 설정하는 전략이 있습니다.

테스트코드를 잘 작성하거나 잘 설계하는데 활용을 잘 해봐야 할 것은 chatGPT입니다. 다시하고 프로픔트를 추가하도록 하면 됩니다.

Make test code with jest.

Import React from ‘react’
....

Make test code with jest.

- coverage 100%

Import React from ‘react’
....

이렇게 질문을 잘해보는 것도 좋은 전략입니다.

테스트코드 작성할 때 chatGPT가 알려준 테스트코드 편하게 사용하면 됩니다.

turbo보다 패키지매니저가 제공하는 mono repo가 갖을 수 있는 장점은 제어입니다. config 위치와 방식을 본인이 원하는 방식을 세세하게 설정할 수 있습니다. 그것 이외에 장점은 크게 없습니다. 또 익숙하다는 것도 이점입니다. pnp을 활용하면 유령의존성 문제가 해결됩니다.

pnpm이 장점이 많습니다. 이것도 하나의 장점입니다. 모노레포를 잘 지원합니다.

yarn barry의 팁입니다. next.js 많이 활용하면 standalone 설정이 있습니다. output 설정에 넣습니다. 번들사이즈에서 개발의존성 패키지들하고 런타임에서 필요한 것은 다릅니다. standalone을 활용하면 node_modules가 실행에 필요한 것만 넣습니다. 하지만 이 모드를 활용하면 node_module을 활용할 때만 가능합니다. 번들사이즈를 줄일 수 있습니다. pnp의 단점입니다.

yarn barry를 toss에서 활용할 때는 배포를 1분 정도에 처리합니다. 도커사이즈를 줄일 수 있습니다.

https://youtu.be/2IE68SDTYvI

이미지 리사이징한 전략입니다. 생각보다 쉽습니다.

https://medium.com/wantedjobs/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B0%80-%EC%A7%80%EA%B5%AC-%EC%98%A8%EB%82%9C%ED%99%94%EB%A5%BC-%EB%A7%89%EB%8A%94-%EB%B0%A9%EB%B2%95-feat-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%B5%9C%EC%A0%81%ED%99%94-730da53ac843

next를 사용하면 웹서버 리소스를 많이 사용하기 때문에 필요합니다.
