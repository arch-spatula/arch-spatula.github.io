---
title: '27주차'
authors: [arch-spatula]
tags: ['회고', '블로그']
description: '지난 분기보다 얼마나 성장했는가? 별로 성장한 것이 없습니다. 하루를 반일처럼 살고 있어서 이룬 것이 없습니다.'
toc_max_heading_level: 6
draft: true
---

# 27주차

## 23.07.03.

## 잡생각

- 오늘 기점으로 중요하고 큰 기능들이 완성되었습니다. 앞으로는 작고 디테일한 기능들입니다. 일부는 2개는 난이도가 높습니다. 하지만 이것만 지나면 개인 기여도 100% 프로젝트가 생깁니다.

## 기간별 제목

그냥해서 동작하기는 했습니다. 구체적인 상태에서 3번 이상 반복하는 요소를 유지하고 점진적으로 추상화하면서 구현했습니다.

구현하면서 생긴 문제는 계산 시간이 너무 오래걸렸습니다. 지금 생각나는 것은 suspense입니다. 랜더링 전에 보여줄 컴포넌트를 보여주는 것으로 해결해 볼 수 있습니다.

### 텍스트 드레그 방지

텍스트 드레그를 방지하는 방법입니다.

```tsx
export const NoCardMessage = styled.p`
  ${(props) => props.theme.fonts.heading20Bold}
  color: ${(props) => props.theme.colors.gray300};
  /* 텍스트 드래그 방지 */
  -ms-user-select: none;
  -moz-user-select: -moz-none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  user-select: none;
`;
```

```css
.class {
  -ms-user-select: none;
  -moz-user-select: -moz-none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  user-select: none;
}
```

위 예시를 적용하면 됩니다.

## button 수정

```tsx
it('should invoke the function when the button is call from form', async () => {
  user.setup();
  const btnText = 'Button';
  const mock = vi.fn((e) => e.preventDefault());

  render(
    <form onSubmit={mock}>
      <Button>{btnText}</Button>
    </form>
  );
  const btnElement = screen.getByRole('button');
  await user.click(btnElement);

  expect(btnElement).toBeInTheDocument();
  expect(mock).toHaveBeenCalledTimes(1);
});
```

form을 테스트할 때는 조금 특이합니다. 클릭 시점에 초기화 때문인지 모르겠는데 `preventDefault`가 필요합니다.

```tsx
it('should invoke the function when the button is call from form', async () => {
  user.setup();
  const btnText = 'Button';
  const mock = vi.fn((e) => e.preventDefault());

  render(
    <form onSubmit={mock}>
      <Button>{btnText}</Button>
    </form>
  );
  const btnElement = screen.getByRole('button');
  const linkElement = screen.queryByRole('link');
  await user.click(btnElement);

  expect(linkElement).not.toBeInTheDocument();
  expect(btnElement).toBeInTheDocument();
  expect(mock).toHaveBeenCalledTimes(1);
});
```

`queryByRole`은 존재하지 않을 수 있을 때 활용합니다.

## useOutSideClick

```tsx
import { useCallback, useEffect, useRef, useState } from 'react';

type OutSideProviderProps = {
  component: JSX.Element;
};

export function useOutsideClick<T extends HTMLElement>() {
  const areaRef = useRef<T>(null);

  const [isOpen, setIsOpen] = useState(false);

  const handleClick = useCallback(
    (e: MouseEvent) => {
      if (areaRef.current?.contains(e.target as Node) === false) {
        setIsOpen(false);
      }
    },
    [setIsOpen]
  );

  useEffect(() => {
    window.addEventListener('mousedown', handleClick);
    return () => window.removeEventListener('mousedown', handleClick);
  }, [handleClick]);

  const handleClose = useCallback(() => {
    setIsOpen(false);
  }, [setIsOpen]);

  const handleOpen = useCallback(() => {
    setIsOpen(true);
  }, [setIsOpen]);

  const handleRevers = useCallback(() => {
    setIsOpen((prev) => !prev);
  }, [setIsOpen]);

  const OutSideProvider = ({ component }: OutSideProviderProps) => {
    return <>{isOpen && component}</>;
  };

  return {
    customRef: areaRef,
    isOpen,
    handleClose,
    handleOpen,
    handleRevers,
    OutSideProvider,
  };
}
```

더 보완된 `useOutSideClick`입니다. 조건부 랜더링을 활용하는 점도 추상화했습니다.

## request waterfall 해결

로그인을 하면 페이지에 로딩 스피너가 보입니다. 잘 몰랐지만 상당히 기초가 없는 짓이라고 합니다.

[React Query meets React Router - tkdodo](https://tkdodo.eu/blog/react-query-meets-react-router)

SSR의 getServerSideProps를 클라이언트 사이드에서 흉내낼 수있습니다. CSR의 프리패칭 전략입니다.

놀랍게도 번역도 올라왔습니다.

[리액트 쿼리 : 리액트 라우터와 연계하기](https://itchallenger.tistory.com/719)

```ts
import { redirect } from 'react-router-dom';
import { checkLogin } from '..';
import { ROUTE_PATHS } from '@/constant/config';

type Direction = 'signin' | 'cards';

const DirectionMap: { [key in Direction]: () => null } = {
  cards: () => {
    if (checkLogin()) throw redirect(ROUTE_PATHS.CARDS);
    return null;
  },
  signin: () => {
    if (!checkLogin()) throw redirect(ROUTE_PATHS.SIGN_IN);
    return null;
  },
} as const;

export function protectRoutes(direction: Direction) {
  return DirectionMap[direction];
}
```

```ts title="route.ts"
const routes = createBrowserRouter([
  {
    path: ROUTE_PATHS.WELCOME,
    element: <Layout />,
    children: [
      {
        index: true,
        element: <Landing />,
        loader: protectRoutes('cards'),
      },
      {
        path: ROUTE_PATHS.SIGN_IN,
        element: <SignIn />,
        loader: protectRoutes('cards'),
      },
      {
        path: ROUTE_PATHS.SIGN_UP,
        element: <SignUp />,
        loader: protectRoutes('cards'),
      },
      {
        path: ROUTE_PATHS.CARDS,
        element: <Cards />,
        loader: protectRoutes('signin'),
      },
      {
        path: ROUTE_PATHS.DECK,
        element: <Deck />,
        loader: protectRoutes('signin'),
      },
      {
        path: ROUTE_PATHS.SETTING,
        element: <Setting />,
        loader: protectRoutes('signin'),
      },
    ],
    errorElement: <NotFound />,
  },
]);

function Router() {
  return <RouterProvider router={routes} />;
}

export default Router;
```

예전에 loader 리다이렉팅을 처리하기 위햇 작성했던 코드입니다. 기존에 갖고 있던 로직은 2가입니다. 로그인 상태로 token이 있으면 접근하지 말아야 할 페이지를 마운트 시키기 전에 리다이렉팅을 loader에서 호출하는 것으로 깜박임을 방지합니다. 만약 해당 페이지에 컴포넌트 속에 위치하면 깜박임이 있을 것입니다.

하지만 좋은 컨벤션이 아닌 점이 있습니다. 관심사의 문제입니다. loader는 그 특정 페이지가 먼저 처리해주기 바라는 로직을 처리해달라는 것입니다. 그런 측면에서 loader 함수는 page에 존재해야 합니다.

## 23.07.05.

## 잡생각

https://deno.land/x/superoak@4.7.0

위 라이브러리를 활용해서 테스트 코드를 작성해봐야겠습니다.

## 에러 로그: axios interceptor 동작 실패

이 문제는 access token이 만료되고 refresh token이 유효하면 다음 요청에 자동 갱신처리하고 재요청해야 하는 기능입니다.

예전에 [axios interceptors와 refresh token을 활용한 jwt 토큰 관리](https://gusrb3164.github.io/web/2022/08/07/refresh-with-axios-for-client/)을 대충보고 구현하고 한번 동작해서 성공한줄 알고 착각했습니다.

이 버그만 고치면 어려운 난이도의 개발은 해결됩니다. 물론 스스로 생각할 때 어려운 부분이라고 봅니다. 이 기능을 해결하면 기능 구현과 병렬로 문서화를 진행하면 됩니다.

이 기능은 사실 어려우면 안되는 기능입니다. 다른 교육과정에서 기본적으로 알려주지만 제가 받은 교육과정은 BaaS로 해결해서 몰랐던 것입니다.

### 문제: 재요청 실패

토큰이 만료되면 로그아웃도 안 보여주고 재요청이 그냥 실패합니다.

새로고침하면 로그아웃이 되는 것은 동작합니다.

### 시도: ???

#### local에서 환경 재현

일단 동일한 문제를 재현해야 하지만 30분 ~ 1시간 토큰기간을 프로덕션에서 그대로 사용할 수 없습니다.

로컬 환경에서 일단 재현해야 합니다.

```ts
import { Application } from 'https://deno.land/x/oak@v12.4.0/mod.ts';
import router from './routes/index.ts';
import { oakCors } from 'https://deno.land/x/cors@v1.2.2/mod.ts';

const app = new Application();

app.use(
  oakCors({
    origin: '*',
  })
);
app.use(router.routes());
app.use(router.allowedMethods());

await app.listen({ port: 8000 });
```

deno에서 와일드 카드로 CORS를 localhost에서 열어 줬습니다. 이것은 커밋할 생각이 없습니다. 이상태로 서버를 열어둘 것입니다.

여기서 실수를 했는데 라이브러리를 deps에서 import를 안했네요;;;

```
http://localhost:8000/
```

여기로 이제 핵심 url을 변경하면 됩니다.

```ts
import { create, getNumericDate } from '../deps.ts';

async function generateAccessToken(
  userId: string,
  expiresInSec = 10,
  key = privateKey
) {
  const jwt = await create(
    { alg: 'HS512' },
    { exp: getNumericDate(expiresInSec), sub: userId },
    key
  );

  console.log(new Date(), 'Access Token 생성');

  return {
    jwt,
    expires: new Date(new Date().getTime() + expiresInSec * 1000),
  };
}
```

access token의 만료 시간을 10초로 설정했습니다. 그리고 logging을 잘하도록 합시다.

여기서 10초 지나면 또 통신여부를 볼 수 있을 것입니다.

로그인 시점에서 10초 미만이 됩니다. 통신으로 받고 리다이렉팅하기 때문입니다.

access token이 만료되면 response 인터셉터가 동작합니다.

인터셉터가 하는 동작은 access token을 갱신요청을 하고 받아서 동일한 요청을 한번더 합니다.

만료 이후 요청은 3번 요청 응답 사이클을 순회하지만 결국 동작에 성공합니다. 만료시간은 꽤 길기 때문에 괜찮습니다. 아주 가끔만 통신 시간이 길어지게 되는 것입니다.

### 원인: 서버 재구동시 primitive 재생성 시점에 요청하면 에러가 발생

하지만 해결이라고 착각하고 있었습니다.

이슈는 1주일 전에 만들었지만 이문제는 놀랍게도 제가 6월 21일에 해결했습니다.

서버를 재구동하면 동일한 문제가 발생했습니다.

이렇게 되면 해결하기 위해서는 매번 동일한 key를 생성하도록 해야 합니다. 이럴 때 활용할 수 있는 전략은 env에 key를 저장하고 읽게 만드는 것입니다.

### 해결: CryptoKey 저장

```ts
const publicKey = await crypto.subtle.exportKey(
  'jwk',
  await crypto.subtle.generateKey(
    { name: 'HMAC', hash: { name: 'SHA-512' } },
    true,
    ['sign', 'verify']
  )
);

Deno.writeTextFileSync('key.json', JSON.stringify(data));
```

위 코드로 키를 생성합니다. json을 env에 이제 저장해주면 됩니다. 이렇게 읽을 수 있습니다. `console.log`는 중간에 짤립니다.

```
PUBLIC_KEY={(key 내용)}
```

이제 이 key를 활용하면 됩니다.

```ts
const PUBLIC_KEY = JSON.parse(
  Deno.env.get('PUBLIC_KEY') || config()['PUBLIC_KEY']
);

const privateKey = await crypto.subtle.importKey(
  'jwk',
  PUBLIC_KEY,
  { name: 'HMAC', hash: { name: 'SHA-512' } },
  true,
  ['sign', 'verify']
);
```

이렇게 되면 key는 항상 동일하기 때문에 서버를 재가동해도 token을 유효하게 만들 수 있습니다.

### 학습: private key 저장하는 방법을 사용해야 하는 이유는 서버 재가동이 많기 때문입니다.

결국 본인도 모르는 privateKey를 생성하게 만드는 전략을 활용할 수 없었습니다.

## nav 라우트를 활용해서 상태관리하기

```tsx
const Header = () => {
  const { pathname } = useLocation();
  return (
    <HeaderWrapper>
      {/* header 태그 */}
      <List>
        {/* ul 태그 */}
        <Item selected={pathname.startsWith('/web')}>
          {/* li 태그 */}
          <Link to="/web">Go to Web</Link>
        </Item>
        <Item selected={pathname === '/design'}>
          <Link to="/design">Go to Design</Link>
        </Item>
        <Item selected={pathname === '/server'}>
          <Link to="/server">Go to Server</Link>
        </Item>
      </List>
    </HeaderWrapper>
  );
};
```

https://velog.io/@soryeongk/ReactRouterDomV6

위 블로그 참고하고 해결했습니다.

React-Router-DOM의 상세 기능들을 적극적으로 활용해봐야 할 것 같습니다.

## 경고 modal

삭제를 누르르면 바로 삭제 요청을 하면 곤란합니다. 사용자의 노력이 많이 투입된 리소스에는 실수로 삭제하는 것을 방지해줘야 합니다.

삭제 방지를 위해서 모달을 보여주고 모달에서 확인을 누르면 서버에 요청을 보내도록 하는 것이 좋은 사용자 경험입니다.

일단 귀가했습니 내일 처리하겠습니다.

## 23.07.06.

## 잡생각

- 글을 잘 쓰려면 글을 쓸 소재가 필요합니다.
- 꿈보다는 해몽입니다.
- 문서화와 기타 수정이 남았습니다. 그리고 이것을 이력서에 반영해야 합니다.
- 1.0.0-alpha를 만들고 바로 리팩토링해야 하는 부분들이 보입니다. 시간 갖고 처리하면 됩니다.
  - 어느곳은 성능개선도 필요합니다. 중첩 순회를 할 수 밖에 없는 기능에는 worker API를 적용해보는 방법을 고안해야 할 것 같습니다.
  - 테스트 코드도 점진적으로 추가하기 시작해야 합니다.
  - React-Query에 type 지정을 올바르게 고쳐야 합니다.
  - 16일을 기준으로 배포해야 합니다.
- 이제 시작할 작업은 문서화입니다. 오늘 구현과 관련된 핵심작업하고 무엇을 해야하는지 방향을 잃었습니다.
- hook의 계층구조를 만들어야 할 것 같습니다.
- 쉬는 날이 너무 많습니다. 오늘은 잠시 다른 작업을 해보고 싶다는 생각이 들었습니다. 상당히 불순합니다.
  - 블로그 작업을 더하고 싶어졌습니다.
  - 리액트와 관련된 Doc을 확장하고 싶습니다.
    - 만들었던 전용 hook들을 추가하고 싶어졌습니다.
- 집중하기 어려운 이유가 배고프고 방금 큼직한 일을 달성해서 그런 것 같습니다.
  - 오늘 운세도 하루를 여유롭게 보내라고 해서 블로그 작업을 합리화해보려고 합니다.
  - 월살이라고도 합니다.
- 내일 계획입니다.
  - [ ] 문서화
  - [ ] 작은 수정
    - [ ] 카드 편집 버튼
    - [ ] 카드 편집 input label
    - [ ] 로그인/회원가입 버튼 위계
    - [ ] 랜딩 페이지 회원가입 버튼 투명 적용
    - [ ] 삭제 modal 위계, 경고, 중립 반영
- 작업 기간을 따지면 2023.05.17. ~ 2023.07.06 인 것 같습니다. 실제 배포일을 기준으로 하면 2달 정도 될 것입니다.
  - 현재 커밋 개수는 프론트엔드 370개 + 백엔드 150개입니다. 총 520 커밋정도 했습니다.

## 경고 modal

예전에 동료가 react portal을 활용해서 만들었습니다. 그 코드를 보는 것도 전략인 것 같습니다.

```tsx
import Document, {
  DocumentContext,
  Html,
  Main,
  NextScript,
  Head,
} from 'next/document';
import { ServerStyleSheet } from 'styled-components';

export default class MyDocument extends Document {
  static async getInitialProps(ctx: DocumentContext) {
    const sheet = new ServerStyleSheet();
    const originalRenderPage = ctx.renderPage;

    try {
      ctx.renderPage = () =>
        originalRenderPage({
          enhanceApp: (App) => (props) =>
            sheet.collectStyles(<App {...props} />),
        });

      const initialProps = await Document.getInitialProps(ctx);
      return {
        ...initialProps,
        styles: [initialProps.styles, sheet.getStyleElement()],
      };
    } finally {
      sheet.seal();
    }
  }

  render() {
    return (
      <Html lang="ko">
        <Head>
          <meta property="og:type" content="website" />
          <meta property="og:url" content="https://code-folio.vercel.app/" />
          <meta property="og:title" content="Codefolio" />
          <meta property="og:image" content="/images/ogImage.png" />
          <meta
            property="og:description"
            content="당신의 프로젝트를 정리해보세요!"
          />

          <meta property="og:site_name" content="Codefolio" />
          <meta property="og:locale" content="ko_KR" />
          <meta property="og:image:width" content="1200" />
          <meta property="og:image:height" content="630" />

          <link
            rel="icon"
            type="image/png"
            sizes="32x32"
            href="/logos/favicon.png"
          />
        </Head>
        <body>
          <Main />
          <NextScript />
          <div id="modal-root" />
        </body>
      </Html>
    );
  }
}
```

https://github.com/react-challengers/Codefolio/blob/dev/pages/_document.tsx

```tsx
import ReactDOM from 'react-dom';
import React, { useState, useEffect } from 'react';
import styled from 'styled-components';

interface ModalProps {
  onClose: () => void;
  children?: string | null | undefined;
  title?: string | null;
}

const Modal = ({ onClose, children, title }: ModalProps) => {
  const [isBrowser, setIsBrowser] = useState(false);

  useEffect(() => {
    setIsBrowser(true);
  }, []);

  const modalContent = (
    <StyledModalOverlay onClick={() => onClose()}>
      {/* Wrap the whole Modal inside the newly created StyledModalWrapper 
            and use the ref
        */}
      <StyledModalWrapper>
        {title && <StyledModalTitle>{title}</StyledModalTitle>}
        {children ? (
          <StyledModalBody>{children}</StyledModalBody>
        ) : (
          <StyledModalBody>
            {`계속 진행을 위해서는 "확인" 버튼을 눌러주세요.`}
          </StyledModalBody>
        )}
        <ButtonWrapper>
          <Checkbutton onClick={() => onClose()}> 확인 </Checkbutton>
        </ButtonWrapper>
      </StyledModalWrapper>
    </StyledModalOverlay>
  );

  if (isBrowser) {
    return ReactDOM.createPortal(
      modalContent,
      document.getElementById('modal-root') as Element
    );
  }
  return null;
};

const StyledModalTitle = styled.h1`
  font-size: 1.5rem;
`;

const StyledModalBody = styled.div`
  margin-top: 1rem;

  height: 4rem;
`;

// the wrapper component
const StyledModalWrapper = styled.div`
  width: 32rem;
  height: 12rem;
  background: #eee;

  border-radius: 1rem;
  padding: 1.5rem;
  z-index: 1000;
`;

const ButtonWrapper = styled.div`
  display: flex;

  justify-content: end;
`;

const Checkbutton = styled.button`
  background-color: #4b8bed;
  border-radius: 0.5rem;
  border: #4b8bed;

  height: 2rem;
  width: 3.75rem;

  color: white;
  font-size: 1rem;
  font-weight: bold;

  cursor: pointer;

  position: absolute;
`;

const StyledModalOverlay = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  background-color: rgba(0, 0, 0, 0.5);
`;

export default Modal;
```

https://github.com/react-challengers/Codefolio/blob/dev/Components/Common/Modal.tsx

정의를 찾았습니다. 호출한 예시를 봐야겠습니다.

```tsx
import '@uiw/react-md-editor/markdown-editor.css';
import '@uiw/react-markdown-preview/markdown.css';

import { ClipboardEvent, useCallback, useState } from 'react';
import Image from 'next/image';
import dynamic from 'next/dynamic';
import { v4 as uuidv4 } from 'uuid';
import { useRecoilState, useRecoilValue } from 'recoil';
import { postContent as recoilPostContent, postId } from '@/lib/recoil';
import type { MDEditorProps } from '@uiw/react-md-editor';
import { NextPage } from 'next';
import * as commands from '@uiw/react-md-editor/lib/commands';
import uploadImage from '@/utils/commons/uploadImage';
import styled from 'styled-components';
import compressImg from '@/utils/commons/compressImg';
import validateFile from '@/utils/commons/validationImage';
import { Modal } from '../Common';
import ImageUploadText from './ImageUploadText';

/**
 * @TODO storage 삭제 구현 필요
 */

const MDEditor = dynamic<MDEditorProps>(() => import('@uiw/react-md-editor'), {
  ssr: false,
});

const PostEditor: NextPage = () => {
  const isPostId = useRecoilValue(postId);
  const [postContent, setPostContent] = useRecoilState(recoilPostContent);
  const [showModal, setShowModal] = useState(false);

  const handleOnPaste = (e: ClipboardEvent<HTMLDivElement>) => {
    if (e.clipboardData.files.length) {
      e.preventDefault();
      onImagePasted(e.clipboardData);
    }
  };

  const onImagePasted = useCallback(
    async (
      dataTransfer: DataTransfer | FileList | null // Drag and Drop API
    ) => {
      if (!dataTransfer) return;
      const files: File[] = []; // 드래그 앤 드랍으로 가져온 파일들
      if (dataTransfer instanceof DataTransfer) {
        for (let index = 0; index < dataTransfer.items.length; index += 1) {
          const file = dataTransfer.items[index].getAsFile();

          if (file && !validateFile(file)) {
            setShowModal(true);
            return;
          }
          files.push(file as File);
        }
      } else if (dataTransfer instanceof FileList) {
        for (let index = 0; index < dataTransfer.length; index += 1) {
          const file = dataTransfer[index];

          if (!validateFile(file)) {
            setShowModal(true);
            return;
          }
          files.push(file);
        }
      }

      files.map(async (file) => {
        const fileId = uuidv4();

        const compressedFile = await compressImg(file);
        if (!compressedFile) return;

        const uploadResult = await uploadImage(
          compressedFile,
          'post-image',
          `${isPostId}/${fileId}`
        );
        if (!uploadResult) return;

        const insertString = `![${file.name}](${uploadResult})`;
        const resultString = insertToTextArea(insertString);

        setPostContent(resultString || '');
      });
    },
    [setPostContent]
  );

  // 에디터에 이미지 추가
  const insertToTextArea = (intsertString: string) => {
    const textarea = document.querySelector('textarea');
    if (!textarea) {
      return null;
    }
    let sentence = textarea.value;
    const len = sentence.length;
    const pos = textarea.selectionStart;
    const end = textarea.selectionEnd;

    const front = sentence.slice(0, pos);
    const back = sentence.slice(pos, len);

    sentence = front + intsertString + back;

    textarea.value = sentence;
    textarea.selectionEnd = end + intsertString.length;
    return sentence;
  };

  return (
    <div>
      {showModal && (
        <Modal
          onClose={() => setShowModal(false)}
          title="이미지 파일이 아닙니다."
        >
          jpeg, jpg, png, svg 등 이미지 파일을 넣어주세요.
        </Modal>
      )}

      <MDEditorStyled
        value={postContent}
        onChange={(value) => {
          setPostContent(value || '');
        }}
        height={600}
        onPaste={handleOnPaste}
        onDrop={(event) => {
          event.preventDefault();
          onImagePasted(event.dataTransfer);
        }}
        textareaProps={{
          placeholder: '프로젝트 내용을 입력해 주세요.',
        }}
        commands={[
          commands.bold,
          commands.italic,
          commands.strikethrough,
          commands.hr,
          commands.title,
          commands.divider,

          commands.link,
          commands.quote,
          commands.code,
          commands.divider,

          commands.unorderedListCommand,
          commands.orderedListCommand,
          commands.checkedListCommand,
          commands.divider,

          commands.group([], {
            name: 'image',
            groupName: 'image',
            icon: (
              <svg width="12" height="12" viewBox="0 0 20 20">
                <path
                  fill="currentColor"
                  d="M15 9c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm4-7H1c-.55 0-1 .45-1 1v14c0 .55.45 1 1 1h18c.55 0 1-.45 1-1V3c0-.55-.45-1-1-1zm-1 13l-6-5-2 2-4-5-4 8V4h16v11z"
                />
              </svg>
            ),
            // eslint-disable-next-line react/no-unstable-nested-components, @typescript-eslint/no-explicit-any
            children: (handle: any) => {
              // API가 any를 지정합니다.
              return (
                <CustomImageContainer>
                  <ImageContainerCloseButtonWrapper>
                    <Image
                      src="/icons/close.svg"
                      width={16}
                      height={16}
                      alt="닫힘버튼"
                      onClick={() => handle.close()}
                    />
                  </ImageContainerCloseButtonWrapper>
                  <label htmlFor="file">
                    <ImageUploadButton>
                      <ImageUploadText />
                    </ImageUploadButton>
                  </label>
                  <ImageInput
                    type="file"
                    id="file"
                    value=""
                    multiple
                    accept="image/*"
                    onChange={(e) => {
                      onImagePasted(e.target.files);
                      handle.close();
                    }}
                  />
                </CustomImageContainer>
              );
            },
            buttonProps: { 'aria-label': 'Insert image' },
          }),
        ]}
      />
    </div>
  );
};

const MDEditorStyled = styled(MDEditor)`
  -webkit-text-fill-color: ${(props) => props.theme.colors.white};
  ::placeholder {
  }
  .w-md-editor {
    background-color: none;
  }
  .w-md-editor-toolbar {
    -webkit-text-fill-color: ${(props) => props.theme.colors.black} !important;
    border: 1px solid ${(props) => props.theme.colors.gray7};
    background-color: ${(props) => props.theme.colors.gray11};
    & li > button > svg > path {
      color: ${(props) => props.theme.colors.gray2};
    }
    & li > button:hover {
      background-color: #343942;
    }
    & li.active > button {
      background-color: #343942;
    }
  }
  .w-md-editor-toolbar-divider {
    background-color: ${(props) => props.theme.colors.gray7};
  }
  .w-md-editor-content {
    background-color: ${(props) => props.theme.colors.gray7};
    border: 1px solid ${(props) => props.theme.colors.gray7};
    border-top: none;
  }
  .w-md-editor-input {
    background-color: ${(props) => props.theme.colors.gray11};
    border-right: 1px solid ${(props) => props.theme.colors.gray7};
    color: ${(props) => props.theme.colors.white};

    ::-webkit-scrollbar {
      background-color: ${(props) => props.theme.colors.gray11};
    }
  }
  .wmde-markdown {
    background-color: ${(props) => props.theme.colors.gray11};
  }
  .w-md-editor-preview {
    box-shadow: none;
  }

  .w-md-editor-toolbar-child {
    background: none;
  }

  li {
    list-style-type: disc;
  }
`;

const CustomImageContainer = styled.div`
  width: 11.25rem;
  height: 5.25rem;
  padding-top: 0.25rem;
  /* padding: 0.625rem; */
  background-color: ${({ theme }) => theme.colors.gray9};
  border-radius: 0.25rem;
`;

const ImageContainerCloseButtonWrapper = styled.div`
  display: flex;
  justify-content: flex-end;
  padding: 0 0.25rem;
  margin-bottom: 0.5rem;
  width: 100%;
  cursor: pointer;
`;

const ImageUploadButton = styled.div`
  width: 7rem;
  height: 1.875rem;
  background: none;
  border: 1px solid ${({ theme }) => theme.colors.gray2};
  border-radius: 0.25rem;
  padding: 0.375rem 0;
  cursor: pointer;
  margin: 0 auto;

  box-sizing: border-box;
  text-align: center;

  &:hover {
    border-color: ${({ theme }) => theme.colors.primary1};
    path {
      fill: ${({ theme }) => theme.colors.primary1};
    }
  }
`;

const ImageInput = styled.input`
  display: none;
`;

export default PostEditor;
```

https://github.com/react-challengers/Codefolio/blob/dev/Components/CreatePost/PostEditor.tsx

이렇게 modal을 제어할 때 조건부 랜더링으로 제어합니다.

## 생각보다 아이콘을 많이 활용합니다.

```tsx
function Component() {
  return (
    <DialogClose onClick={closeCB}>
      <svg
        xmlns="http://www.w3.org/2000/svg"
        width="24"
        height="24"
        viewBox="0 0 24 24"
        stroke-width="2"
        stroke={theme.colors.gray700}
        fill="none"
        stroke-linecap="round"
        stroke-linejoin="round"
      >
        <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
        <path d="M18 6l-12 12"></path>
        <path d="M6 6l12 12"></path>
      </svg>
    </DialogClose>
  );
}
```

```tsx
export const DialogClose = styled.button`
  all: unset;
  background-color: transparent;
  border-radius: 0.5rem;
  width: 3rem;
  height: 3rem;
  display: flex;
  align-items: center;
  justify-content: center;
  :hover {
    background-color: ${(props) => props.theme.colors.gray100};
  }
  :active {
    background-color: ${(props) => props.theme.colors.gray200};
  }
  position: relative;
`;
```

모달의 문제점은 다형성을 보장할 수 없다는 것입니다. 어떤 modal 컴포넌트가 들어와도 항상 동알하게 사용할 수 있어야 합니다. overlay, 중앙정렬을 보장받을 수 있어야 합니다.

## 이메일 저장

이 기능이 왜 필요한가? 생각해보면 답변은 간단합니다. 유저의 노력비용을 절약하기 위한 기능입니다.

localStorage를 사용해서 이상하게 사용하면 혼선이 발생할 가능성이 큽니다.

modal보다 쉽게 만들었습니다.

그냥 만들어졌습니다.

## 23.07.07.

## 잡생각

- 어제 블로그 관련 작업을 했습니다. 상당히 재미있었습니다.
- 오늘도 블로그 작업을 조금 해도 괜찮을 것 같습니다.
- 저의 블로그가 해결하는 문제는 무엇인가?
- 문제를 해결해보기 전에 다른 사람들이 저랑 비슷한 문제를 풀어봤는지 찾아봐야 합니다.
  - 이미 만들어진 바퀴를 찾고 이해하고 사용하면 됩니다.
  - 개인적인 생각에서는 이해를 하면서 학습하면서 성장한다고 봅니다. 모르면 곤란합니다. 모르면 성장이라고 보기 어렵습니다.
    - 개인적으로는 독려합니다. 결국 없는 문제를 해결해야 하면 이미 다른 사람들이 만들었던 것을 이해하고 학습했다면 응용은 할만할 것입니다.
  - 회사는 개인의 의견과 다릅니다. 검색으로 문제를 해결하면 죄책감을 가져야 하고 금기해야 합니다.
- 시간을 갖으면 지식을 쌓을 수 있을 것이라는 착각을 하고 살고 있습니다.
  - 취업하면 시간없습니다. 그래서 미리 쌓고 입사해야 합니다.
- 항상 꿈보단 해몽입니다.
  - 꿈에 대해서 이야기하는 사람은 항상 조심해야 합니다. 보통 우울할 가능성이 있습니다.

## modal 스크롤 제어

어제 구현하고 잠시 잊은 것이 있었습니다. modal이 활성화되면 scroll을 정지시켜야 합니다. 이 기능을 잊었습니다.

```ts
import { useEffect } from 'react';

/**
 * @see https://joylee-developer.tistory.com/185
 * 뒷배경 스크롤을 정지시킵니다.
 * Model과 함께 사용할 것을 권장합니다.
 */

const useStopScroll = () => {
  // 모달 오버레이에서 스크롤 방지
  useEffect(() => {
    document.body.style.cssText = `
      position: fixed;
      top: -${window.scrollY}px;
      overflow-y: scroll;
      width: 100%;`;
    return () => {
      const scrollY = document.body.style.top;
      document.body.style.cssText = '';
      window.scrollTo(0, parseInt(scrollY || '0', 10) * -1);
    };
  }, []);
};

export default useStopScroll;
```

https://github.com/react-challengers/Codefolio/blob/dev/hooks/common/useStopScroll.ts

예전에 제가 만들었던 hook입니다. 아 물론 제가 만든 것은 아니고 제가 보고 붙인 hook입니다.

---

https://www.youtube.com/@ocp396/videos

[그림 한 장으로 외워서 끝내는 웹 서비스 구조 기본이론 - 널널한 개발자](https://www.inflearn.com/course/lecture?courseSlug=%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%ED%95%B5%EC%8B%AC%EC%9D%B4%EB%A1%A0-%EA%B8%B0%EC%B4%88&unitId=126849&tab=activity-log)

web server was waf 차이

ips ssl

https://stackoverflow.com/questions/5600257/factoring-refactoring-a-program

## 23.07.08.

## 잡생각

- html만으로 극한의 성능을 끌어올릴 수 있는 방법이 생각났습니다.
  - tailwind css로 스타일링합니다.
  - htmx로 통신합니다.
  - alpine.js로 클라이언트 상태를 관리합니다.
- 백엔드는 deno를 사용합니다.
- DB는 하드에 sqlite를 저장해서 사용합니다.
- 상당히 이상한 풀스택 todo-app을 만들어보고 싶은 생각이 들었습니다.
- 내일 아티클 하나를 작성하기 시작해야 겠습니다. 이제 프론트엔드는 멸망했고 html만으로 모든 것을 할수 있다고 해야겠습니다.
  - deno fresh는 tailwind를 설치할 수 있는데 어떻게 했는지 찾아볼 것입니다.
  - alpine.js는 토큰 제어를 위해 사용하해보고 싶습니다.
  - sqlite는 DB로 디스크에 직접 읽고 쓰는 방식을 취해보고자 합니다. 필요하면 json에 읽고 쓰기를 하고자 합니다.
