---
title: '35주차'
authors: [arch-spatula]
tags: ['회고', '블로그']
description: '35주차'
toc_max_heading_level: 6
draft: true
---

# 주간 회고

<!--truncate-->

## JWT의 다른 이름

암호학에서 HMAC(keyed-hash message authentication code, hash-based message authentication code)는 암호화 해시 함수와 기밀 암호화 키를 수반하는 특정한 유형의 메시지 인증 코드(MAC)

https://ko.wikipedia.org/wiki/HMAC

오늘 유튜브 돌아다니다가 발견했습니다.

## 주간 & 월간 회고

- [ ] 자기소개서 성장을 위한 리소스가 필요 없어보이는 내용 추가
  - [ ] 혼자서 문제를 정의하고 혼자서 능동적으로 문제를 해결
- [ ] 주 6일 1일 3제 일요일 복습
- [ ] 개발자 포트폴리오 & 이력서 사이트
- [ ] 개발자 이력서 figma
- [ ] 랜딩 페이지 디자인
- [ ] 플래시카드 figma에서 디자인 정리하기
- [ ] nest.js freecodecamp 튜토리얼 완강 후 todo app 만들기
- [ ] nest.js 플래시카드 백엔드 포팅
- [ ] 함수형 코딩 완독
- [ ] 기술면접질문 6개
- [ ] 6일 1일3제
- [ ] nest.js todo app 만들기
- [ ] 플래시카드 프로젝트 테스트 코드 추가
- [ ] 장애(보안)보고서 블로그에 공개
- [ ] 원티드 프론트엔드 특강 8월 공개

### Liked

- 스스로 완성도가 어느정도 있는 이력서를 만들었다고 생각한다.
  - 이력서 작성으로 발생하는 시간낭비를 줄일 수 있을 것 같습니다.
- 가치가 낮다고 생각되는 부분까지 함수형 코딩을 읽었습니다.

### Learned

- UX랑 비즈니스 가치랑 연결하는 것이 좋은 사례에 해당합니다.
- 면접관은 최근 커밋도 확인합니다. 또 개인 블로그도 확인합니다.
- CS 지식 기초 중 기초는 어느정도 되었습니다. 방향을 복습 위주로 설정하면 문제가 없을 것 같습니다.
- 코테 실력이 결핍입니다. 전보다는 좋지만 더 오래동안 꾸준히 풀어봐야 할 것 같습니다.
- 과제 능력이 부족하다는 것을 발견했습니다. 완성도 높은 코드를 추구한다고 했는데 완성도가 낮았습니다.

### Lacked

- nest.js로 백엔 porting 준비를 너무 오래동안 하고 있습니다. 그냥 단순하고 빠르게 만들면 괜찮는데 작업을 계속 미루고 있습니다.
- 별로 중요하지 않지만 포트폴리오 사이트를 미루고 있습니다.
- 원티드 8월 특강은 비공개 하는 것이 더 적절해 보였습니다. 내용 중복도 있습니다.
- 보안 장애는 너무 늦게 다루려고 합니다. 금방 간단하게라도 작성하면 되는데 안하고 있습니다.
  - github pages에 맞게 공신 문서를 한국어로 설명한 버전으로 알려줘도 될 것 같습니다.
- 플래시카드 테스트 코드는 부분만 추가되었습니다.
- CS 지식을 자세히 알려주는 golang 강의에 심취했었습니다. 물론 좋은 지식은 맞지만 지금은 오히려 커밋내역이 부정적인 인상을 줄 내용입니다.

### Longed(잘하기 위해 필요한 것)

- 자소서에 질문 답안이 필요한 기업에 지원하기
- 개인 프로젝트를 더욱더 발전시켜야 합니다. 완전한 제어와 재량을 더욱더 적극적으로 활용해야 합니다.
  - 매일 사용해서 dogfooding해야 합니다.
  - 회원가입 페이지 중에 이메일 조회 기능을 추가해야 합니다.
  - 회원 탈퇴 기능도 추가해야 합니다.
  - 백엔드 porting을 진행해야 합니다.
    - 배포는 vercel로 합니다.
  - 하루 1개 정말 작고 꾸준하게 진행합니다.
- 코테는 천천히 해도 괜찮으니까 매일 꾸준히 해야 합니다.
- 면접 경험을 블로그 히든 페이지에 정리해야 합니다.
- 2주동안 특집으로 다룰 내용을 추가해야 합니다.

### Action Item

- [ ] 자소서에 질문 답안이 필요한 기업에 지원하기
  - [ ] 자소서에 질문 답안이 필요한 기업 목록 나열하기
  - [ ] 3개 이상 지원하기
- [ ] 정성적인 최종 면접 질문 목록 추가
  - [ ] 임원 면접질문 등
- [ ] 블로그 CS 지식에 면접 질문 문서 추가
- [ ] 회원탈퇴 기능 추가
- [ ] 이메일 중복 확인 기능 추가
- [ ] nest.js로 todo backend 만들기
  - [ ] 드리즐 활용
  - [ ] sqlite db로 활용

## 면접 후 회고

### 이전 회사에서 어떤 일을 맡으셨나요?

- NDA 때문에 자세한 언급은 주의하겠습니다. 전자연구노트를 SaaS로 디자인하고 있었습니다. 디자인 시스템과 관련된 작업을 재미있게 했고 많이 했습니다.

### 디자이너에서 프론트엔드 엔지니어로 전향한 이유?

- 특별한 사건이 있기 보단 디자이너로 직무를 수행하면서 기술적인 부분도 공부했는데 오히려 재미있었습니다.
- 꾸준히 해보고 계속 재미있을 수 있으면 전환해도 괜찮다는 생각으로 결정을 내렸습니다. 또 결정을 내렸던 시기도 1년 가까워졌을 때 였습니다. 퇴직금 받기 위해 1년 맞추고 동료들에게 미리 이야기 했습니다.

### 회사에서 챌린징 했던 것은 무엇이었나요?

- 실제로 했던 답변의 방향이었습니다.
  - 여러명의 요구사항을 맞추는 것이 어려웠습니다. 몇개의 중요한 우선순위를 두고 결정을 잘 내리는 것이 중요했던 것 같습니다.
  - 같은 질문을 다시합니다.
    - 참고할 래퍼런스가 많이 않아 도메인에 맞게 작업하는 것이 어려웠습니다.
  - 질문의 즉 도메인과 커뮤니케이션 문제가 있는데 같은 질문에서 갑자기 방향을 튼 것입니다.
    - 이런 이유로 커뮤니케이션 능력이 현격히 떨어진다는 것을 알 수 있습니다.
    - 커뮤니케이션 능력의 부족이 검증된 것입니다.
- 답했어야 하는 방향입니다.
  - 도메인이 특수하다는 점이 어려웠습니다. 비개발 직군인 프로덕트 매니저와 디자이너 비율이 높은 이유 중 하나는 TPM 허들 중에 제품 허들을 넘기는 것이 핵심이었습니다. 좋은 제품을 만들기 위해 UI 적인 트레이드 오프들이 많았습니다. 예를 들어 읽기 쉬우면 편집하기 어려운 것입니다. 화학적 관계와 비율을 표현하는 것이 중요한데 이것을 고민하는 부분이 다 같이 어려웠습니다.
  - 개인적으로 어려웠던 부분이 있나요?
    - 절대 부족하면 안된다고 하면 안 되는 부분은 커뮤니케이션입니다.
      - 예: 커뮤니케이션이 너무 많았습니다. 분명 언더 커뮤니케이션보다는 오버 커뮤니케이션이 적절합니다. 회의 시간이 너무 많았습니다. Single Source Of Truth로 뭘 둬야할지 애매한 상황이 많았습니다.
    - 조직이 커지고 새로운 협업 방식에 다시 적은하는 것이 어려웠습니다. 다음 투자라운드에 진입하면서 다들 격는 성장통입니다. 그 상황에서 남들보다 더 위축된 것입니다. 투자를 받고 PM, 디자이너 숫자가 더 늘었습니다. 기존의 워터폴 방식의 프로젝트를 배포하고 스크럼으로 전환할 때 였습니다. 절대 스크럼이 나쁘다는 것은 아닙니다. 제가 적응력을 잘 발휘하지 못했던 것 같습니다. 이야기 할 채널도 기능조직과 목적조직 양쪽으로 늘어나고 커뮤니케이션을 위한 노력의 량이 늘었고 또 방식도 바뀐 것이 어려웠습니다. 합류 했을 때 정해진 것이 없다가 조금지나서 정해진 포멧을 갖추다가 초기화로 다시 정해야 하는 상황이었습니다. 이전에는 옆자리 동료에게 화면 바로 보여주고 논의하면 괜찮았습니다. 조직이 커지면서 회의도 많아지고 회의 준비를 위한 시간도 같이 늘어났습니다.

### 면접으로 배운것

- CS 지식은 복습에 집중해야 합니다.
  - 신입사원에게 바라는 수준의 CS 지식은 많이 채웠습니다.
- 회사에 필요한 것을 더 찾아보고 기여할 수 있는 방향인지 찾아봤어야 합니다.
- 면접시간이 짧은 것은 적신호입니다. 길수록 합격 가능성이 높은 것입니다.
  - 면접을 검증요소를 찾아내는 시간이라는 관점을 갖으면 면접시간이 길수록 좋다는 것입니다.
  - 면접시간이 길수록 검증요소 검증을 위해 시간을 더 들이는 것이고 검증 시도에서 기각할 요소가 없다는 것이 검증된 것입니다.
  - 면접시간이 짧으면 검증요소에서 기각할 사항을 확인하면 그 뒤부터 면접 진행은 필요없다고 보게됩니다.
- 커뮤니케이션 능력이 없습니다.
  - 경청하고 생각을 해야 합니다. 말하게 두고 다음에 무슨말을 할지 말하는 중간에 생각하는 것이 아닙니다. 말을 하면 이해하고 그 다음을 생각하는 것입니다. 이해가 없었습니다.
- 여기서 약간의 멘탈관리를 할 부분도 있습니다.
  - 지원한 회사의 연봉이 아주 낮습니다.
  - 법무법인의 전산실과 비슷할 것입니다.
  - 합격하면 좋지만 못했다고 아쉬워할 부분은 없습니다.

## 20 13장 구조체

https://roadmap.sh/golang

https://www.youtube.com/watch?v=zNkawRtI4OI

구조체는 고급스러운 내용입니다. 모던한 프로그래밍 언어의 특성을 볼 수 있습니다. 구조체는 구조를 제공합니다.

구조체는 여러 필드(filed)를 묶어서 사용하는 타입니다. 필드는 속성이라고 번역하기도 합니다.

학생이 있으면 성적, 이름, 반, 번호가 있습니다. 구조체는 결국에는 타입입니다. 필드를 묶어서 사용하는 타입입니다.

```go
type 타입명 struct {
	필드명 타입
	...
	필드명 타입
}
```

위처럼 생겼습니다.

```go
package main

import (
	"fmt"
)

type Student struct {
	name  string
	class int
	no    int
	score float64
}

func main() {
	var jakeTheDog Student = Student{name: "Jake", class: 5, no: 30, score: 100}
	fmt.Println(jakeTheDog) // {Jake 5 30 100}
  fmt.Println(jakeTheDog.name, jakeTheDog.no, jakeTheDog.class, jakeTheDog.score) // Jake 30 5 100
}


```

구조체는 새로운 타입을 선언하는 것입니다.

타입을 별칭(alice)를 만드는 것처럼 새로운 타입을 만드는 것입니다.

인터페이스 타입도 존재합니다. 또 함수타입 선언도 가능합니다.

위의 경우는 한번에 선언한 것입니다.

```go
package main

import (
	"fmt"
)

type House struct {
	address  string
	size     int
	price    float64
	category string
}

func main() {
	var house House
	house.address = "전 우주"
	house.size = 99
	house.price = 0
	house.category = "카테고리 이론"
	fmt.Println(house) // {전 우주 99 0 카테고리 이론}
}
```

클라이언트에서 데이터를 받아 로직을 처리하는 과정에 활용할 수 있습니다. 한번에 입력하지말고 입력하는 순서를 확인하고 로직을 확인하기 좋습니다.

구조체는 필드의 값을 그대로 출력합니다.

필드는 점(.)으로 접근하면 됩니다.

패키지도 점(.)으로 접근하는 것도 비슷한 동작은 맞습니다.

구조체 선언할 때 순서를 맞춰서 초기화하는 것도 가능합니다.

```go
package main

import (
	"fmt"
)

type House struct {
	address  string
	size     int
	price    float64
	category string
}

func main() {
	var house House = House{"전 우주", 99, 0, "카테고리 이론"}
	fmt.Println(house)
}
```

한줄로 순서만 지키면 선언할 수 있습니다.

```go
package main

import (
	"fmt"
)

type House struct {
	address  string
	size     int
	price    float64
	category string
}

func main() {
	var house House = House{"전 우주", 99, 0, "카테고리 이론"}
	fmt.Println(house)
}
```

한줄로 순서만 지키면 선언할 수 있습니다.

```go
package main

import (
	"fmt"
)

type House struct {
	address  string
	size     int
	price    float64
	category string
}

func main() {
	var house House = House{address: "전 우주", size: 99}
	fmt.Println(house)
}
```

이렇게 하면 특정 필드만 초기화할 수 있습니다.

구조체는 중첩도 가능합니다.

```go
type User struct {
	name string
	id string
	age int
}

type VIPUser struct {
	userInfo User
	vipLevel int
	price int
}
```

이런 구조입니다. 왜 이렇게 하는가? 만약 학교라는 기관에서 학교라는 테이블이 있고 학생 테이블하고 선생님 테이블이 있는데 이 관계를 상속이 아니라 조합게 만들기 위해서입니다.

조합을 표현하기 위해서 포함관계로 표현하게 만듭니다.

```go
package main

import (
	"fmt"
)

type User struct {
	name string
	id   string
	age  int
}

type VIPUser struct {
	userInfo User
	vipLevel int
	price    int
}

func main() {
	user := User{name: "fin", id: "1", age: 16}
	vip := VIPUser{
		userInfo: User{name: "Jake", id: "2", age: 30},
		vipLevel: 1,
		price:    1000,
	}
	fmt.Println(user.name, vip.userInfo.name) // fin jake
}
```

임베디드 구조체라는 개념도 하는데 iot랑 무관합니다.

```go
type User struct {
	name string
	id   string
	age  int
}

type VIPUser struct {
	User
	vipLevel int
	price    int
}
```

위처럼 작성하는 것을 보고 임베디드 구조체라고 합니다. 내장된 구조체라고 번역하는 것이 더 좋을 것 같습니다. 상속을 더 쉽게 표현한 것인데 조합에 가깝습니다.

```go
type User struct {
	name string
	id   string
	age  int
}

type VIPUser struct {
	User
	vipLevel int
	price    int
}

func main() {
	user := User{name: "fin", id: "1", age: 16}
	vip := VIPUser{
		User:     User{name: "Jake", id: "2", age: 30},
		vipLevel: 1,
		price:    1000,
	}
	fmt.Println(user.name, "and", vip.name)
}
```

위처럼 표현하면 중간에 있던 userInfo 키를 무시하고 접근할 수 있습니다.

또 중첩구조체에서 키가 중복하면 밖에 있는 순서부터 출력합니다.

```go
package main

import (
	"fmt"
)

type User struct {
	name string
	id   string
	age  int
}

type VIPUser struct {
	User
	vipLevel int
	price    int
	name     string
}

func main() {
	user := User{name: "fin", id: "1", age: 16}
	vip := VIPUser{
		User:     User{name: "Jake", id: "2", age: 30},
		vipLevel: 1,
		price:    1000,
		name:     "Not Jake",
	}
	fmt.Println(user.name, "and", vip.name, "and", vip.User.name)
}

// fin and Not Jake and Jake
```

User를 통해 접근하면 내부에 할당한 값을 접근할 수 있습니다.

타입은 항상 데이터의 형태이고 형태를 알면 사이즈를 알 수 있습니다. 구조체의 타입도 선언으로 확보해야 하는 메모리 공간을 빠르게 파악할 수 있습니다.

```go
type User struct {
  age  int
	score float64
}
```

age 필드가 8바이트 score필드가 8바이트라 이 타입을 활용하면 16바이트를 메모리상 확보할 것입니다.

모든 필드가 복사가 됩니다. 대입연산으로 필드값이 그대로 2개가 복사됩니다. go 컴파일러는 자바스크립트처럼 주소를 참조하게 만들고 그런거 없이 값을 그대로 스트림처럼 복사합니다. 각각의 필드가 복사됩니다.

좌변은 주소 우변은 값이라는 것을 상기하기 바랍니다.

```go
type User struct {
  age  int
	score float64
}

var user1 User

// ...

user2 = user1
```

위처럼 필드에 맞게 복사합니다.

또 특정 필드끼리 복사할 때는 그 필드의 타입만 같으면 괜찮습니다.

```go
package main

import (
	"fmt"
	"unsafe"
)

type User struct {
	age   int32
	score float64
}

func main() {
	user := User{30, 77.2}
	fmt.Println(unsafe.Sizeof(user)) //  16
}
```

변수가 확보하고 있는 공간을 알 수 있습니다. 하지만 age는 4바이트이고 score는 8바이트인데 16이 나왔습니다.

하지만 구조체의 크기는 각 필드의 크기의 합인데 왜 16바이트인가? 그것은 바로 메모리 정렬 문제입니다. go 컴파일러는 메모리를 정렬해서 저장합니다.

CPU가 메모리의 값을 레지스터로 가져오고 계산하고 메모리에 쓰기를 합니다. 우리는 컴퓨터가 레지스터 크기가 64비트입니다. 이값을 가져올 때 8단위로 끊어져 있으면 가져오기 쉽습니다.

위 개념을 다시 생각해보면 4의 공간을 임의로 띄워서 정렬한 것입니다. 그래서 12가 아닌 16으로 늘려서 가져옵니다. 만약에 12이로 가져오는데 다음 메모리 공간이 4인지 그 양을 초과하는지 확인하는 작업이 번거롭습니다.

구조체는 메모리 시작주소가 age가 240에서 시작했다고 가정하면 4바이트라 244까지 공간을 확보합니다. 그리고 score는 8바이트 공간을 확보하는데 사이 4를 띄웁니다.

4(age) + 4(padding) + 8(score)

위처럼 4라는 padding을 8배수를 맞추기 위해 넣게 됩니다.

```go
package main

import (
	"fmt"
	"unsafe"
)

type User struct {
	a int8
	b int
	c int8
	d int
	e int8
}

func main() {
	user := User{1, 2, 3, 4, 6}
	fmt.Println(unsafe.Sizeof(user)) // 40
}
```

위 구조체는 40바이트를 저장합니다.

a, c, e는 1바이트입니다. b, d는 8바이트입니다.

1(a) + 7(padding) + 8(b) + 1(c) + 7(padding) + 8(d) + 1(e) + 7(padding)

일렇게 되어서 40바이트가 됩니다.

실제 필요한 것은 19바이트인데 40바이트를 사용하는 것입니다. 즉 메모리 낭비입니다.

```go
package main

import (
	"fmt"
	"unsafe"
)

type User struct {
	a int8
	c int8
	e int8
	b int
	d int
}

func main() {
	user := User{1, 2, 3, 4, 6}
	fmt.Println(unsafe.Sizeof(user)) //24
}
```

놀랍게도 24바이트가 됩니다.

1(a) + 1(c) + 1(e) + 5(padding) + 8(b) + 8(d)

메모리 효율을 고려하면 작은 순서에서 큰 순서로 배치하도록 합니다.

이것은 메모리자 작은 환경에서 개발해야 하면 즉 공간복잡성 문제가 크면 이렇게 문제를 해결합니다.

하지만 본인이 웹개발 분야면 굳이?

구조체의 역할이 있습니다.

프로그램의 길은 결합도는 낮게 응집도는 높게가 좋습니다.

> low coupling, high cohesion

궁극적으로 추구해야할 방향입니다.

구조체는 응집도를 높이기 좋은 개념입니다. 관련이 있는 속성들을 하나의 타입으로 만들기 때문에 응집도를 높이는데 유용합니다.

- 함수는 관련 코드 블록을 묶어서 응집도를 높이고 재사용성을 증가시킵니다.
- 배열은 같은 타입의 데이터들을 묶어서 응집도를 높입니다.
- 구조체는 관련된 데이터들을 묶어서 응집도를 높이고 재사용성을 증가시킵니다.

구조체는 객체지향 프로그래밍의 기반이 됩니다.

각각의 독립적인 변수들을 하나의 타입으로 묶어서 객체로 의미를 부여할 수 있게 됩니다. 하지만 클래스랑은 다릅니다. 구조체를 기반으로 OOP에 맞게 작성할 수 있게 됩니다. 필드를 묶어서 객체라는 개념이 생깁니다. 예전에는 변수와 변수사이 관계를 구조체를 만들면 객체와 객체사이 관계가 더 중요해집니다. 학교와 학생과 선생의 관계를 어떻게 만드는지가 중요해집니다.

go는 class가 없고 그냥 구조체만 있습니다. 다른 언어는 class와 구조체 각각 지원해줄 것입니다.

## 21 14장 포인터

https://www.youtube.com/watch?v=gvWXcGDG0k4

포인터입니다. 포인터는 c, c++에서 다루는 내용인데 go 지원합니다. go는 최신에 나온 언어입니다. 자바스크립트, 파이썬, 자바는 포인터가 없지만 go는 포인터가 있습니다.

포인터는 문법적으로 지원하지 않습니다. 하지만 내부적으로 사용합니다. 즉 다른 언어들은 암묵적으로 사용합니다. go는 노출합니다. 하지만 c, c++만큼 노출하지 않습니다. 포인터에를 사용할 때 위험하기 쉬운 부분은 언어차원에서 차단했습니다.

c, c++는 어럽게 생각하면 어렵고 쉽게 생각하면 쉬울 수 있습니다. 원리를 보면 간단합니다.

포인터는 메모리 주소를 값으로 갖는 타입입니다. 이것이 전부입니다.

값은 1과 0으로 되어 있는 숫자에 불과합니다. 하지만 형태에 따라 다릅니다. 실수, 문자열, 정수가 될지는 상황마다 다릅니다.

포인터는 변수를 만듭니다. 값을 갖습니다. 값은 숫자값인데 형태가 메모리주소입니다.

메모리 주소를 값으로 갖는다는 것은 무슨의미인가?

메모리는 값을 보관하기 위해 주소를 지정하고 값을 기록합니다. 메모리 공간의 시작주소가 있는데 그 시작 주소를 저장하게 만듭니다. 즉 변수가 값을 저장하는데 주소라는 것을 값으로 저장합니다. 이런 이유로 포인터입니다.

```go
var a int   // int 선언
var p *int  // 포인터 선언

p = &a // p에 a 메모리 주소 할당
*p = 20 // p의

fmt.Println(a)
```

`&a`은 a의 메모리 주소를 접근할 수 있습니다. p는 메모리 주소를 변수에 할당하게 됩니다. p도 메모리 공간을 갖습니다.

```go
package main

import (
	"fmt"
)

func main() {
	var a int
	var p *int

	p = &a
	fmt.Println(p) // 0xc0000ac008

	*p = 20
	fmt.Println(a) // 20
}
```

p에는 a라는 변수의 메모리 주소가 할당되어 있습니다.

p라는 포인터에 메모리 주소에 값을 쓰기를 해서 a가 갱신됩니다. a 주소에 해당하는 값에 할당 즉 쓰기를 했기 때문에 a를 접근하면 20으로 갱신되어 있습니다.

주소타입은 앞에 `*`을 붙이면 됩니다.

p는 int를 담고 있는 변수의 주소를 바라 볼 수 있는 포인터입니다. 다른 타입을 할당한 메모리 주소를 바라볼 수 없습니다.

`p`라는 것은 변수이고 `*p`할당한 주소값입니다. 주소를 접근하면 쓰기 즉 갱신이 가능합니다.

좌변은 주소이고 우변은 값입니다. `*p` 주소에 `20`이라는 값을 할당한 것입니다. `p`이라는 주소에 `0xc0000ac008`이라는 a 변수의 주소를 담습니다.

포인터 여러개가 변수 하나를 가리켜도 괜찮습니다.

```go
package main

import (
	"fmt"
)

func main() {
	var a int = 20
	var p1 *int
	var p2 *int
	var p3 *int

	fmt.Println(a)
	p1 = &a
	p2 = &a
	p3 = &a
	fmt.Println(p1, *p1, p2, *p2, p3, *p3)
}
// 20
// 0xc0000ae008 20 0xc0000ae008 20 0xc0000ae008 20
```

포인터는 변수를 계속 바라보면서 갱신을 관측할 수 있습니다.

0x는 16진수입니다. c0000ae008은 16진수에 해당하는 값입니다. 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, b, c, d, e, f가 자리당 범위입니다.

우에 해당하는 주소를 접근해서 쓰기하는 것에 불과합니다.

포인터는 주소를 담는데 결국 같은 주소인지 비교도 가능합니다.

```go
package main

import (
	"fmt"
)

func main() {
	var a int = 10
	var b int = 20

	var p1 *int = &a
	var p2 *int = &a
	var p3 *int = &b

	fmt.Println(p1 == p2)
	fmt.Println(p2 == p3)
}
// true
// false
```

생각조금만 하면 당연합니다.

포인터의 기본값은 nil입니다.

nil은 다른 언어의 null을 의미합니다.

nil의 값은 무엇인가? 값은 존재하는데 0입니다. 없음을 표현하는 것에 불과합니다.

```go
var p *int
if p != nil {
  // 정상적인 메모리 주소를 가리킴
}
```

위는 p가 어느 주소를 바라보고 있는지 확인할 때 사용할 수 있습니다.

포인터는 변수입니다. 변수는 메모리 공간이 있습니다. 당연히 주소도 존재합니다.

주소를 정하는 것은 컴퓨터가 변수를 선언할 때 임의로 공간을 찾아서 주소값을 정합니다.

말로만 들으면 혼란스러워보입니다. 기본기가 없는 것입니다.

go는 타입검증을 강하게 합니다. go는 명시적으로 주소를 int로 변환할 수 없습니다. go에서는 금지입니다. 하지만 c언어는 허용하고 있습니다.

포인터는 왜 사용하는가?

```go
package main

import (
	"fmt"
)

type Data struct {
	value int
	data  [200]int
}

func setData(arg Data) {
	arg.value = 999
	arg.data[100] = 999
}

func main() {
	var data Data
	setData(data)
	fmt.Println(data.value, data.data[100])
}
// 0 0
```

0만 2개 출력합니다. 왜 출력하는가? 함수의 인자로 대입할 때는 주소가 아닌 값으로 대입하기 때문입니다. 즉 함수의 인자로 대입하면 주소를 통해 값을 접근하고 값을 매개변수로 할당하고 실행하는 것입니다. 그리고 매개변수는 다른 공간에 저장하고 실행이 끝나면 삭제합니다.

그렇다면 여기서 값이 아닌 주소로 대입한다면 어떻게 될 것인가?

```go
package main

import (
	"fmt"
)

type Data struct {
	value int
	data  [200]int
}

func setData(arg *Data) { // 포인터 타입을 매개변수에 지정
  // 주소를 매개변수에 할당해 0을 999로 쓰기
	arg.value = 999
	arg.data[100] = 999
}

func main() {
	var data Data
	setData(&data) // 주소를 인자로 대입
	fmt.Println(data.value, data.data[100])
}
// 999 999
```

이렇게 되면 동작합니다. 함수가 주소를 받아오고 주소에 값을 할당해서 갱신합니다.

```go
func setData(data *Data) {
	(*data).value = 999
	(*data).data[100] = 999
}
```

사실 원래는 위처럼 작성해야 합니다. `*`을 붙여서 메모리의 키에 접근해서 값을 갱신하도록 하는 것입니다. 하지만 go의 문법적 설탕으로 생략해도 괜찮게 됩니다.

포인터를 사용하면 주소를 복하기 때문에 데이터 전체가 아니라 8바이트만큼 복사합니다.

같은 공간을 가리켜서 갱신하는 것과 복사하는 (주소를 저장하기 때문에) 사이즈가 8바이트로 고정됩니다. 이런 이유로 사용합니다.

성능과 메모리 사용량 측면에서 장점이 있습니다.

구조체 포인터 초기화입니다.

```go
var data Data
var p *Data = &data
```

```go
var p *Data = &Data{}
```

위 2개 코드 블럭은 같습니다. p는 구조체의 공간을 확보하고 그 공간의 메모리 주소를 담게 됩니다. 구조체의 공간을 가리키는 주소의 이름만 없을 뿐입니다.

인스턴스입니다. 인스턴스는 중요한 개념입니다. 문법이 아니라 개념입니다. 인스턴스는 메모리에 할당한 데이터의 실체라고 합니다.

```go
var p *Data = &Data{}
```

위 코드를 보면 인스턴스는 1개입니다. p는 데이터가 만들어졌고 공간의 주소를 담고 있습니다.

```go
var p1 *Data = &Data{}
var p2 *Data = p1
var p3 *Data = p1
```

모두 같은 데이터 주소를 가리킵니다. 그리고 데이터 인스턴스는 여전히 1개입니다.

```go
var data1 Data
var data2 Data = data1
var data3 Data = data1
```

data1을 복사한 것입니다. 지금 상황에서는 인스턴스가 3개입니다.

객체의 라이프 사이클이 있습니다. 메모리상 인스턴스를 만들어서 가리키게 되면 객체는 생성된 것입니다. 가리키는 것이 없으면 인스턴스는 죽은 것입니다.

인스턴스는 객체로 생각하고 라이프사이클이 존재한다고 볼 수 있습니다. 인스턴스가 사라지면 객체의 수명이 끝난것입니다.

```go
package main

import (
	"fmt"
)

type Data struct {
	value int
	data  [200]int
}

func main() {
	var p1 *Data = &Data{}
	var p2 *Data = &Data{}
	fmt.Println(p1 == p2) // false
}
```

위처럼 작성하면 서로 다른 객체 즉 각각의 인스턴스입니다. 메모리 주소가 다릅니다.

하지만 조금더 우아한 방법이 있습니다.

```go
package main

import (
	"fmt"
)

type Data struct {
	value int
	data  [200]int
}

func main() {
	var p1 = new(Data)
	var p2 = new(Data)

	fmt.Println(p1 == p2)
}
// false
```

문법이 클래스 스러워보입니다.

new는 초기값으로만 초기화됩니다.

인스턴스의 수명은 언제까지인가? 인스턴스가 존재한다는 것은 메모리상 존재한다는 것입니다. 언젠가는 메모리 공간이 부족하면 프로그램은 종료될 것입니다.

인스턴스는 참조가 없으면 사라집니다.

```go
type Data struct {
	value int
	data  [200]int
}

func testFunc() {
	u := &Data{}
	u.value = 30
	fmt.Println(u)
}
```

인스턴스는 함수호출이 종료되면 사라집니다. 그리고 삭제는 GC 사이클에 처리합니다. 참고로 위 예시는 함수는 스택에 만들어져서 함수 종료에 삭제합니다.

포인터는 가리키면 쓰임이 있고 쓰임이 있으면 수거대상이 아닙니다.

일반적으로 데이터가 힙에 있으면 GC의 수거 대상이 됩니다.

스택메모리와 힙메모리입니다.

```go
package main

import (
	"fmt"
)

type User struct {
	name string
	age  int
}

func newUser(name string, age int) *User {
	u := User{name: name, age: age}
	return &u
}

func main() {
	userPointer := newUser("Jake", 30)
	fmt.Println(userPointer)
}
```

u라는 변수는 스택이 실행되는 동안만 존재하고 삭제됩니다. 삭제된 u의 주소를 반환하면 원래 c언어는 wrangling error가 발생해야 합니다. 유효하지 않은 주소를 사용하면 에러가 발생해야 합니다. 무효한 주소가 반환하고 할당해서 출력이 됩니다. 즉 공간이 보존되고 있다는 것입니다.

함수의 지역변수는 스택메모리에 저장합니다. 함수가 종료되면 스택에 있는 메모리를 삭제해야 합니다. go는 탈출분석을 합니다. escape analysis를 지원합니다. 컴파일러가 코드를 분석하고 어떤 인스턴스가 함수 밖에 사용되고 있는지 분석합니다. userPointer 변수에 사용되었다는 것을 컴파일러가 보게 됩니다. 컴파일러는 탈출을 분석했으면 스택에 만들지 않고 힙에 저장합니다. 탈출분석으로 함수의 반환값은 GC의 수거대상이 되도록 합니다.

c언어는 불가능한 코드를 go에서는 편안하게 사용할 수 있습니다.

## Ch 5. Basic Queries

https://youtu.be/KBDSJU3cGkc?t=7217

SQL에 AS 키워드로 별칭(alias)을 지정할 수 있습니다.

```sql
SELECT employee_id AS id, employee_name AS name
FROM employees;
```

위처럼 작성하면 그냥 id, name이라고 작성할 수 있고 또 DB에서 가져온 테이블의 컬럼 이름도 바뀝니다.

SQL도 언어입니다. 대부분의 프로그래밍 언어처럼 함수를 사용할 수 있습니다.

sqlite는 삼항연산자처럼 IIF 함수를 사용할 수 있습니다.

```sql
IIF(carA > carB, "Car a is bigger", "Car b is bigger")
```

참이면 앞의 매개변수 거짓이면 뒤의 매개변수를 반환하게 만들 수 있습니다.

Between 절도 유용합니다.

```sql
SELECT employee_name, salary
FROM employees
WHERE salary BETWEEN 30000 and 60000;
```

위처럼 범위를 표현할 수 있습니다.

```sql
SELECT product_name, quantity
FROM products
WHERE quantity NOT BETWEEN 20 and 100;
```

NOT을 앞에 붙이면 역이라 제외할 범위를 설정하게 됩니다.

DISTINCT는 쿼리의 중복 레코드를 제외합니다. 예를 들어 국가코드를 쿼리하면 분명 겹치는 국가가 많을 것인데 중복을 제거합니다.

```sql
SELECT DISTINCT previous_company
    FROM employees;
```

논리연산자들도 제공합니다. AND, OR 키워드 그대로 사용합니다. WHERE절에 AND, OR에 여러 로직을 조합할 때 활용할 수 있습니다.

```sql
SELECT product_name, quantity, shipment_status
    FROM products
    WHERE shipment_status = 'pending'
    AND quantity BETWEEN 0 and 10;
```

대문자 AND가 2개의 조건을 조합합니다. 참고로 sql은 동등비교 연산자가 `=`입니다. 일반적인 프로그래밍 언어들은 할당이지만 sql은 아닙니다.

OR는 예상한 것처럼 조건 둘 중 하나라도 참이면 모두 쿼리가 됩니다. 또 소괄호(`()`)로 순서를 제어할 수 있습니다.

또 IN 절도 존재합니다. 유용한데 직관적이지 않습니다.

```sql
SELECT product_name, shipment_status
    FROM products
    WHERE shipment_status IN ('shipped', 'preparing', 'out of stock');
```

```sql
SELECT product_name, shipment_status
    FROM products
    WHERE shipment_status = 'shipped'
        OR shipment_status = 'preparing'
        OR shipment_status = 'out of stock';
```

같은 동작이지만 위 SQL이 더 간소합니다. 컬럼에서 인자에 해당하는 값 중 하나라도 해당하면 쿼리할 수 있게 됩니다.

LIKE 연산자도 있습니다. 퍼지 매칭, 와일드카드 매칭입니다. 데이터 베이스에서 부분적으로 일치하는 것을 찾습니다.

```sql
SELECT * FROM products
WHERE product_name LIKE 'banana%';
```

banana%: banana로 시작하면 선택합니다.
%banana: banana로 끝나면 선택합니다.
%banana%: banana문자가 존재하면 선택합니다.

다른 연산자들이 있습니다. 언더스코어(`_`)도 존재합니다. 정확히 그문자의 개수를 맞출 수 있습니다.

```sql
SELECT * FROM products
    WHERE product_name LIKE '_oot';
```

boot
root
foot

```sql
SELECT * FROM products
    WHERE product_name LIKE '__oot';
```

shoot
groot

즉 문자열의 일치하는 부분만 조회합니다.

https://youtu.be/KBDSJU3cGkc?t=8681

https://www.youtube.com/post/Ugkx2gW-KZJWRZhRmv9U31BPPX5OajCLGJt1

## 19 12장 배열

https://www.youtube.com/watch?v=-voLITa_LUw

배열은 같은 타입으로 이루어진 타입입니다. 배열도 타입입니다.

배열은 인덱스를 통해서 순서를 만들 수 있습니다. 컴퓨터는 0부터 숫자를 셉니다. 이런 이유로 마지막 번호는 전체 개수에서 -1입니다.

배열은 모두 같은 타입을 가져야 합니다.

배열은 자료구조입니다. 자료구조는 데이터를 저장하는 방식을 나타내는 구조입니다.

리스트(링크드 리스트), 트리도 존재합니다.

배열타입을 선언하는 방법입니다.

```go
var 변수명 [원소 개수]타입
```

위처럼 배열을 정의합니다.

```go
var t [5]float64
```

```go
package main

import "fmt"

func main() {
	var t [5]float64 = [5]float64{1.0, 0.2, 30.2, 5.43, 56.7}
	for i := 0; i < 5; i++ {
		fmt.Println(t[i])

	}
}
// 1
// 0.2
// 30.2
// 5.43
// 56.7
```

이렇게 배열을 사용할 수 있습니다.

```go
var nums [5] int // 초기값 자동할당
days := [3]string{"one", "two", "three"} // 선언대입
var temps [5]float64 = [5]float64{24.4, 26.7} // 남은 공간은 초기값으로 자동할당
var s = [5]int{1:20, 3:40} // 인덱스:값으로 할당 나머지는 초기값으로 할당
x :=  [...]int{10, 20, 30} // 3이라는 길이가 정해집니다. 그리고 배열입니다.
x :=  []int{10, 20, 30} // 슬라이스이고 동적배열입니다. 길이가 늘어났다가 줄어들 수 있습니다.
```

배열 선언으로 대입할 수 있는 값은 항상 상수만 넣을 수 있습니다.

```go
const x = 5

a:= [x]int{1, 2, 3, 4, 5} // 정상동작

y:=16

b:= [y]int{1, 2, 3} // 에러 발생
```

이렇게 해야 하는 이유는 메모리 공간을 고정시켜야 하는데 계속 동적인 것이랑 다릅니다.

```go
package main

import "fmt"

func main() {
	nums := [...]int{10, 20, 30, 40}
	nums[2] = 50
	for i := 0; i < len(nums); i++ {
		fmt.Println(nums[i])
	}
}
```

위가 가장 일반적인 배열 순회의 형태입니다. len 내장함수가 배열의 수량을 알 수 있습니다. 위 같은 경우 코드를 유지보수하기 편합니다. 배열의 크기를 처음부터 결정하지 않고 또 len로 할당하고 결정된 배열의 길이를 활용합니다.

```go
package main

import "fmt"

func main() {
	nums := [...]int{10, 20, 30, 40}
	nums[2] = 50
	for i, v := range nums {
		fmt.Println(i, v)
	}
}
```

range는 인덱스와 값을 같이 접근할 수 있게 해줍니다. v는 value 값을 의미하고 i는 index를 의미합니다.

둘 중 하나를 생략하고 싶으면 언더스코어를 활용하면 됩니다.

```go
package main

import "fmt"

func main() {
	nums := [...]int{10, 20, 30, 40}
	nums[2] = 50

  for _, v := range nums {
		fmt.Println(v)
	}

  for i := range nums {
		fmt.Println(i)
	}
}
```

위처럼 선언하고 필요 없으면 생략하거나 언더스코어로 건너 뛰면 됩니다.

배열을 선언할 때 타입을 알면 연속된 메모리 사이즈를 정하기 쉽습니다. 위 예시를 보면 덩어리 chunk에 해당합니다.

int인데 지금 컴퓨터는 64비트라 int64이고 int64 바이트를 차지할 공간 4개를 연속으로 붙입니다.

$$
\text{요소의 위치} = \text{배열의 시작 주소} + (\text{인덱스} \cdot \text{타입크기})
$$

위 공식으로 배열의 인덱스만 알면 그 해당하는 공간을 찾을 때는 상수시간으로 알 수 있습니다.

배열의 메모리 주소를 찾는 것은 상당히 쉽습니다. 덧셈과 곱셈으로 주소를 쉽게 찾을 수 있습니다. 배열을 읽기가 빠릅니다.

자료구조가 여러가지 형태가 있습니다. 특정 요소를 찾는 것을 보고 Random Access라고 합니다. 랜덤하게 접근하는데 배열이 제일 빠릅니다. 배열은 연속된 메모리 구조를 갖기 때문에 빠릅니다. 인덱스와 크기라는 자료의 사이즈와 무관하게 상수 횟수로 접근이 가능하기 때문입니다.

자료구조는 용도에 따라 선택하는데 읽기를 많이 할 때 유용합니다.

배열 복사입니다.

```go
package main

import "fmt"

func main() {
	a := [5]int{1, 2, 3, 4, 5}
	b := [5]int{100, 200, 300, 400, 500}
	for i, v := range a {
		fmt.Println(i, v)
	}
	fmt.Println()
	for i, v := range b {
		fmt.Println(i, v, "b")
	}
	fmt.Println()
	b = a
	for i, v := range b {
		fmt.Println(i, v, "b")
	}
	fmt.Println()
}

// 0 1
// 1 2
// 2 3
// 3 4
// 4 5

// 0 100 b
// 1 200 b
// 2 300 b
// 3 400 b
// 4 500 b

// 0 1 b
// 1 2 b
// 2 3 b
// 3 4 b
// 4 5 b
```

값 타입의 크기만큼 복사합니다. b는 int 5개입니다. 40바이트입니다. 복사과정이 컴퓨터에서 주소에 대응해서 복사하는 방식이 아닙니다. 크기를 그대로 스트림처럼 복사합니다.

값의 크기와 공간의 크기가 같은 것이 golang에서 중요한 부분입니다.

만약에 할당할 때 공간의 크기가 다르면 에러가 발생합니다. 또 타입도 같아야 합니다. 그래야 대입이 가능합니다.

중첩배열 즉 행렬은 생각하는대로 그대로입니다. 텐서도 동일합니다. n중 배열도 그냥 만들면 만들어집니다.

```go
[2][5][100][500]int
```

4중 배열은 3차원 공간에 시간축을 같이 포함해서 표현할 때 사용합니다.

```go
package main

import "fmt"

func main() {
	a := [2][5]int{{1, 2, 3, 4, 5}, {6, 7, 8, 9, 10}}
	for i, v := range a {
		fmt.Println(i, v)
		for j, v := range v {
			fmt.Println(j, v)
		}
	}

}

// 0 [1 2 3 4 5]
// 0 1
// 1 2
// 2 3
// 3 4
// 4 5
// 1 [6 7 8 9 10]
// 0 6
// 1 7
// 2 8
// 3 9
// 4 10
```

위는 중첩 순회의 예시입니다.

참고로 golang의 배열은 닫는 괄호가 다음이면 트레일링 코마로 작성해야 합니다.

```go
a := [2][5]int{
  {
    1,
    2,
    3,
    4,
    5,
  },
  {
    6,
    7,
    8,
    9,
    10,
  },
}
```

사실 컴퓨터에게 중요한 것은 메모리 사이즈입니다. 중요한 것은 사이즈와 타입을 미리 정의해줘야 하는 이유는 이렇습니다.

go는 타입이 항상 중요합니다. 타입을 결정할 수 있으면 메모리를 결정할 수 있기 때문입니다.

## dfs와 순열과 조합

https://leejams.github.io/%EC%A1%B0%ED%95%A9/

https://velog.io/@rlatp1409/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-JS-%EC%88%9C%EC%97%B4%EA%B3%BC-%EC%A1%B0%ED%95%A9-%EA%B5%AC%ED%98%84-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8

https://velog.io/@devjade/JavaScript%EB%A1%9C-%EC%88%9C%EC%97%B4%EA%B3%BC-%EC%A1%B0%ED%95%A9-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0

---

## 회사에 가장 기대하는 바가 있다면 무엇인지 말씀해주실 수 있을까요?

기술적인 스킬을 적용하면서 엔지니어로 성장할 수 있는 회사인 점이 커리어에서 제일 중요합니다.

오래된 기술을 고수하지 않고 비즈니스에 유용한 기술들을 적용하는 회사인점을 봤습니다.

다른 부분도 바라는 점이 있습니다. 함께 일하는 개발자 동료가 최소한 존재해야 합니다. 지금은 회사에 이끌어가줄 엔지니어 분이 있어서 더 좋습니다.

이끌어가줄 엔지니어가 있으면 적응하고 회사에 빠르게 기여하기 수월할 것 같습니다.

## 롤모델이 있다면 누구고 그 이유는 무엇인가요?

the primeagen이라는 인터넷 방송하는 개발자입니다. 실력도 좋지만 프로그래밍을 대하는 태도가 제일 좋았습니다. 즐겁게 개발을 하고 최대한 몰입을 합니다. 물론 건강을 잘 챙기면서 몰입합니다.

개발자로서 회사일을 잘하는 것이 중요하고 기여를 잘하기 위해 전문성을 갖추는 것이 최우선순위라고 했습니다. 하지만 절대로 회사에서 기여하고 있는 분야로 본인을 한정하지 말라고 했습니다. 넓고 다양하게 경험하고 돈은 1가지 깊게 전문성으로 벌어라고 했습니다. 사고를 넓게 하는 것이 중요하고 또 기본기가 풍부한 것도 중요하다고 했습니다.

## 힘들고 쉽지 않았지만 극복한 경험을 하나 이야기해주실 수 있을까요?

부족한 능력에 너무 과분한 자리를 받았을 때 힘들었습니다. 대학교에서 영상제를 진행하고 있었는데 경험이 너무 부족하고 협업하는 방식과 지식들이 전무한 상태에서 다른 사람들을 이끌었어야 했을 때 힘들었습니다.

극복은 불가능합니다. 프로젝트는 지금 생각해도 망했다고 봅니다. 단거리 경주로 생각하면 거기서 끝입니다.

단기거리 경주가 아니라 마라톤이라고 생각해야 하는 것같습니다. 끝나고 어떻게 더 보완했어야 했는지 찾아보기 시작했습니다. 작업의 규모가 크면 하이레벨 측면에서 위임, 정리, 공유가 중요합니다. 로우 레벨로 작업흐름도 보고 계획을 잘 하는 방법을 찾았어야 했습니다. 큰 흐름에서 같이 핵심 스토리짜고 촬영 계획 시간과 일자별로 짰어야 했습니다. 그리고 쵤영 진행할 때 담당 스태프 배정은 디테일해서 위임했어야 합니다.

비슷한 작업을 다시 했을 때는 몸만 힘들었습니다.

## 즐겁고 행복했던 경험을 하나 이야기해주실 수 있을까요?

개발자 블로그만들고 커지면서 만족감이 있습니다. 사실 눈으로 보이는 페이지들 이외에 숨겨둔 페이지들도 있습니다. 개인적으로 관심만 있고 강의듣고 정리한 내용이 많습니다. 이런 글은 보통 인사이트를 제공하지 않아서 다른 사람들이 볼 수 있게 두지 않습니다. 커지면서 분리하고 또 내용추가하고 그렇게 됩니다.

개인 프로젝트보다 더 오래 만든 프로젝트고 너무 일찍 선택한 프레임워크에서 성숙한 프레임워크를 선택해서 만족감이 큽니다.

## 개발과 무관한 본인의 장단점?

장점은 꾸준합니다. 지금까지 개발 공부한 것도 꾸준해서 가능한 것 같습니다. 1주일 몰입하고 2주 휴식하고 그런 스타일은 아닙니다. 3주 중간을 추구합니다.

단점은 쉽게 겁을 냅니다. 돌아보면 과감하게 해도 괜찮을 것에 불필요한 조심성을 갖던 경우도 많았던 것 같습니다. 개인 프로젝트에서 코드 퀄리티 강박을 갖지말고 빠른 전달을 하고 리팩토링하는 능력에 집중하는 것이 더 실용적이었을 것 같습니다.

## 개발과 관련된 장단점?

장점은 정보력이 많습니다. 영작 실력은 다른 개발자랑 비슷하거나 조금 부족한 수준인데 영어 듣기 실력은 좋은 편입니다. 영어로 된 콘텐츠를 먼저 접해서 테크 트렌드가 빠른 편이라고 동료가 피드백을 해줬습니다. 또 스타트업에서 UX/UI 디자이너로 근무한 경험이 있고 스타트업 생태계에 관심이 많아 전반적인 지식은 많은 편이라고 생각합니다.

단점은 단순하게 생각해도 괜찮은 것을 복잡하게 생각하는 경향이 있습니다. 이런 단점은 목표와 우선순위를 구체적으로 두는 것으로 해결해야 하는 것 같습니다. 부가적으로 고려해야 하는 것은 부가적인 것을 고려해도 괜찮은 맥락에 처리하는 방식도 방법인 것같습니다.

## 16 9장 if문

```go
package main

import "fmt"

func main() {
	temp := 33

	if temp > 28 {
		fmt.Println("에어컨 풀 가동")
	} else if temp < 3 {
		fmt.Println("히터 풀 가동")
	} else if temp >= 18 {
		fmt.Println("적당")
	} else {
		fmt.Println("참는다")
	}
}
```

if문 내에는 bool이 들어가야 합니다. 비교연산자 bool을 만듭니다.

```go
package main

import "fmt"

func main() {
	age := 22
	if age >= 10 && age <= 15 {
		fmt.Println("좋을 때다")
	} else if age > 30 || age < 20 {
		fmt.Println("인생 싫을 나이")
	} else {
		fmt.Println("그냥 살자")
	}
}
```

2개의 로직을 조합하는 것도 가능합니다.

golang도 쇼트 서킷 개념이 있습니다. 왼쪽에서 오른쪽 순서대로 조건을 확인하는데 ||은 true를 보면 뒤를 무시합니다. &&반대로 false를 보면 뒤를 무시하고 false로 간주합니다.

쇼트 서킷을 모르면 발생할 수 있는 실수들이 있습니다.

```go
package main

import "fmt"

var cnt int = 0 // 패키지 전역변수, cnt는 count의 약자

func add() int {
	fmt.Println("add", cnt)
	cnt += 1
	return cnt
}

func main() {
	fmt.Println("???")
	if false && add() < 5 {
		fmt.Println("1증가")
	}
}
```

false가 뒤 조건을 무시하게 만듭니다. 그래서 로직이 실행되지 않습니다.

숏서킷은 조건문에 호출은 많이 하지만 값만 비교해야 합니다. 조건문에서 조작하지 말아야 합니다. 프로그래밍적으로 불가능하다는 것이 아니라 일반적으로 권장하는 조언입니다. 조건문에서 함수를 호출하면 함수로 읽기만 하도록 합니다.

소괄호를 활용하는 방법이 있습니다. 소괄호는 로직을 처리할 순서를 제어할 때 사용합니다.

```go
package main

import "fmt"

func hasRichFriend() bool {
	return true
}

func getRichFriendCount() int {
	return 3
}

func main() {
	price := 35_000
	if price >= 50_000 {
		if hasRichFriend() {
			fmt.Println("앗 신발끈이 풀렸??")
		} else {
			fmt.Println("카뱅 ㄱ")
		}
	} else if price >= 30_000 {
		if getRichFriendCount() > 3 {
			fmt.Println("앗 신발끈이 풀렸??")
		} else {
			fmt.Println("카뱅 ㄱ")
		}
	} else {
		fmt.Println("각이다!")
	}
}
```

이렇게 중첩 로직을 표현할 수 있습니다.

이제 golang에서 특이한 부분입니다. 초기문, 조건문입니다.

```go
if 초기문; 조건문 {
  문장
}
```

위처럼 작성합니다.

```go
package main

import "fmt"

func main() {
	if filename, success := uploadFile(); success {
		fmt.Println("업로드 성공")
		} else {
		fmt.Println("업로드 실패")
	}
}
```

이런 예시로 사용할 수 있습니다. `uploadFile`은 실제 함수가 아닙니다.

golang은 한 줄에 여러 구문을 작성하면 세미콜론(`;`)으로 구분합니다.

success가 조건문에 해당합니다.

go의 스타일은 두번째 반환값을 성공과 실패, 에러를 값이자 플레그로 활용합니다.

보통 초기절에서 플래그를 접근하고 조건절에서 조건을 제어합니다.

## 17 10장 Switch 문

if는 조건을 검사하지만 switch는 값을 검사합니다.

```go
switch 비교값 {
case 값1:
  문장
case 값2:
  문장
default:
  문장
}
```

비교값과 같은 값을 찾아 실행합니다. 결국 선형비교는 동일합니다. 하지만 switch는 값이 중요합니다.

```go
package main

import "fmt"

func main() {
	a := 3
	switch a {
	case 1:
		fmt.Printf("a == 1")
	case 2:
		fmt.Printf("a == 2")
	case 3:
		fmt.Printf("a == 3")
	default:
		fmt.Printf("X")
	}
}
```

if랑 같지만 한줄에 필요한 공간이 더 작습니다. 구조적으로 이해하기 조금더 쉽습니다.

여러개의 값을 검사하는 것도 가능합니다.

```go
package main

import "fmt"

func main() {
	day := "thursday"

	switch day {
	case "monday", "tuesday":
		fmt.Printf("수업")
	case "wednesday", "thursday", "friday":
		fmt.Printf("공강")
	default:
		fmt.Printf("X")
	}
}
// 공강
```

여러개 값들 중 해당하는 값 1개를 발견하면 처리하게 만들 수 있습니다.

```go
package main

import "fmt"

func main() {

	switch true {
	case true:
		fmt.Printf("실행")
	default:
		fmt.Printf("X")
	}
}
// 실행
```

case에 조건문을 작성해서 조건문과 동일하게 작성할 수 있습니다.

조건 자체는 if문이 더 적잘합니다.

switch도 초기문을 지원합니다.

```go
switch 초기문; 비교값 {
case 값1:
  문장
case 값2:
  문장
default:
  문장
}
```

하지만 비교를 위한 비교값을 접근합니다.

```go
package main

import "fmt"

func getAge() int {
	return 3
}

func main() {
	switch age := getAge(); age {
	case 30:
		fmt.Println("나는 스물열살")
	case 20:
		fmt.Println("술먹고 지능 감소")
	case 3:
		fmt.Println("삼위일체 ㄱ")
	default:
		fmt.Printf("X")
	}
}

// 삼위일체 ㄱ
```

```go
package main

import "fmt"

type ColorType int

const (
	Red ColorType = iota
	Blue
	Green
	Yellow
)

func colorToString(color ColorType) string {
	switch color {
	case Red:
		return "Red"
	case Blue:
		return "Blue"
	case Green:
		return "Green"
	case Yellow:
		return "Yellow"
	default:
		return "none"
	}
}

func getColor() ColorType {
	return Yellow
}

func main() {
	fmt.Println("my favorite color is", colorToString(getColor()))
}

// my favorite color is Yellow
```

이런 응용도 가능합니다.

열거형을 만들어서 switch case로 구문 검사하는 패턴을 자주 볼 수 있습니다.

다른 언어는 `break`가 필요합니다. 없으면 모두 실행합니다. go는 작성할 필요가 없습니다. 실제 프로그래머가 switch case를 사용하는 방식을 참고한 것입니다. go는 작성하고 말고 선택입니다.

`fallthrough`를 사용하면 다음 case로 건너가도록 할 수 있습니다.

```go
package main

import "fmt"

func main() {
	a := 2
	switch a {
	case 1:
		fmt.Printf("a == 1")
	case 2:
		fmt.Printf("a == 2")
		fallthrough
	case 3:
		fmt.Printf("a == 3")
	default:
		fmt.Printf("X")
	}
}
// a == 2a == 3
```

이렇게 동작합니다. 참고로 go에만 있는 기능입니다.

사실 프로그래밍에서 잘 모르면 덜 사용하도록 합니다. 성능저하 문제나 이런 거는 없는데 불필요한 혼란을 발생시킬 가능성이 높기 때문입니다.

## CRUD

https://github.com/bootdotdev/fcc-learn-sql-assets/tree/main/course/4-crud/exercises

CRUD는 데이터와 데이터 베이스 관련된 것의 핵심입니다. 일반적인 REST API는 대응관계가 잘 됩니다.

http는 post - create, get - read, put - update, delete - delete로 대응됩니다.

sql도 대응됩니다. create - create, read - select, update - update, delete - delete

```sql
INSERT INTO employees(id, name, title)
VALUES (1, 'Allan', 'Engineer');
```

인서트문은 이렇게 생겼습니다.

```sql
INSERT INTO 테이블 이름(컬럼이름1, 컬럼이름2, 컬럼이름3)
VALUES (필드1, 필드2, 필드3);
```

이런 형식입니다.

데이터가 웹앱에 일반적으로 흐르는 방식입니다. 프론트엔드, 백엔드 웹서버, 데이터베이스가 있습니다. 프론트엔드는 백엔드에게 http로 주로 통신합니다. 백엔드 서버는 데이터 베이스를 sql로 통신합니다.

사용자가 회원가입 요청을 post로 서버에게 요청을 보내면 서버는 해당 정보를 sql로 실행해서 기록합니다. 이 처리가 성공하면 클라이언트는 성공응답 200을 돌려 받습니다.

프론트엔드랑 db랑 직접 통신하는 경우는 로컬 전용 어플리케이션에서 주로 합니다. 하지만 클라우드를 수단으로 서로 통신해야 하면 프론트엔드는 서버랑 통신해야 합니다.

auto increment는 자동 증감을 명시하지 않고 1개 증가를 처리할 수 있습니다. 하지만 이렇게 사용하면 db를 한번 읽어야 합니다. 하지만 그 뒤부터 서버가 구동되는 동안 증가시켜줄 필요는 없습니다. 재구동으로 메모리가 비워지면 다시 db를 읽어야 합니다. uuid도 자주 볼 수 있습니다. uuid는 삽입 전에 읽을 필요 없어서 좋습니다.

어떤 데이터 베이스는 auto increment는 명시해야 합니다. 하지만 sqlite는 명시할 필요 없습니다.

```sql
INSERT INTO users (name, age, country_code, username, password, is_admin)
VALUES (Lance, 20, US, LanChr, b00tdevisbest, false)
```

sqlite는 id를 생략하면 위처럼 자동으로 id를 increment 해줄 것입니다.

```go
sqlQuery := fmt.Sprintf(`
INSERT INTO users(name, age, country_code)
VALUES ('%s', %v, %s);
`, user.Name, user.Age, user.CountryCode)
```

위처럼 작성하는 경우는 거의 없습니다. 다른 프레임워크 orm을 통해서 처리할 것입니다. sql injection 공격으로부터 방어해줄 수 있습니다.

sql문은 동적으로 프로그래밍 언어에서 생성되는 경우가 대부분입니다. code gen을 해주는 프레임워크 및 라이브러리를 활용하게 될 것입니다.

```sql
SELECT count(*) from employees;
```

row 전체의 개수를 구하는 명령입니다. sqlite에서 지원합니다.

클라이언트는 get 서버는 db에게 select합니다. 그리고 db에서 가져오면 json으로 응답합니다. 유일한 방법은 아니고 자주 볼 수 있는 방법입니다.

where 절은 자주 볼 것입니다. where 절 없이 db를 조회하는 경우는 거의 없습니다.

```sql
SELECT name FROM users WHERE power_level >= 9000;
```

이렇게 생겼습니다.

```sql
SELECT 컬럼명 FROM 테이블명 WHERE 선택 조건;
```

위처럼 where를 사용하는 것이 일반적입니다. 안 사용하면 클라이언트, 서버가 터질 수 있습니다.

```sql
SELECT username FROM users WHERE is_admin=true;
```

위는 is_admin이 true 경우만 선택합니다.

is null과 is not null 문법으로 선택 혹은 무시하게 만들 수 있습니다.

```sql
SELECT name FROM users WHERE first_name IS NULL; -- 존재하지 않는 경우

SELECT name FROM users WHERE first_name IS NOT NULL; -- 존재하는 경우
```

위처럼 입력이 없는 경우를 무시 혹은 확인하게 만들 수 있습니다.

```sql
DELETE from employees
    WHERE id = 251;
```

위에서 where 절이 없으면 테이블이 비워집니다. where 절로 필터를 반드시 해주시기 바랍니다.

노하우가 하나 있다면 delete 명령 전에 select로 where 의도가 맞는지 확인하고 select를 delete로 바꿉니다.

삭제를 할 때는 또 조심할 점은 프라이머리키를 통해서 삭제하도록 합니다. 동시에 여러개 삭제할 필요가 없으면 프라이머리키를 접근해서 삭제합니다. 의도하지 않게 중복삭제가 발생할 수 있습니다.

```sql
DELETE from employees
    WHERE name="jake";
```

가장 지혜로운 개발자는 프로덕션 앱이 분명 버그로 가득하다는 것을 알고 있습니다. 장애까지 1커밋 남은 상황일 수 있습니다. 장애가 발생해도 db를 메모리에 저장하지 말고 사용자 db를 저장하고 있는 것이 지혜로울 것입니다.

이번에는 백업의 동작방식입니다.

제일 일반적인 방식입니다. 매일 스냅샷을 찍습니다. 밤 12시 정각에 정검시간이 있을 수 있습니다. 이때 백업 처리를 진행합니다. 파일 시스템로 디스크를 제공해주는 클라우드 서비스에 쑤셔 넣을 것입니다. 만약에 잘못되면 하루전으로 돌릴 수 있습니다. 하루 단위 스탭샷을 보관하고 월 단위로 보관할 것입니다. 월을 넘기면 삭제합니다.

단점은 스냅샷 이후로 데이터를 모두 잃습니다. 보완은 시간단위입니다. 이렇게 되면 비용이 커집니다. 하지만 작은 회사는 이렇게 해도 괜찮습니다.

조금이라도 데이터를 잃으면 안되는 경우면 다른 방법이 있습니다. DB에 변화가 발생하면 append only log에 추가되도록 합니다. 해당 log를 기록합니다. 실제 db에서 삭제하면 삭제가 된 것이지만 append only log는 삭제가 되었다는 기록을 남길 수 있습니다.

대부분의 작은 회사는 스냅샷으로 충분합니다.

항상 프로덕션 환경을 위해 백업 db를 구축하도록 합니다. 하루 단위로 데이터를 잃지만 모든 데이터를 잃는 것보다 좋습니다.

가끔은 soft delete 전략을 갖고 있습니다. db에 진짜로 delete 처리를 하지 않고 delete log를 기록하고 나중에 진짜로 삭제하고 다시 쿼리할 때는 안보이게 합니다. 문제는 복잡성입니다. 필터링이 필요합니다. 또 프라이버시 문제도 있습니다. 유저가 탈퇴했지만 유저의 데이터는 남기 쉽습니다. 또 문제는 쿼리가 느리게 만들어 줄 것입니다. 조회해야 하는 량이 많아지기 때문입니다.

```sql
UPDATE employees
SET job_title = 'Backend Engineer', salary = 150000
WHERE id = 251;
```

위와 같이 처리하면 갱신됩니다. 구체적으로 1개의 row를 갱신합니다.

ORM입니다. ORM은 DB 제어를 더 편하게 해주는 라이브러리입니다. 인메모리 객체, 구조, 레코드를 데이터베이스 스키마에 맞춰서 제어할 수 있게 해줍니다.

go는 구조체가 있습니다.

```go
type User struct {
    ID int
    Name string
    IsAdmin bool
}

user := User{
    ID: 10,
    Name: "Lane",
    IsAdmin: false,
}

// generates a SQL statement and runs it,
// creating a new record in the users table
db.Create(user)
```

모든 것은 sql문으로 직접 작성할 필요가 없어서 제어하기 좋습니다. ORM은 직접 sql작성도 쉽다는 조건 하에 ORM을 통해 작성할 것을 권장합니다.

나중에는 아주 복잡한 쿼리도 작서해야 합니다. ORM은 제어를 지불해서 낮은 복잡성을 얻는 경우가 많습니다.

코드의 작성량이 작아서 아주 좋은 장점이 있습니다. 하지만 절대 제어가 늘지 않습니다. 또 가끔 디버깅도 더 어려워질 수 있습니다. ORM이 복잡해지면 쿼리 성능도 나빠질 수 있습니다.

하지만 대부분의 경우 ORM을 사용하는 것이 좋습니다.

https://youtu.be/KBDSJU3cGkc?t=7214

## 18 11장 for문

https://www.youtube.com/watch?v=6K05jYPJlKo

go는 for 문 1가지입니다. for 문을 while 문처럼 작성할 수 있습니다.

괄호가 없는 것은 조건문과 같습니다.

```go
for 초기문; 조건문; 후처리 {
  문장
}
```

조건문이 true 동안 실행됩니다.

초기문을 실행하고 조건문을 확인합니다. 문장을 실행하고 후처리를 실행합니다. 문장을 먼저 실행하고 후처리하

```go
package main

import "fmt"

func main() {
	for i := 0; i < 10; i++ {
		fmt.Println(i, ", ")
	}
}
// 0
// 1
// 2
// 3
// 4
// 5
// 6
// 7
// 8
// 9
```

i는 인덱스 말고 지금 맥락에서는 이터레이터를 의미합니다. i, j, k 3가지를 많이 활용합니다.

반복문에서 사용한 i는 반복문 블록 스코프 내에 한정됩니다.

```go
package main

import "fmt"

func main() {
	i := 0
	for ; i < 10; i++ {
		fmt.Println(i)
	}
	fmt.Println(i)
}

// 0
// 1
// 2
// 3
// 4
// 5
// 6
// 7
// 8
// 9
// 10
```

초기문이 없으면 없다고 세미콜론만 남기고 i 선언 대입은 위 밖에 스코프에 정의하면 변수를 밖으로 뺄 수 있습니다.

후처리도 문법적으로 생략이 가능하지만 실수하기 쉽기 때문에 남기도록 합니다.

```go
for 조건문 {
  문장
}

for ; 조건문; {
  문장
}
```

위 2가지 모두 가능합니다.

```go
for true {

}

for {

}
```

위 2가지로 무한루프를 만들 수 있습니다. 무한루프를 만들기 위해 `true`도 생략할 수 있습니다.

무한 반복문은 왜 필요한가? 특정 조건에 깨고 싶으면 `break` 키워드를 사용하면 됩니다.

`continue` 키워드를 보면 다음 순회로 넘어가게 합니다.

```go
package main

import (
	"bufio"
	"fmt"
	"os"
)

func main() {
	stdin := bufio.NewReader(os.Stdin)
	for {
		fmt.Println("숫자입력 ㄱㄱ")
		var num int
		_, err := fmt.Scanln(&num)
		if err != nil {
			fmt.Println("숫자로 ㄱㄱ")
			stdin.ReadString('\n')
			continue
		}
		fmt.Printf("%d\n", num)
		if num%2 == 0 {
			fmt.Println("짝수 해제")
			break
		}
	}
}
```

짝수를 받으면 해제하는 프로그램을 만들 수 있습니다. 표준 입출력으로 상호작용하게 만들 수 있습니다.

for문은 if문 중첩처럼 중첩이 가능하지만 성능이 나쁩니다.

이중 for문을 현실에서 보게 되는 상황은 은근히 있습니다. 성능최적화로 기여할 기회입니다.

중첩 for 문은 break로 탈출하기 어려워서 플레그 변수 혹은 레이블을 많이 활용합니다.

```go
package main

import (
	"fmt"
)

func main() {
	a := 1
	b := 1
	found := false
	for ; a <= 9; a++ {
		for b = 1; b <= 9; b++ {
			if a*b == 45 {
				found = true
				break
			}
		}
		if found {
      break
		}
	}
  fmt.Println(a, b) // 5, 9
}
```

간단하게 곱셈을 볼 수 있습니다. 위는 플래그를 활용한 예시입니다. 이중 for문까지 탈출 할 수 있습니다. 3중 for문이 필요하면 플래그 변수를 또 만들어야 합니다.

다른 방법은 레이블을 활용하는 전략입니다.

```go
package main

import (
	"fmt"
)

func main() {
	a := 1
	b := 1

outer:
	for ; a <= 9; a++ {
		for b = 1; b <= 9; b++ {
			if a*b == 45 {
				break outer
			}
		}

	}
	fmt.Println(a, b)
}
```

위에서 outer가 레이블에 해당합니다. break가 outer를 나간다고 반환 값 할당하는 것처럼 입력하면 됩니다. 장점은 간결해졌습니다. c, c++는 레이블을 지원합니다. 또 goto문도 지원합니다.

사실 레이블은 자주 작성하지 않는 것이 좋습니다. instruction pointer를 내부적으로 막 바꾸기 때문에 stack이 꼬일 수 있습니다. 또 레이블을 지원하지 않는 언어도 많습니다.

하지만 예외는 있습니다. 플레그를 먼저 사용해보고 outer가 효율적이면 outer를 활용합니다.

[url vs uri vs urn](https//www.youtube.com/post/UgkxFWdiySGxN41hpohPYQsBXHjcX0dhfMx0)

## [Tucker의 Go 언어 프로그래밍] 8장 상수

https://www.youtube.com/watch?v=HNgeZySnQFI

상수는 변하지 않는 수를 의미합니다.

상수 선언은 단순합니다.

```go
const foo int = 10
```

상수는 상수입니다. 값을 갱신할 수 없습니다. 읽기 전용입니다.

```go
package main

func main() {
	const pi1 float64 = 3.14

	pi1 = 3 // 컴파일 전에 에러 발생
}
```

상수는 언제 사용하는가? 원주율처럼 값이 고정된 상황에 유용합니다.

변수로 사용해도 괜찮지만 프로그래머가 실수로 바꿀 가능성이 있습니다.

상수를 코드값으로 사용하는 경우도 있습니다. 숫자에 의미를 부여하는 경우입니다. 아스키코드가 해당합니다. a는 65 숫자를 부여하는 경우가 있습니다. 65를 보면 화면상 도트어떻게 처리할지 보는 것과 유사합니다.

```go
package main

import "fmt"

const PIG = 1
const COW = 2
const CHICKEN = 3

func printAnimal(animal int) {
	if animal == PIG {
		fmt.Println("꿀꿀")
		return
	}
	if animal == COW {
		fmt.Println("mow")
		return
	}
	if animal == CHICKEN {
		fmt.Println("2만원")
		return
	}
	fmt.Println("...")
	return
}

func main() {
	printAnimal(COW)
	printAnimal(PIG)
	printAnimal(7)
}
```

상수를 사용하면 사람이 의미를 부여해서 주고 받을 수 있게 됩니다.

```go
const (
	PIG     int = iota
	COW     int = iota
	CHICKEN int = iota
)
```

이렇게 수정도 가능합니다. 하지만 더 간소하게 만드는 방법이 있습니다.

```go
const (
	PIG int = iota
	COW
	CHICKEN
)
```

이렇게 표현하는 것도 가능합니다. 값이 1개 단위로 증가합니다.

비트 플래그로 응용하는 것도 가능합니다.

```go
const (
	BIT_FLAG1 = 1 << iota // 1
	BIT_FLAG2             // 2
	BIT_FLAG3             // 4
	BIT_FLAG4             // 8
)
```

이런 연산도 가능합니다.

```go
package main

import "fmt"

const (
	MASTER uint8 = 1 << iota
	LIVING
	BATH
	SMALL
)

func setLight(rooms, room uint8) uint8 {
	return rooms | room
}

func resetLight(rooms, room uint8) uint8 {
	return rooms &^ room
}

func isLightOn(rooms, room uint8) bool {
	return rooms&room == room
}

func turnLight(rooms uint8) {
	if isLightOn(rooms, MASTER) {
		fmt.Println("안방 킴")
	}
	if isLightOn(rooms, LIVING) {
		fmt.Println("거실 킴")
	}
	if isLightOn(rooms, BATH) {
		fmt.Println("화장실 킴")
	}
	if isLightOn(rooms, SMALL) {
		fmt.Println("작은방 킴")
	}
}

func main() {
	var rooms uint8 = 0

	rooms = setLight(rooms, MASTER)
	rooms = setLight(rooms, BATH)
	rooms = setLight(rooms, SMALL)
	rooms = resetLight(rooms, SMALL)

	turnLight(rooms)
}

// 안방 킴
// 화장실 킴
```

이런식으로 4개의 방을 4개의 비트로 제어할 수 있습니다.

golang은 특이하게 상수는 타입을 정하지 않을 수 있습니다. 안 정하면 타입은 상수값이 호출될 때 정해집니다.

```go
package main

import "fmt"

const PI = 3.14
const FLOAT_PI float64 = 3.14

func main() {
	var a int = PI * 100        // 정상동작
	var b int = FLOAT_PI * 100  // 에러
	fmt.Println(a, b)
}
```

타입을 안 넣으면 그냥 숫자를 사용한 것이랑 같습니다.

여기서는 컴파일할 때 값을 처리합니다.

상수는 좌변으로 사용할 수 없습니다. 상수는 메모리 공간이 없습니다. 컴파일된 코드에 그대로 들어갑니다. 프로그램을 실행할 때 메모리 공간을 할당합니다. 프로그램 코드가 실행되면서 메모리의 일부를 사용합니다. 변수는 메모리가 동적인 공간을 받습니다. 하지만 상수는 동적일 필요가 없습니다.

이런 이유로 숫자 그자체로 사용할 수 있게 된 것입니다. 컴퓨터에게 변수명, 상수명 중요하지 않습니다. 값이 중요합니다. 그리고 이 값이 고정되어 있기 때문에 그대로 두게되는 것입니다.

## Constraints

https://youtu.be/KBDSJU3cGkc?t=3045

https://github.com/bootdotdev/fcc-learn-sql-assets/tree/main/course/3-constraints/exercises

null 값은 중요합니다. 만약에 유저이름 셀이 비어있는 문자열("")이면 유저이름이 존재한다는 의미입니다. 빈 문자열, false보단 null을 활용해서 비어있음을 알려주는 것이 더 직관적입니다.

Constraints는 직역하면 제약입니다. 처리가 불가능하게 프로그래머가 막을 수 있습니다.

```sql
CREATE TABLE users (
    id INTEGER PRIMARY KEY,
    name TEXT NOT NULL,
    age INTEGER NOT NULL,
    country_code TEXT NOT NULL,
    username TEXT UNIQUE,
    password TEXT NOT NULL,
    is_admin BOOLEAN
);
```

PRIMARY KEY 제약은 row가 고유합니다. 테이블마다 1개만 사용할 수 있습니다. 보통 id에 많이 사용합니다. 고유하게 해주고 또 Not Null입니다.

UNIQUE는 고유자하지만 null이 될 수 있습니다.

이메일이 고유하다고 이메일을 프라이머리 키로 사용하는 짓거리를 하지말도록 합니다. 일단 id가 더 직관적입니다. 또 비즈니스 로직은 변화합니다. 만약에 이메일 중복을 허용하면 변형이 어렵습니다.

```sql
INSERT into users (
    id,
    name,
    age,
    username,
    password,
    is_admin
) values (
    1,
    "Jerry",
    25,
    "jerrysmith",
    "mypasswordis1234",
    true
);
```

삽입할 때는 매개변수의 순서에 주의해주시기 바랍니다.

프라이머리 키가 있으면 이제는 Foreign는 sql이 관계를 갖고 있다고 표현할 수 있는 수단입니다. Foreign 키를 Foreign라고 굳지 제약을 설정해줄 필요는 없습니다. 참조에 불과하기 때문에 그렇습니다.

지정하는 문법은 소개하겠습니다. 이유는 참조하고 있음을 보장해야 하기 때문입니다. 관계가 존재하면 처리하고 없으면 차단하도록 설정할 수 있습니다.

```sql
CREATE TABLE departments (
    id INTEGER PRIMARY KEY,
    department_name TEXT NOT NULL
);

CREATE TABLE employees (
    id INTEGER PRIMARY KEY,
    name TEXT NOT NULL,
    department_id INTEGER,
    CONSTRAINT fk_departments   -- CONSTRAINT 이름
    FOREIGN KEY (department_id) -- department_id INTEGER의 department_id매개변수를 고릅니다.
    REFERENCES departments(id)  -- departments 테이블의 id를 참조하도록 합니다.
);
```

스키마란 DB베이스에서 테이블관의 관계와 테이블의 이름과 컬럼별 자료형을 보고 포괄적으로 지칭하는 용어입니다.

세상에 완벽한 스키마는 없습니다. 데이터베이스 스키마는 최선을 고르도록 합니다. 최대한 단순하게 유지하면서 관계를 적절히 표현하도록 합니다. 처음부터 복잡성을 넣으면 나중에 풀어서 없애야할 때 고생하게 됩니다.

```sql
CREATE TABLE transactions (
    id INTEGER PRIMARY KEY,
    sender_id INTEGER,
    recipient_id INTEGER,
    memo TEXT NOT NULL,
    amount INTEGER NOT NULL,
    balance INTEGER NOT NULL
);
```

이렇게 거래 내역을 저장하는 테이블을 정의하고 스키마를 정의할 수 있습니다.

금융은 정수단위로 저장할 가능성이 더 높습니다. 5달러는 500개 페니를 저장하기 위해서 real 대신에 integer를 사용합니다. 메모리 공간의 유한함을 CS 지식으로 갖고 있으명 알 수 있습니다.

row를 보고 레코드라고 부릅니다.

관계형 DB는 이제 알 수 있습니다. 그렇다면 NoSQL은 어떻게 생겼는가?

일반적으로 NoSQL은 nested된 데이터로 표현합니다. 큼직한 json이라고 생각할 수 있습니다.

```json
{
  "users": [
    {
      "id": 0,
      "name": "Elon",
      "courses": [
        {
          "name": "Biology",
          "id": 0
        },
        {
          "name": "Biology",
          "id": 0
        }
      ]
    }
  ]
}
```

이런 관계를 갖고 있습니다. 이렇게 포함관계를 갖고 있는데 단점이 있습니다. 동일한 데이터가 복사됩니다.

NoSQL은 관계형 데이터 베이스에서 many to many 관계를 표현하는 방식을 표현하기 어렵습니다.

## 이상적으로 생각하는 조직문화에 대해 알려주실 수 있을까요?

최대한 압축하면 대인배라고 할 수 있습니다.

2가지 조직문화가 정착해야 할 것 같습니다. 관용과 투자인로 봅니다.

먼저 악의에는 관용적이지 않습니다. 누가 마음에 안든다고 업무를 방해하는 행동을 막아야 합니다. 하지만 실수에는 관용적이어여 합니다. 사람은 실수할 가능성이 높습니다. 이 실수를 어떻게 대하는가가 실수 그 자체보다 더 중요하게 보입니다. 실수가 실수로 끝나고 조직차원에서 정체될지 조직차원에서 학습의 기회로 활용할지는 다른 것 같습니다. 실수하고 혼나고 끝나면 정체됩니다. 실수하고 분석을 잘하고 학습해서 방식을 바꾸고 성장입니다.

다른 하나는 투자관점입니다. 예를 들어 직원 1명이 일을 엄청 잘하는데 회사 내에서 포스트잇 소비량이 너무 많습니다. 이 것을 보고 어떻게 생각하는가에 따라 다릅니다. 비용관리 관점으로 본인이 지출하게 만드는 조직이 있을 것입니다. 반대로 투자 관점에서 지금 지원이 10,000원을 써서 100,000원을 벌어 들이면 20,000원을 투자하면 190,000원이 수익인가? 포스트잇 구매량을 늘리고 일 잘하는 직원이 본인 업무 노하우, 팁을 다른 직원들에게 공유하게 만드는 것을 보고 투자라고 볼 수 있습니다.

## 16 9장 if문

https://www.youtube.com/watch?v=wMwX633gXU0

조건문은 조건에 따라 아래 블럭을 실행할지 말지 정합니다.

```go
if 조건문 {
  문장
} else if 조건문 {
  문장
} else {
  문장
}
```

사실 조건문은 위가 전부입니다.

위처럼 조건문을 작성하면 else if 순서대로 검사할 수 있습니다.
