---
title: 'bun 1.0 출시'
authors: [arch-spatula]
tags: ['런타임', '번들러', '패키지 매니저', '테크 트렌드 줍줍']
description: 'bun 1.0이 출시'
toc_max_heading_level: 6
draft: true
---

# bun 1.0 출시

블리딩 엣지 Deno를 사용하다가 과다출혈을 그렇게 당하고도 아직도 정신 못차린 것 같습니다.

<!--truncate-->

## Bun 1.0 is here 영상

<iframe class="codepen" src="https://www.youtube.com/embed/BsnCpESUEqM" title="Bun 1.0 is here" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

저처럼 문해력 딸리는 사람을 위한 유튜브 영상을 가져왔습니다.

## Bun 1.0 공식 블로그

[Bun 1.0 공식 블로그](https://bun.sh/blog/bun-v1.0)

하지만 문해력은 없지만 직접 시도해보고 싶은 사람들을 위해 블로그 링크를 준비했습니다.

또 저처럼 영어실력 부족한 여러분들을 위해 번역도 같이 다루겠습니다. 모두는 안 다루고 또 일부 편집해서 다룰 것입니다.

> Bun 1.0 is finally here.

Bun 1.0이 드디어 출시되었습니다.

> Bun is a fast, all-in-one toolkit for running, building, testing, and debugging JavaScript and TypeScript, from a single file to a full-stack application. Today, Bun is stable and production-ready.

Bun은 빠르고 자바스크립트와 타입스크립트 모두를 위한 실행, 빌딩, 테스트, 디버거 모든 것을 갖고 있는 툴킷입니다. 하나의 파일로 풀스택 앱을 구현할 수 있습니다. 오늘 Bun은 table 릴리즈이고 production에서 사용해도 괜찮습니다.

### Bun의 철학

#### Bun is an all-in-one toolkit

> We love JavaScript. It's mature, it moves fast, and its developer community is vibrant and passionate. It's awesome.

우리는 자바스크립트를 사랑합니다. 성숙하고 빠르게 움직이고 개발자 커뮤니티는 각양각색하고 열정적입니다. 어썸합니다.

> However, since Node.js debuted 14 years ago, layers and layers of tooling have accumulated on top of each other. And like any system that grows and evolves without centralized planning, JavaScript tooling has become slow and complex.

하지만 14년 전 Node.js 데뷔 이후 여러 계층의 툴링이 서로 뒤덮여있습니다. 중앙에서 계획 없이 자라나고 진화하는 모든 시스템처럼 자바스크립트 툴링은 느려지고 복잡해졌습니다.

#### Why Bun exists

> Bun's goal is simple: eliminate slowness and complexity without throwing away everything that's great about JavaScript. Your favorite libraries and frameworks should still work, and you shouldn't need to unlearn the conventions you're familiar with.

Bun의 복표는 단순합니다. 자바스크립트의 장점은 남겨두고 느리고 복잡함을 제거하는 것입니다. 당신의 최애 라이브러리와 프레임워크는 여전히 동작하고 익숙했던 컨벤션을 날릴 필요없어야 합니다.

> You will however need to unlearn the many tools that Bun makes unnecessary:

하지만 당신은 Bun이 필요없게 만드는 여러 툴을 잊어야 합니다.

---

여기까지가 Bun의 중심이 되는 철학입니다. Bun은 Runtime, Transpilers, Bundlers, Package Managers, Test Runner입니다.

### 설치

```sh
docker pull oven/bun
docker run --rm --init --ulimit memlock=-1:-1 oven/bun
```

개인적으로 제일 권장하는 docker입니다.

[Does bun has any docker image available?](https://github.com/oven-sh/bun/discussions/1040)

이슈에서 권장하는 docker image입니다. 공식문서좀 읽으라고 하는군요.

[oven/bun - docker hub](https://hub.docker.com/r/oven/bun)

실제로 직접 운영 중인 docker입니다.

```sh
brew tap oven-sh/bun
brew install bun
```

docker를 모르면 brew로 설치하기 바랍니다. ~~저는 아직도 docker를 설명서만 보고 하죠 정확히 이해는 못하고 있습니다.~~

<!-- @todo file io -->
<!-- @todo 서버 -->
<!-- @todo SQLite -->
<!-- @todo 테스트러너 -->
<!-- @todo window 차별 -->

## 테크 인플루언서들의 반응

### fireship

<iframe class="codepen" src="https://www.youtube.com/embed/dWqNgzZwVJQ" title="Bun is disrupting JavaScript land" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

### Lee Robinson

<iframe class="codepen" src="https://www.youtube.com/embed/z_66kDwxwBI" title="My thoughts on Bun" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

### Theo

<iframe class="codepen" src="https://www.youtube.com/embed/dQkv5C-Lfkw" title="Bun Is Better Than I Hoped" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

## bun stack 웹앱 개발 실전

```sh
brew tap oven-sh/bun
brew install bun
```

먼저 설치합시다. 저는 운영체제 수업 완강하기 전까지는 docker 활용을 자제하겠습니다.

```sh
bun -v
```

이렇게 버전을 확인해봅시다. 저는 `1.0.2`가 나왔습니다.

```sh
bun init
```

원하는 폴더에 들어가서 위 명령으로 초기화 설정을 해주시기 바랍니다. 저는 아주 창의적인 이름의 `bun-crud`라고 했습니다. 그리고 엔트리포인트는 `index.ts`로 유지했습니다. 마법사 선택지 2개밖에 없습니다.

```ts title="index.ts"
console.log('Hello via Bun!');

const file = Bun.file('package.json');

const print = await file.json(); // {...}

console.log(print);
```

위처럼 작성하고 실행해봅시다.

```sh
bun run index.ts
```

그럼 json출력을 확인할 수 있을 것입니다.

이제 읽기를 했다면 쓰기를 해봅시다.

```ts title="index.ts"
await Bun.write(
  'index.html',
  `<html><body><h1>hello bun html</h1></body></html>`
);
```

이렇게 작성하고 실행해보면 html파일이 생성된 것을 볼 수있을 것입니다. 나중에 htmx로 이상한 짓거리를 해봅시다.

```ts
Bun.serve({
  port: 3000,
  fetch(request) {
    return new Response('Hello from Bun!');
  },
});
```

`http://localhost:3000/` 에서 get 요청을 해봅시다. `Hello from Bun!`을 볼 수 있을 것입니다.

```ts
import { Database } from 'bun:sqlite';

const db = Database.open(':memory:');
db.exec(
  `CREATE TABLE todos (id INTEGER PRIMARY KEY AUTOINCREMENT, title TEXT, content TEXT, done INTEGER)`
);

Bun.serve({
  port: 3000,
  fetch: async (request) => {
    const url = new URL(request.url);

    if (request.method === 'GET' && url.pathname.split('/')[1] === 'todo') {
      const todos = db.query('SELECT * FROM todos').all();
      return new Response(JSON.stringify(todos), { status: 200 });
    }

    if (request.method === 'POST' && url.pathname.split('/')[1] === 'todo') {
      // body를 확인
      const { title, content, done } = await request.json<{
        title: string;
        content: string;
        done: boolean;
      }>();

      // insert 문
      const insert = db.prepare(
        'INSERT INTO todos (title, content, done) VALUES ($title, $content, $done)'
      );
      // insert 처리
      insert.run({ $title: title, $content: content, $done: done });

      return new Response(JSON.stringify({ title, content, done }), {
        status: 201,
      });
    }

    if (
      request.method === 'PATCH' &&
      url.pathname.split('/')[1] === 'todo' &&
      url.pathname.split('/')[2]
    ) {
      // body를 확인
      const { title, content, done } = await request.json<{
        title: string;
        content: string;
        done: boolean;
      }>();

      const [, path, id] = url.pathname.split('/');

      const updateTodo = db.prepare(
        `UPDATE todos SET title = ?, content = ?, done = ?  WHERE id = ?`
      );
      updateTodo.run(title, content, done, id);

      return new Response(JSON.stringify({ title, content, done }), {
        status: 201,
      });
    }

    if (
      request.method === 'DELETE' &&
      url.pathname.split('/')[1] === 'todo' &&
      url.pathname.split('/')[2]
    ) {
      const [, path, id] = url.pathname.split('/');
      const deleteTodo = db.prepare(`DELETE from todos WHERE id = ${id}`);
      deleteTodo.run();
      return new Response(null, { status: 204 });
    }

    return new Response('404!');
  },
});
```

이렇게 작성하면 백엔드 API가 구현된 것입니다. 아직 서버사이드 라우팅은 없습니다. 인메모리 DB를 사용하고 있습니다.

DB는 [better-sqlite3](https://github.com/WiseLibs/better-sqlite3)을 사용하고 있습니다. 그래서 해당 문서를 참고하면 DB 구현이 가능합니다. 하지면 더 좋은 ORM을 사용하기 바랍니다.

<!-- 여기서 저는 htmx를 사용해서 클라이언트가 서버랑 통신가능하게 만들어보겠습니다.  -->

## 결론

오늘 저녁은 딤섬이 땡깁니다.
