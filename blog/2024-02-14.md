---
title: 'neovim의 발을 들이면서...'
authors: [arch-spatula]
tags: ['vim', 'neovim']
description: 'neovim을 설정하는 과정'
toc_max_heading_level: 6
draft: true
---

오늘은 발렌타인 데이입니다. 저는 여자에게 받는 초코렛은 못 받아도 스스로 IDE는 선물로 줄 수 있을 것같습니다.

neovim을 설정하는 여정입니다. 이제 일상적으로 c 언어를 사용해야 할 때 사용할만할 정도로 개발환경이 좋아졌습니다.

<!--truncate-->

<!-- 글쓰기 단계: invent -->

:::warning

이글은 대부분의 개발자에게 가치가 없는 글입니다. 아주 소수의 개발자에게만 가치가 있습니다.

저는 맥북 에어 M1 유저로서 neovim을 설정하는 과정입니다. 이글은 저의 neovim 여행의 시작이고 이 시작을 여러분에게 알려주기 위해 쓰는 글입니다.

:::

<!-- @todo: 설정한 neovim 스크린샷  -->

![neovim 시작](/img/2024-02-14/start.png)

배경은 C 언어를 공부하는 중에 VSCode를 그만 사용하고 싶어졌습니다. 하나는 기본 플러그인 설치로 개발하는 프로젝트를 만들 때마다 자꾸 파일을 만듭니다. 저는 이 부분이 싫었습니다.

C 언어를 올바르게 다루려면 에디터부터 올바르게 다루는 방법부터 학습해야 할 것 같았습니다. MS가 제공하는 [비주얼 스튜디오](https://visualstudio.microsoft.com/ko/)도 싫었습니다. [CLion](https://www.jetbrains.com/ko-kr/clion/)도 있지만 이것은 유료입니다. 이때 정말 많은 사람들이 사용하는데 저도 같이 neovim을 사용해보고자 했습니다.

vim motion 자체는 알고 있습니다. 하지만 VS Code에 사용하면 플러그인이 충돌하는 것인지 오류가 많아졌습니다. 그래서 어느정도 익숙해졌는데 다시 해제했니다. 나중에는 [nvchad](https://nvchad.com/)를 발견하고 조금 사용했습니다. 하지만 그렇게 사용하면 결국 남이 만들어 주는 것이라 뭔가 어색했습니다. 분명 좋은 neovim distro는 맞지만 저는 제가 설정할 neovim을 온전히 이해하고 싶었습니다. 특별히 도움 되지 않지만 도움된다고 착각하면서 보는 [테크 유튜버](https://www.youtube.com/watch?v=6qSzFWRz6Ck)가 [kickstart.nvim](https://github.com/nvim-lua/kickstart.nvim)를 추천해줬고 distro를 잠시 옮겼습니다. 이 distro는 아니지만 꽤 좋았습니다. 그리고 내부 소스코드를 보니까 비교적 단순했고 저의 두뇌 성능으로 이해할 수 있었습니다. ~~최소한 이해하고 있다는 착각을 하고 있었습니다.~~

vim은 이펙트티브하려면 숙련도가 필요합니다. 본인이 설정하기 때문에 본인이 에디터에 대해서 자각하는 부분이 많아집니다. 그리고 성능이 꽤 좋다고 착각하면서 사용하는 에디터입니다. 저는 직업은 개발자인 주제에 홍대병 말기라 저만의 간지나는 에디터를 사용하고 싶었습니다. 해피해킹 키보드에 스타벅스에서 neovim으로 판교에서 코딩하고 있으면 ~~아무도 신경 안쓰는데~~ 간지날 것 같습니다.

VSCode를 사용하다 보면 아쉬운 점이 많습니다. 글을 쓰는 중에 이동하려면 커맨드 팔레트(`cmd` + `p` > `@`)를 사용해 접근하기 때문입니다. 이동을 하고 글이 하단에 있으면 상단 혹은 중간으로 끌어 올리고 싶은데 단축키를 모릅니다.

일개 1년 정도 프로그래밍 공부하고 회사 수습 기간 끝난지 얼마 안 된 나약한 현대 웹개발자가 vim을 논하기는 웃기지만 그래도 ~~블로그 소재를 위해~~ 논하겠습니다. 참고로 vim에 대한 내용은 블로그 vim 문서에 중복해서 작성 될 것입니다. 문서는 정리하고 찾기 쉬워야합니다. 하지만 이 글은 저의 여정에 관한 글입니다.

## neovim 설치

neovim을 설치하고 그냥 사용하는 것은 가능할 것입니다. 하지만 제가 2년 뒤 노트북 바꿀 때 제가 제 블로그 보고 했던 설정 또하기 위해서 작성해두겠습니다.

먼저 zsh이 설치 되어 있는지 확인해봅니다. 일반적으로 맥북은 기본설치가 되어 있을 것입니다.

```sh
zsh --version
```

만약에 설치되어 있다면 다음은 neovim을 설치하겠습니다.

```sh
brew install neovim
```

[설치 가이드](https://github.com/neovim/neovim/blob/master/INSTALL.md)를 보고 알아서 설치하기 바랍니다. 또 brew도 없으면 ~~일상생활을 어떻게 하는지 모르겠지만~~ 설치하기 바랍니다.

```sh
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)" # brew 있으면 생략
```

[home brew 홈페이지](https://brew.sh/ko/)에서 가져왔습니다.

이제 oh-my-zsh을 설치하겠습니다. omz는 vi 커맨드를 사용해도 nvim으로 커맨드를 에일리어싱하기 위해서 필요합니다.

```sh
sh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)" # omz 있으면 생략
```

```sh
cd # 루트 폴더로 이동
vi .zshrc
```

위 파일에서 다음처럼 수정하기 바랍니다.

```sh title='.zshrc'
alias vim="nvim"
alias vi="nvim"
alias vimdiff="nvim -d"
export EDITOR=/usr/local/bin/nvim # M1이면 /opt/homebrew/bin/nvim
```

마지막은 neovim을 실행 전 설정입니다. 이렇게 하면 기존 vi를 실행하지 않고 새롭게 설치한 neovim을 사용하게 됩니다. 마치 백엔드 nginx 백워드 프록시처럼 기존 vi로 향할 커맨드가 새로운 nvim으로 향하도록 합니다.

### 보존

```sh
git clone 본인원격레포 ~/.config/nvim --depth 1 && nvim
```

우리가 원하는 것은 `git clone` 만으로 개발하는 환경을 바꿔도 neovim 환경을 일관되게 사용하고 싶습니다.

```sh
cd ~/.config/nvim
vi init.lua
```

먼저 `init.lua`를 설정하기 바랍니다. 여기서는 파일만 만들고 끝내도 됩니다.

```lua title='init.lua'
print("hello neovim")
```

`:wq` 다음 명령을하고 저장하고 닫기바랍니다.

```sh
git init
git add init.lua
git commit -m "neovim init"
# 그래봤자 github이겠지만 알아서 원격 연결하기 바랍니다.
git push
```

여기서 팁을 하나 주자면 본인 개인 레포를 만들기 바랍니다. 본인 레포에서 본인의 개발환경도 이슈로 관리하기 바랍니다. 또 github-flow 방식으로 레포를 운영하면 효율적일 것입니다.

<!-- 저는 현재 저 혼자 사용해서 주석으로 관리하고 있지만 이슈를 추가하고 체계적으로 설정하기 어려운 플러그인을 시도하고 롤빽하기 좋습니다. -->

### 삭제

<!-- @todo: rm -rf 짤 -->

```sh
# Linux / Macos (unix)
rm -rf ~/.config/nvim
rm -rf ~/.local/share/nvim
```

가끔은 다른 distro를 경험하고 영감을 받고 싶을 때가 있습니다. 잠시 삭제하고 본인 것을 나중에 다시 설치하기 바랍니다.

또 마음에 안든다 싶으면 그냥 삭제하고 처음부터 다시 만들 때도 은근히 있습니다. 뭐가 뭐하는 녀석인지 잘 모르기 시작하고 어디를 점진적으로 분리하기 시작했는데 오히려 문제가 많아지면 합니다.

## 플러그인 매니져

플러그인 매니져를 사용해도 괜찮고 안 사용해도 괜찮습니다. 저는 지금은 저의 편의성을 위해 일단 플러그인 매니저를 사용하겠습니다.

<!-- 하지만 몇가지 중요한 것들은 알아야 합니다. -->

플러그인 매니저는 크게 2가지가 있습니다.

- [lazy.nvim](https://github.com/folke/lazy.nvim)
- [packer](https://github.com/wbthomason/packer.nvim)

어느것을 선택하는 사실 크게 상관없습니다. 본인 기계의 neovim 버전이 맞으면 됩니다. 저는 `lazy.nvim`을 선택했습니다. [kickstart](https://github.com/nvim-lua/kickstart.nvim)에서 사용하고 있었기 때문입니다. 여기서 저는 양심의 가책도 없이 일부를 복붙했습니다.

```lua title="init.lua"
-- lazyvim 플러그인 설치
local lazypath = vim.fn.stdpath("data") .. "/lazy/lazy.nvim"
if not vim.loop.fs_stat(lazypath) then
	vim.fn.system({
		"git",
		"clone",
		"--filter=blob:none",
		"https://github.com/folke/lazy.nvim.git",
		"--branch=stable", -- latest stable release
		lazypath,
	})
end
vim.opt.rtp:prepend(lazypath)

require('lazy').setup({})
```

여기까지 했다면 플러그인 매니저를 설치한 것입니다. 다음은 테마 설정입니다.

### 테마 설정

편집하기 시작할 때 가장 의욕을 많이 주는 것은 테마일 것입니다.

```lua title="init.lua"
-- lazyvim 플러그인 설치
local lazypath = vim.fn.stdpath("data") .. "/lazy/lazy.nvim"
if not vim.loop.fs_stat(lazypath) then
	vim.fn.system({
		"git",
		"clone",
		"--filter=blob:none",
		"https://github.com/folke/lazy.nvim.git",
		"--branch=stable", -- latest stable release
		lazypath,
	})
end
vim.opt.rtp:prepend(lazypath)

require('lazy').setup({
  { "catppuccin/nvim", name = "catppuccin", priority = 1000 },
})
```

위처럼 설정하기 바랍니다. 그리고 껐다가 키면 뭔가가 설치될 것입니다. 또 껐다키면 완전히 설정될 것입니다. 여기서부터 에디터가 간지나기 시작할 것입니다.

여기서 정말로 중요한 것은 공식 레포를 들어가보는 활동입니다. 저는 [catppuccin](https://github.com/catppuccin/nvim)을 설치하고자 했습니다. neovim이 어느 레포에서 가져오는지 무슨 이름으로 설정되는지 알아내는 것이 중요합니다.

```lua title="lua/plugins/theme.lua"
return {
	"catppuccin/nvim",
	name = "catppuccin",
	priority = 1000,
	init = function()
		-- catppuccin 컬러 태마 설정
		vim.cmd.colorscheme "catppuccin-mocha"
	end
}
```

`init`은 load 전에 실행할 수 있게 해줍니다.

```lua title="init.lua"
require('lazy').setup({
	require 'plugins.theme',
})
```

위처럼 관심사를 분리하는 것도 가능합니다. 어느정도 설정이 커지기 시작하면 관심사를 분리하는 것이 좋습니다. 중요한 것은 neovim을 실행할 때 `init.lua`가 실행된다는 점입니다. 그래서 가져오게 만들고 실행하도록 해야 합니다.

### git 설정

![neovim github 설정 후 이미지](/img/2024-02-14/git-save.png)

git 설정을 하면 위처럼 될 것입니다.

저는 위 설정을 [kickstart](https://github.com/nvim-lua/kickstart.nvim/blob/master/init.lua)에서 복붙했습니다. 그래서 사실 무슨 내용인지 자세히는 모릅니다.

```lua title="lua/plugins/theme.lua"
return {
	-- git 설정
	-- Adds git related signs to the gutter, as well as utilities for managing changes
	'lewis6991/gitsigns.nvim',
	opts = {
		-- See `:help gitsigns.txt`
		signs = {
			add = { text = '+' },
			change = { text = '~' },
			delete = { text = '_' },
			topdelete = { text = '‾' },
			changedelete = { text = '~' },
		},
		on_attach = function(bufnr)
			local gs = package.loaded.gitsigns

			local function map(mode, l, r, opts)
				opts = opts or {}
				opts.buffer = bufnr
				vim.keymap.set(mode, l, r, opts)
			end

			-- Navigation
			map({ 'n', 'v' }, ']c', function()
				if vim.wo.diff then
					return ']c'
				end
				vim.schedule(function()
					gs.next_hunk()
				end)
				return '<Ignore>'
			end, { expr = true, desc = 'Jump to next hunk' })

			map({ 'n', 'v' }, '[c', function()
				if vim.wo.diff then
					return '[c'
				end
				vim.schedule(function()
					gs.prev_hunk()
				end)
				return '<Ignore>'
			end, { expr = true, desc = 'Jump to previous hunk' })

			-- Actions
			-- visual mode
			map('v', '<leader>hs', function()
				gs.stage_hunk { vim.fn.line '.', vim.fn.line 'v' }
			end, { desc = 'stage git hunk' })
			map('v', '<leader>hr', function()
				gs.reset_hunk { vim.fn.line '.', vim.fn.line 'v' }
			end, { desc = 'reset git hunk' })
			-- normal mode
			map('n', '<leader>hs', gs.stage_hunk, { desc = 'git stage hunk' })
			map('n', '<leader>hr', gs.reset_hunk, { desc = 'git reset hunk' })
			map('n', '<leader>hS', gs.stage_buffer, { desc = 'git Stage buffer' })
			map('n', '<leader>hu', gs.undo_stage_hunk, { desc = 'undo stage hunk' })
			map('n', '<leader>hR', gs.reset_buffer, { desc = 'git Reset buffer' })
			map('n', '<leader>hp', gs.preview_hunk, { desc = 'preview git hunk' })
			map('n', '<leader>hb', function()
				gs.blame_line { full = false }
			end, { desc = 'git blame line' })
			map('n', '<leader>hd', gs.diffthis, { desc = 'git diff against index' })
			map('n', '<leader>hD', function()
				gs.diffthis '~'
			end, { desc = 'git diff against last commit' })

			-- Toggles
			map('n', '<leader>tb', gs.toggle_current_line_blame, { desc = 'toggle git blame line' })
			map('n', '<leader>td', gs.toggle_deleted, { desc = 'toggle git show deleted' })

			-- Text object
			map({ 'o', 'x' }, 'ih', ':<C-U>Gitsigns select_hunk<CR>', { desc = 'select git hunk' })
		end,
	},
}
```

```lua title="init.lua"
require('lazy').setup({
	require 'plugins.theme',
	require 'plugins.gitPlugin' -- 추가
})
```

### fuzzy finder(검색기)

저는 이번에 [telescope.nvim](https://github.com/nvim-telescope/telescope.nvim)을 설정해보겠습니다. vim에서 가장 유명한 fuzzy finder입니다.

```lua title="lua/plugins/telescope.lua"
return {
	'nvim-telescope/telescope.nvim',
	branch = '0.1.x',
	dependencies = {
		'nvim-lua/plenary.nvim',
		{
			'nvim-telescope/telescope-fzf-native.nvim',
			-- NOTE: If you are having trouble with this installation,
			--       refer to the README for telescope-fzf-native for more instructions.
			build = 'make',
			cond = function()
				return vim.fn.executable 'make' == 1
			end,
		},
	},
	init = function()
		-- 검색기 활성화
		local builtin = require('telescope.builtin')
		vim.keymap.set('n', '<leader>ff', builtin.find_files, {}) -- 파일이름으로 검색
		vim.keymap.set('n', '<leader>fg', builtin.live_grep, {}) -- 단어 검색
		vim.keymap.set('n', '<leader>fb', builtin.buffers, {})   -- buffer 탭 검색
		vim.keymap.set('n', '<leader>fh', builtin.help_tags, {})
		vim.keymap.set('n', '<C-p>', builtin.git_files, {})
	end
}
```

```lua title="init.lua"
require('lazy').setup({
	require 'plugins.theme',
	require 'plugins.gitPlugin'
	require 'plugins.telescope' -- 추가
})
```

### tabs

```lua title="lua/plugins/tabs.lua"
return {
	'akinsho/bufferline.nvim',
	version = "*",
	dependencies = 'nvim-tree/nvim-web-devicons',
	init = function()
		vim.keymap.set("n", "bs", vim.cmd.BufferLineCloseOthers)
		--vim.keymap.set("n", "<leader>bcr", vim.cmd.BufferLineCloseRight)
		--vim.keymap.set("n", "<leader>bcl", vim.cmd.BufferLineCloseLeft)
		vim.keymap.set("n", "bct", vim.cmd.BufferLinePickClose)
		vim.keymap.set("n", "bt", vim.cmd.BufferLinePick) -- buffer target
	end,
	config = function()
		local bufferline = require('bufferline')
		vim.opt.termguicolors = true
		require("bufferline").setup {
			options = {
				mode = "buffers",
				style_preset = bufferline.style_preset.minimal,
				themable = true,
				numbers = "ordinal",
				close_command = "bdelete! %d", -- can be a string | function, | false see "Mouse actions"
				right_mouse_command = "bdelete! %d", -- can be a string | function | false, see "Mouse actions"
				left_mouse_command = "buffer %d", -- can be a string | function, | false see "Mouse actions"
				middle_mouse_command = nil, -- can be a string | function, | false see "Mouse actions"
				indicator = {
					icon = '▎', -- this should be omitted if indicator style is not 'icon'
					style = 'underline', -- 'icon' | 'underline' | 'none',
				},
				buffer_close_icon = '󰅖',
				modified_icon = '●',
				close_icon = '',
				left_trunc_marker = '',
				right_trunc_marker = '',
				diagnostics = "nvim_lsp",
				offsets = {
					{
						filetype = "NvimTree",
						text = "File Explorer", -- "File Explorer" | function ,
						text_align = "center", -- "left" | "center" | "right"
						separator = true
					}
				},
				padded_slant = true,
				color_icons = true, -- whether or not to add the filetype icon highlights
				get_element_icon = function(element)
					-- element consists of {filetype: string, path: string, extension: string, directory: string}
					-- This can be used to change how bufferline fetches the icon
					-- for an element e.g. a buffer or a tab.
					-- e.g.
					local icon, hl = require('nvim-web-devicons').get_icon_by_filetype(element.filetype, { default = false })
					return icon, hl
					-- or
					--local custom_map = {my_thing_ft: {icon = "my_thing_icon", hl}}
					--return custom_map[element.filetype]
				end,
				diagnostics_indicator = function(count, level, diagnostics_dict, context)
					local icon = level:match("error") and " " or ""
					return " " .. icon .. count
				end,
				separator_style = "thin", -- "slant" | "slope" | "thick" | "thin" | { 'any', 'any' },
				hover = {
					enabled = true,
					delay = 200,
					reveal = { 'close' }
				},
				show_buffer_icons = true,   -- true | false, -- disable filetype icons for buffers
				show_buffer_close_icons = true, -- true | false,
				show_close_icon = true,     --true | false,
				show_tab_indicators = true, --true | false,
			},
		}
	end
}
```

```lua title="init.lua"
require('lazy').setup({
	require 'plugins.theme',
	require 'plugins.gitPlugin'
	require 'plugins.telescope'
	require 'plugins.tabs' -- 추가
})
```

### 리팩토링

원래 이것도 관심사별로 분리한 것인데 아쉬운 점이 있습니다.

```lua title="init.lua"
require('lazy').setup({
	require 'plugins.theme',
	require 'plugins.gitPlugin'
	require 'plugins.telescope'
	require 'plugins.tabs'
})
```

뭐 사용할지 말지 제어하는 관점에서 좋을지 몰라도 저는 제가 사용중이라는 것을 매번 입력하기 귀찮습니다. 또 실수할 가능성도 있습니다. 그래서 먼저 저희는 위 호출하는 지점을 정리하겠습니다.

```lua title="init.lua"
require("lazy").setup("plugins")
```

이렇게 교체하면 됩니다. 상당히 단순합니다. 이렇게 두면 각자 원하는 곳에 관심사별로 모듈을 분리할 수 있습니다. 앞으로는 위처럼 설정하고 계속 이어집니다.

## LSP 설정

![lsp 없음](/img/2024-02-14/no-lsp.png)

먼저 이해해야 하는 것은 LSP입니다. Language Server Protocol의 약어입니다. Language는 프로그래머가 프로그래밍 하는 언어에 해당합니다. 이 언어는 확장자를 통해서 구분하는 경우가 많습니다. js로 끝나면 자바스크립트라는 것을 알 수 있습니다. 프로그래머는 프로그래밍을 합니다. 예를 들어 자바스크립트 프로그래밍을 하면 js 확장자를 갖고 있는 문서를 작성하는 것입니다. 결과적으로 모든 프로그램은 문서입니다. LSP는 이 문서를 효율적으로 작성할 수 있게 해줍니다. Language Client는 우리 프로그래머이고 Sever는 Client의 요청에 맞게 제공합니다. 이 Protocol은 직역하면 규약입니다. 주로 우리는 확장자로 규약을 정할 것입니다. 자바스크립트 확장자라면 `console` 객체가 네이티브 객체라는 것을 프로그래머는 자주사용해서 압니다. 이 `console` 전체를 이해할 수 없어도 부분만 요청해도 남은 완성된 형태를 응답하는 것이 language server입니다. 이 네이티브 객체에 대한 정보를 갖고 있어서 console에 달려있는 메서드도 알 것입니다. console.log도 많이 사용하지만 계층구조가 많아지면 console.trace 메서드도 사용하는 것처럼 language server는 개발자의 생산성을 위해 알고 있습니다.

저는 포괄적으로 syntax highlighting, 자동완성, 저장에 포멧팅, linting에 대한 설정들입니다. 이과정은 사실 어렵게 생각하면 어렵고 쉽게 생각하면 쉽습니다. 막짜면 돌아게 만들 수 있지만 설정을 유지보수하기 어렵습니다. 어디에 무엇을 추가해야 무슨 언어에 어떻게 적용되는지 모르기 때문입니다. 반대로 어렵게 접근하면 분석마비에 걸릴 수 있습니다. 꽤 많고 다양한 플러그인을 활용해야 하기 때문입니다. 본인은 개발분야에서 특정분야에 해당하는 설정만하고 그외 데이터와 관련된 python, 로우레벨을 위한 rust 혹은 zig를 위한 설정도 하고 싶을 것입니다. ~~최소한 저는 설정하고 싶습니다.~~

코드 작성에서 제일 중요한 부분에 해당하기 때문에 이 과정을 천천히 확인하고 작업하는 것이 좋습니다.

여기서 볼 것은 후보군과 목록 분석입니다.

레포에 대한 후보군 분석과 플러그인 분석이 필요합니다. 먼저 레포 후보군입니다.

- ???

다음은 플러그인 후보군입니다.

- [lsp-zero](https://github.com/VonHeikemen/lsp-zero.nvim/tree/v3.x)
  - 먼저 실수입니다. 무조건적으로 lsp-zero가 필요하지는 않습니다. 하지만 앞으로 성장하기 기대하고 있는 플러그인입니다. 프로그래머 입장에서 syntax highlighting, 자동완성, 저장에 포멧팅, linting은 한번에 하고 싶은 경우가 많습니다. 지금은 일부는 자동포멧팅을 지원하고 일부는 자동포멧팅을 지원하지 않습니다. 목적은 추상화이지만 추상화를 하는데 아직 부족한 점이 많습니다.
  - lsp-zero는 IDE랑 비슷한 syntax highlighting, 자동완성, 링팅, 저장시 포맷팅을 설정을 한번에 할 수 있게 만들기 위해 존재합니다. 우리는 코드로 우리 에디터를 설정하는데 이 설정에 대해서 추상화를 제공하는 플러그인입니다.
  - 하지만 자주 사용하는 키바인딩은 활용할 것입니다. 타입의 정의와 구현정의를 구분하고 접근한다는 점이 좋습니다.
- [mason](https://github.com/williamboman/mason.nvim) & [mason-lspconfig](https://github.com/williamboman/mason-lspconfig.nvim)
  - mason은 LSP를 설치, 삭제, 갱신하기 좋은 플러그인입니다.
- [treesitter](https://github.com/nvim-treesitter/nvim-treesitter) & [treesitter/playground](https://github.com/nvim-treesitter/playground)
  - 내부적으로 elisp를 사용합니다. emacs 유저들이 elisp를 사용하는데 그부분을 neovim이 사용할 수 있게 합니다.
  - 원래 LSP 설정을 위해 사용했지만 지금은 하이라이팅을 위해 사용할 것입니다.
- [cmp](https://github.com/hrsh7th/nvim-cmp) & [cmp-lsp](https://github.com/hrsh7th/cmp-nvim-lsp)
  - 자동완성을 지원하는 라이브러리입니다. 자동완성에 대한 설명도 포함되어 있습니다.
- [none-ls](https://github.com/nvimtools/none-ls.nvim)
  - 원래는 null-ls가 존재했습니다. 하지만 아카이브 결정이 나고 다른 사람이 fork하고 유지보수하게 되었습니다. 기존 레포들은 이 플러그인으로 설치할 주체만 바꿔야 할것입니다. 운이 좋게 우리는 후발자주라 일단은 none-ls를 사용하고 나중에 더 좋은 플러그인이 나왔을 때 교체하면 됩니다.
- [nvim-lint](https://github.com/mfussenegger/nvim-lint)

### mason

mason의 목적은 LSP 설치 혹은 삭제입니다. 순수하게 mason만 설치하는 것은 아니고 mason-lspconfig로 LSP를 설정도 같이 합니다. mason에 대해서는 아직 파일 분리를 안 하는 것이 좋을 것 같습니다.

mason-lspconfig의 목적은 neovim이 제공하는 [lspconfig](https://github.com/neovim/nvim-lspconfig) 사이 간극을 줄이는 것입니다.

<!-- ### lsp-zero -->

<!-- ### lspconfig -->

<!-- ### treesitter

treesitter는 많은 LSP가 의존하는 AST를 만들 때 사용하는 것입니다. emacs도 지원하고 vscode도 지원합니다.

파서도 만들고 AST로 만들어서 우리가 작성하는 언어를 이해할 수 있게 해줍니다.

텍스트를 하이라팅하기 위해 필요한 툴입니다.

-->

<!-- ### cmp -->

<!-- ### nvim-lint -->

<!-- ### null-ls를 대체할 none-ls -->

## 유용한 키맵 설정

https://www.reddit.com/r/neovim/comments/13uvsw6/how_can_i_set_my_tab_key_to_be_4_spaces_indent/

tab 대신에 space 4칸으로 수정 하는 방법

```lua
-- 1 tab을 4 space로 변환
vim.opt["tabstop"] = 4
vim.opt["shiftwidth"] = 4
```

```lua
-- 현재 줄기준으로 표시
vim.wo.relativenumber = true
```

## 결론

여러분에게 vim을 추천하겠는가? 저는 절대 추천하지 않을 것입니다. 저 혼자 이 간지라는 꿀을 빨기 위해서 추천 안할 것입니다.
