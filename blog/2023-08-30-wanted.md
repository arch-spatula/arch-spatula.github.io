---
title: '8월 원티드 챌린지'
authors: [arch-spatula]
tags: ['회고', '블로그']
description: '????'
toc_max_heading_level: 6
draft: true
---

# 8월 원티드 챌린지

이번 8월 주제는 TDD입니다.

<!--truncate-->

## 8월 원티드 챌린지

오늘자로 퇴사합니다. 원티드 강의는 이미 3번 했습니다.

이직 방법은 4회차에 논합니다.

변수관리는 어떻게할지 전역상태관리는 어떻게할지 나중에 최적화는 어떻게할지 다룹니다.

최적화는 리액트, 자바스크립트 따로 나누기에는 애매한 것이 많습니다.

회사는 들어가기 전까지 모릅니다.

state는 변수입니다. 일반 프로그래밍에서는 변수입니다. 지역변수와 전역변수를 어떻게 결정할 것인가?

스코프는 컨벤션이 이미있습니다. 변수의 수명주기도 있습니다. 전역변수는 프로그램의 시작부터 종료까지 저장됩니다.

네이임스페이는 이름 충돌문제가 있습니다.

전역변수가 필요한 상황들이 있지만 필요 없으면 전역변수는 줄이는 것이 좋습니다.

자식이 너무 많으면 전역변수를 활용한다는 본인의 기준을 갖고 있도록 합니다.

전역 상태관리가 필요한 이유입니다. 옛날에는 컨테이너 프리젠터 패턴을 활용했습니다.

state는 컨테이너가 들고 있습니다.

프리젠터는 UI 즉 view만 담당합니다.

여러 계층의 자식에게 넘겨줄 때 중간을 건너가지 않고 직접 자식에서 접근해야 하면 랜더링도 효율적입니다.

스타일만 두고 값을 바꾸는 경우는 흔합니다.

손자에게 state를 주입해야 하면 전역 상태관리로 처리하는 개발자들이 많습니다.

Context API의 단점은 랜더링 효율이 낮습니다. 하지만 비즈니스 요구사항이 잡히기 전에 활용하기 좋습니다.

memo로 방지하기에 애매합니다. React.memo는 고려할 부분이 많습니다.

상태관리 변경은 공수가 많이 들어갑니다.

리덕스는 네카라 개발자랑 스터디를 하면서 redux를 많이 사용 안 한다고 합니다.

redux flux 패턴에서 provider는 필요 없는 것같습니다. 리액트 쿼리 많이 사용하면서 덜 사용하게 되었습니다.

리덕스는 면접질문 나올 것입니다. 기본은 맞습니다. 하지만 value가 낮습니다.

신입은 툴 하나를 깊게 파는 것을 권장합니다.

recoil은 atom 패턴을 활용합니다. 비교적 간단한 편입니다.

비정규화를 하면 백엔드 작업이 많이 편해집니다.

selector는 값을 참조해서 만드는 변수입니다. atom의 값을 가져오고 새로운 값을 만듭니다.

서버 상태관리하는 라이브러리는 Observer 패턴 사용하는 경우가 대부분입니다.

서버상태관리가 카카오가 국내의 경우 적용에 성공해서 도입이 많아졌습니다.

react query는 상태 3가지가 중요합니다. fresh는 바로 보여줘도 된는 경우입니다. stale은 갱신이 필요하다는 것입니다.

stale하면 갱신하기 전에 캐시를 보여주고 통신에 성공하면 갱신합니다.

용어 줍줍: multi-step form

새롭게 배운 기술이나 도구가 있는가? 의외로 질문 많이합니다. ES6 문법 사용한다고 하면 이런질문할 가능성 있습니다.

ChatGPT는 트렌스포머로 만든 모델입니다. 번역을 하면 트렌스포머 전까지는 단어 한개 단위로 번역합니다. 하지만 트렌스포머를 활용하면 문맥을 활용합니다.

ChatGPT는 질문할 때 디테일하게 질문하는 것이 좋습니다. 질문을 구체적으로 하면 답변도 구체적이게 됩니다.

라인은 코파일럿을 많이 활용한다고 합니다.

### 질문

신입은 개인 프로젝트가 판단하기 좋습니다. 포트폴리오에 개인프로젝트는 꽤 좋습니다.

Redux, Recoil은 프로젝트 규모를 기준으로 결정합니다.

퇴사 기준은 얻을 수 있는 것이 없을 때입니다. 할 수 있는 것이 없고 성장에 기여해줄 것이 없으면 퇴사를 고려합니다.

독학은 부트캠프보다 유리하고 불리하고 그런거는 없습니다.

신입이력서는 github 보고 블로그 보고 질문합니다. 잘 모르면 모르는 척하는 것이 더 좋습니다. 그래서 블로그 작성은 신중히 하도록 합니다.

공백기는 질문합니다. 알아서 잘풀어가도록 합니다.

전역변수는 컴포넌트에서 받아서 유틸함수에 전달해주는 것이 좋습니다. 이것은 함수형 프로그래밍 원칙입니다.

리팩토링은 성능이 제일 크고 컨벤션 문제입니다. 새로운 사람이 올때마다 들어가는 비용이 너무 큽니다. 성능이 너무 떨어집니다.

프론트엔드 신입은 AWS별로 안 봅니다. 학습은 도서활용하기 바랍니다.

컴포넌트를 나누는 기준은 반복될 때입니다. 너무 길어지면 분리합니다. 하지만 이것은 컨벤션 문제입니다.

통합테스트를 잘 작성하는 노하우는 2회차에 공개합니다.

예외처리를 포함해서 타입지정할 때는 백엔드랑 협의를 잘해야 합니다.

기능개발 위주로 작업을 하고 최적화 경험을 어필할 수 없으면 야근해야 합니다. 기능 개발할 때 고민한 내용을 블로그에 잘 정리해야 합니다.

완전 신입에게 Node.js 기대하는 것은 이상합니다.

신입은 스타일링 무난한거 잘 사용하면 됩니다. 스타일드 컴포넌트 아니면 CSS 사용하도록 합니다.

라이브러리는 몇개 집중해서 사용하는게 어필이 많이 됩니다.

Context API는 싱글톤보단 옵저버 패턴에 가깝습니다.

View랑 로직은 무조건 분리할 필요는 없는데 Custom hook으로 분리합니다.

타입스크립트를 잘 쓰는 법은 복잡한 프로젝트를 해봐야 하고 코드를 많이 봐야 합니다.

제일 좋은 것은 회사일만으로 공부되는 것입니다. 성장할만한 업무를 받을 수 있는 회사로 가야합니다.

폴더 구조는 좋은 코드를 많이 봐야 합니다. 블로그좀 많이 보도록 합니다.

TDD는 개인적으로 어렵다고 봅니다.

컴포넌트 추상화는 객체지향 관점입니다. 컴포넌트 이름만 보고도 무슨일을 하는지 알 수 있어야 합니다.

예전코드 리팩토링하고 싶어지면 성장한 것입니다.

웹뷰는 요즘 유행합니다.

API 명세서 만들어서 데이터 구조 확정짓고 개발해야 효율적입니다.

성능은 라이트하우스, 프로파일러, 성능탭을 활용합니다.

useCallback은 함수를 캐싱하는 hook입니다.

리랜더링 고민은 불필요할정도로 많으면 고민을 시작합니다. 사용자가 불편하면 대응합니다.

통상적으로 사용하는 컨벤션은 의외로 많이 정해진 것이 없습니다. 조직마다 다른게 큰 분야입니다.

php 단점이 이직이 어려울 수 있다는 점입니다.

테스트 코드는 프론트엔드가 요구사항 반영과 커뮤니케이션할 때 좋습니다.

포트폴리오는 개인이든 팀이든 뭐든 좋습니다. 일단 팀이 좋습니다. 그리고 개인은 주어진 것에서 잘하는 것이 중요합니다. 그리고 코드 퀄리티가 중요합니다. 이정도면 됐나? 까지 하면 됩니다.

신입 최소 스택은 React.js, React-Query, 개인적으로 좋아하는 상태관리 라이브러리 최적화는 플러스 알파입니다.

프론트엔드 로드맵을 활용해서 취업 후에도 계속 공부하도록 합니다.

팀원 좋고 월급 적음 VS 월급 많음 팀원 나쁨 -> 돈입니다.

코딩테스트랑 기술면접은 준비해야 합니다.

소스 코드 분석하는 습관은 좋습니다.

퇴사는 회사는 문제가 없고 얼라인이 안 맞으면 이직한다고 설명하면 됩니다.

경력직도 면접보면 많이 떨어집니다.

기술면접도 본인이랑 맞는 회사면 물어봅니다. 면접의 난이도는 면접관이 조절합니다.

프로젝트는 기존 코드를 계속 리팩토링하는 프로젝트가 더 좋습니다.

함수는 암지적인 매개변수를 만드는 행동을 지향하도록 합니다.

신입 면접 준비사항은 100% 이해한 블로그 내용입니다. 어설프게 작성하면 탈탈털립니다.

토스 면접도 기술블로그 질문 많이 합니다.

디자이너와 커뮤니케이션 할 때 어려우면 어쩔 수 없는 경우가 많습니다.

개발할 때는 고민을 잘 담도록 합니다. 프론트는 사용자가 없어도 성능개선할 수 있습니다.

백엔드는 DB를 잘알아야 합니다. 프론트는 많이 알 필요 없습니다. 거의 몰라도 괜찮고 JSON 상하차처럼 생각하면 됩니다.

신입에게 보는 것은 꾸준함과 성장가능성입니다.

신입은 React가 더 좋습니다.

프로젝트에서 어떻게 고민하고 무슨 고민하는지가 더 중요합니다.

요즘은 타입스크립트는 필수입니다.

신입 면접질문으로 클래스에서 존재하던 라이프사이클을 말할 수 있어야 합니다.

기술을 왜 사용했는지 질문했으면 무슨 장점이 있는지 설명해야 합니다. 커뮤니티 서포트도 설명할 수 있습니다.

github에 Star가 많은 Repo 보고 배우면 좋은 코드를 알게 됩니다.

요즘 개발자 블로그는 필수 입니다.

코드를 잘 짜는 것보다 서비스를 잘 운영하는 것이 더 중요합니다.

useCallback도 props 넘겨주는 상황말고 거의 없습니다. 하지만 최적화할 때는 랜더링이 엄청 비효율적이어야 합니다. 시간복잡도 500을 초과하면 고민합니다.

프론트엔드 엔지니어에게 UI구현 능력은 큰회사 아니면 중요합니다.

성능최적화는 눈으로 보이면 바로 개선하고 조기최적화는 신중하도록 합니다.

풀스택은 프론트 백엔드 모두 70 능력이 있어야 합니다.

네이밍 꿀팁 없습니다. 어렵습니다. 개인적으로 디테일하게 작성합니다.

한국 리액트 네이티브 개발자가 별로 없어서 침투해볼만한 시장입니다. 물론 모바일에 뜻이 있어야 합니다.

Webpack은 설정해볼 일이 거의 없습니다. 하지만 설정을 공부하기 애매합니다.

리액트 SI는 가능해 보입니다.

SI가 프로젝트 8 ~ 9 개월은 괜찮은 회사일 가능성이 높습니다.

큰회사는 베스트 프렉티스를 보고 배울 수 있어서 갑니다.

의외로 배포는 덜보고 코드를 많이 봅니다.

큰회사는 프론트엔드 지식보다 CS 지식을 물어봅니다. 신입은 CS 지식위주로 질문합니다.

기능은 브랜치를 최대한 쪼개서 진행하도록 합니다.

리액트 기초강의가 많은 이유는 만들기 쉽기 때문입니다. 중급은 보안상 공개할 것이 많습니다.

이직은 월단위로 극단적으로 자주하면 안 좋습니다. 프론트엔드 CI/CD는 AWS 연결하면 끝입니다. github action으로 충분합니다.

회사는 1년은 버텨보도록 합니다.

자바스크립트는 동물책으로 공부합니다.

## 원티드 특강

전역 상태관리는 지나가기만 하면 전역상태로 관리하기 바랍니다.

atom은 공통함수에서 활용하기 어럽습니다. recoil state는 다른 hook 혹은 컴포넌트에서 만 사용할 수 있습니다. 또 암시적 매개변수와 사이드 이펙트가 발생하기 때문에 조심해야 합니다. 순수함수가 아니기 때문에 함수형 프로그래밍 원칙에 어긋납니다.

일반적으로 context API는 랜더링 효율이 나쁩니다.

Optimistic update는 의외로 많이 안 씁니다.

### 개요

무엇을 테스트할 것인가? 어디까지 테스트할 것인가? 어떻게 테스트할 것인가? 테스트도 자동화할 수 있는가? 그리고 프론트엔드도 TDD를 실천할 수 있는가?

UI 테스트는 프론트엔드는 사용자가 어떻게 사용하는지 테스트를 해야 힙니다. 하지만 이번 시간에는 깊게는 안 다룹니다. UI의 스타일에 관한 테스트도 존재하지만 의미가 약합니다. 컴포넌트 렌더링 순서도 테스트하기 단점이 많습니다. UI 테스트는 존재여부를 파악하는 것이 좋습니다. 하지만 로직상 순서를 테스트할 때 도움될 경우도 있을 수 있지만 별로 없습니다.

이런 이유로 UI 테스트는 의미가 별로 없습니다.

테스트는 유저 시나리오를 기준으로 작성하는 것이 좋습니다. PM이 작성한 유저 스토리를 기준으로 테스트 코드를 작성해야 합니다. 사용자의 행위를 기준으로 테스트하기 바랍니다.

테스트를 위한 테스트는 잘못된 것입니다. 테스트 코드는 있으면 유용하지만 없다고 문제가되는 것은 아닙니다.

TDD로 테스트를 타이트하게 작성하면 코드 가변성이 너무 떨어집니다. 신뢰하기 어렵거나 버그가 자주 발생하는 지점위주로 테스트하는 것이 좋습니다.

이벤트 핸들러를 주입하기 위해 랜더링을 합니다. 이런 이유로 존재위주로 UI 테스트를 하는 것이 좋습니다.

프론트엔드에서는 단위테스트와 통합테스트 경계가 애매합니다. 프론트엔드는 경우의 수를 조합해야 하기 때문에 테스트 방식이 특이합니다.

given - when - then 으로 테스트 코드를 작성하면 됩니다. 테스트 코드를 작성하는 패턴입니다.

단위 테스트는 가장 작은 테스트 단위입니다. 하지만 자주 사용하는 테스트 코드는 jest로 테스트 코드를 작성합니다. vitest는 현재 크게 도움될 것같지 않습니다. 개인적으로 jest로 공부할 것을 더 추천합니다.

통합테스트는 컴포넌트 상호작용하는지 확인합니다. 단위테스트와 단위테스트가 결합되는 지점을 통합테스트로 이해하면 됩니다.

E2E 테스트는 사용자 관점에서 테스트를 진행하는 것입니다. QA가 빡센 회사는 E2E 테스트로 처리를 많이 한다고 합니다. 실제 환경처럼 테스트하기 때문에 실제 DB랑 연결도 됩니다. 단위 테스트에서는 이벤트 발생한것처럼 흉내내지만 E2E 테스트는 흉내내는 방식이 다릅니다. 유저 자체를 흉내닙니다.

테스트 코드의 의미가 강력한 경우는 리팩토링할 때입니다. 새로운 비즈니스 로직을 수기로 확인하지 않고 테스트코드가 보증면 작업이 편해집니다.

리팩토링을 많이 할 경우랑 대규모 업데이트가 필요할 때 테스트 코드가 효율이 좋습니다. 리팩토링한다는 것자체가 작업시간을 어느정도 보장받은 것입니다. 그래서 테스트코드 작성해서 혜택을 누리기 바랍니다.

컴포넌트에서는 hook을 사용할 수 있는데 테스트코드에서는 hook을 다르게 작성해야 합니다.

act는 테스트 코드에서 act가 있고없고 차이는 없지만 act가 있어야 실제 브라우저가 있고없고 차이가 있습니다. 브라우저가 있는 것처럼 작성해야 합니다. userEvent는 유저의 행위를 흉내냅니다. render는 컴포넌트를 그립니다. watiFor는 비동기 호출을 대기합니다.

참고로 recoil provider는 jest가 접근할 필요가 없지만 hook에서 모두 provider로 감싸주도록 합니다.

history 패키지는 현재 stack을 확인할 수 있는 패키지입니다. memoryRouter도 같이 필요합니다.

테스트 provider에서 리액트 쿼리는 retry를 false로 설정하도록 합니다.

beforeAll에 jest.spyon(console, "error").mockImplementation()

nock은 사용하면 엔드포인트를 mocking합니다. 해당하는 엔드포인트에 통신을 흉내내입니다.

waitFor는 비동기처리 관련 통신을 합니다.

data-testid로 랜더 존재여부를 쿼리하는 것을 확인할 수 있습니다.

nock은 MSW보더 덜 부담스럽습니다.

테스트 코드는 it should로 작성하는 것이 정석인 것같습니다. 최근에는 특이하게 한글로 작성하는 경우가 많습니다. PM 요구사항을 더 쉽게 표현할 수 있습니다.

PM과 QA가 테스트를 보고 작성하는 방식도 있고 본인이나 다른 개발자들이 중요하다고 생각하면 알아서 넣어야 합니다. 기획에 구멍이 생겨도 개발자가 알아서 공부해야 합니다.

it, test, spec은 각자 조직마다 컨벤션 차이입니다. given - when - then은 주석으로 알려줘도 됩니다.

테스트 코드는 하드 코딩으로 작성해도 됩니다.

history.location에 toBe 어서션으로 라우트 테스트를 할 수 있습니다.

중간 크기의 컴포넌트를 테스트하고 싶을 때는 mock을 조금섞거나 단위테스트로 쪼개는 것도 좋을 수 있습니다.

recoil은 state를 mocking할 수 없습니다. recoil은 테스트코드 작성할 때는 이벤트핸들러에서 변경되었는지만 봅입니다.

recoil값 변경을 확인하고 싶으면 변경하는 이벤트를 테스트해야 합니다.

mobx는 하드코딩하고 테스트를 하는 것이 더 일반적인 패턴입니다.

외부 API 연동은 무조건 mocking해야 합니다. 결제는 일반적으로 결제 로직을 백엔드에서 처리합니다.

오늘 예제는 나중에 공개합니다.

테스트 코드에서 항상 유저이벤트는 비동기입니다. 또 라우팅은 history.location.pathname을 접근으로 테스트를 검증하기 바랍니다.

프론트엔드에서는 완벽한 TDD는 불가능에 가깝습니다. 기본적으로 실패 케이스를 모두 확인해줘야 합니다. UI가 모두 완성된 상태에서 비즈니스로직에 테스트 코드에 작성이 가능합니다. 또 TDD는 결합도가 높아집니다. 또 PM이 본인 기획의도를 모르는 경우도 많고 구멍도 많습니다. 본인이 원하는 것이 뭔지 모르는 경우 많습니다.

빌드 전에 테스트하고 또 github action에서 테스트 설정하는 것도 전략입니다. PR 시점 뿐만아니라 merge 시점에서 테스트를 실행하는 경우도 많습니다.

userEvent보단 그냥 user라고 작성하는 것이 더 좋은 것 같습니다. provider는 모두 적용하고 import하는 경우도 많습니다.

findBy 쿼리는 비동기적으로 동작합니다. 에러는 실패케이스로 작성하는 것이 더 좋은 테스트 케이스입니다.

---

요즘관심있는 것은 무엇인가? 기술면접 대비하는 방법입니다. 뉴스레터를 읽어보는 것도 좋은 방법입니다.

기술면접에서 코테 서비스 이용하도록 합니다. 신입 프론트엔드는 질문이 어느정도 정해졌습니다. 면접 스터디를 진행해보도록 합니다. 면접 경험을 쌓도록 합니다. 서류 통과도 프로젝트와 블로그 중심으로 질문할 것이기 때문입니다. 예비 회사에서 연습을 시작합니다. 프론트엔드 CS 지식은 디스크, 케시, 메모리를 질문하지 않고 네트워크를 깊게 질문합니다.

시장에서 가치를 확인하고 싶을 때는 채용공고를 많이 확인하도록 합니다.

채용공고에서 어떤 사람을 찾는지 분석합니다.

회사 기술스택을 이해하고 그 기술스택의 장점을 설명할 준비하고 지원합니다. i18n은 국제화입니다.

테스트코드는 맥락에 따라 다릅니다. 처음 출시하는 상황이면 구축하고 테스트코드를 도입합니다. 기능 추가는 테스트코드를 먼저 추가합니다.

leetcode는 우리나라에 적합하지 않습니다. 프로그래머스 문제집 풀이가 더 좋습니다.

실제 실무에서 테스트 코드를 작성합니다. 테스트는 중요한 비즈니스 로직위주로 테스트합니다. 테스트 코드는 성공 케이스별로 UI 변화는 확인해도 스타일링에 대한 테스트는 필요 없습니다.

프론트엔드는 단위 테스트와 통합테스트 경계가 애매합니다. 프론트엔드에서 점진적으로 도입이 많이 보입니다. 리팩토링했을 때 비즈니스 로직이 동일하다는 것을 검증할 때 활용합니다.

통신 mocking은 nock을 활용합니다. 무조건 /user로 시작합니다.

nock 서순?

nock의 서순은 중요합니다. 클릭 이후에 mocking을 해서 nock을 활용해야 합니다. act 이후 nock을 처리해야 합니다. nock은 이벤트 다음에 작성해야 합니다.

act, nock, awitFor를 섞어 사용하면 라우팅 테스트도 구현할 수 있습니다.

리액트 쿼리를 테스트할 때는 custom hook을 테스트하지 말고 컴포넌트를 테스트하도록 합니다.

### 질문

E2E 테스트는 디자이너와 QA가 같이 진행합니다. 개발자가 일부만 자동화합니다.

테스트 코드는 네이버는 작성합니다. 토스는 자유로 둡니다. 리팩토링이 더 성장가능성을 잘 보여줍니다. 하나의 레포가 발전하는 모습을 보여주는 것이 더 좋습니다. 또 리팩토링은 최근의 좋은 코드만 보기 때문에 좋습니다.

useEffect lent는 다음 링크를 참고합니다. https://velog.io/@khy226/useEffect-%EC%99%84%EB%B2%BD-%EA%B0%80%EC%9D%B4%EB%93%9C-%EC%9A%94%EC%95%BD

https://www.robinwieruch.de/react-router-private-routes/

의외로 에러바운더리 많이 활용합니다.

WAS는 대부분 사용합니다. node.js도 비슷하게 있을 것입니다.

함수는 순수함수 가깝게 유지하고 임시형 매개변수는 최대한 절제합니다.

https://jojoldu.tistory.com/615

에러바운더리는 한번에 처리하면 유용할 수 있습니다.

3-Way 핸드쉐이크, 웹 소캣이 뭔지 특히 소캣이 뭔지 알아봅니다.

RDBMS, NoSQL 정규효 무엇이지는 알고있도록 합니다. 가능하면 공고에 있는 것은 면접질문으로 봅니다.

이직할 때는 개인 프로젝트가 별로 안 중요합니다. 회사에서 무슨일을 했는지랑 무슨이유로 기술을 사용했는지 확인합니다. 신입은 무조건 개인 프로젝트하도록 합니다.

fontsource가 정말 좋은 라이브러리입니다. https://github.com/fontsource/fontsource

부족해도 계속 지원해보도록 합니다. 면접이라도 보도록하고 스스로 부족한 것을 확인하도록 합니다.

코테, 과제는 회사마다 다릅니다.

개발자에게 좋은 학원은 없습니다. 유명한 부트캠프 멘토링도 비슷한 고민을 하고 있습니다. 자바스크립트, 타입스크립트, 리액트 프로젝트로 충분한 경우 많습니다. 그리고 리액트 잘 사용하면 Next.js 잘 할 거 압니다.

memo는 비싼 계산에 사용하는 ifream은 useMemo가 정답이 맞을지도 모릅니다.

SI 기업 중에도 좋은 회사도 있습니다. 나쁜 서비스 회사도 있습니다.

주니어는 다양한 경험이 도움됩니다. 하지만 전문성을 위해서는 이직을 해야 합니다.

nock은 API를 더 간단하게 mocking합니다.

플젝 배포 꿀팁은 AWS Amplyfiy가 제일 편합니다. 하지만 Next.js면 그냥 vercel 사용하도록 합니다.

연봉은 회사가 부르게 만들도록 합니다.

테스트 코드는 같이 하는 것이 좋습니다.

프론트 개발 잘한다는 것은 저도 모릅니다. 유명한 개발자 만나도 모르겠는 경우도 있습니다. 개발을 잘한 다는 것은 제품 고민을 잘하는 것 같습니다. 프론트엔드는 사용자랑 가까우니까 디바이스랑 깨지지 안헥 하는 것입니다. 아니면 UX적인 지식을 활용하는 것도 좋습니다.

access Token은 스토리지에 안 담는 전략도 있습니다.

서버는 환경을 동일하게 만드는 것이 중요합니다.

GraphQL은 신입은 공부하지 말도록 합니다. REST API만 공부해도 꽤 공부할 것이 많습니다.

경력직 이직준비는 이력서 업데이트를 분기단위랑 회사가 빡치게하면 이력서를 업데이트합니다. 회사에 조금씩 지원합니다. 일반적인 공고에 지원하면 합격이 낮습니다. 그리고 회사가 면접도 가볍게 봅니다. CS 지식 리뷰하고 블로그 글 다시 복기하고 면접봅니다. 면접 필수 질문 확인합니다.

최적화 경험은 좋게 봅니다. 테스트와 최적화 중 최적화를 더 보는 것 같습니다.

props가 너무 많으면 객체로 묶어보는 전략을 활용합니다.

신입은 어디든 회사 경험이 필요합니다.

쿠키저장은 백엔드가 정한 정책을 기준으로 합니다. 하지만 response에 있는 것을 cookie에 담으면 백엔드 이상한 것입니다.

프론트엔드는 가상환경 설정할 필요 없을 수 밖에 없는 것이 브라우저에서 동작해야 하기 때문입니다.

개발바닥 이력서 리뷰 컨텐츠를 더 많이 보도록 합니다. 하나를 깊게 공부한 기록을 보여주는 것이 좋습니다. 예외처리처럼 꾸준히 뭘 한 것을 보여주는 것이 좋습니다.

타입스크립트는 요즘은 필수입니다. 하지만 Zod는 선택입니다.

블로그는 2주에 1회는 작성하려고 합니다.

경력직은 회사에서 경험한 것을 찾습니다. 현업에서 주니어가 잘해야 하는 것은 구조, 변수관리, 랜더링 관리를 잘해야 합니다.

웹 소캣 관련팁은 채팅 서비스 만들고 알아서 공부합니다.

깊게 팠다는 것은 꼬리질문을 답할 수 있으면 깊게 판것입니다.

에러 바운더리는 현업이 아니면 모를 가능성이 충분히 있습니다.

잘만든프로젝트는 코드에 군더더기가 없는 것입니다.

개발을 잘하는 것은 서비스 운영을 잘 하는 것입니다. 최적화도 사용자가 불편함을 덜어주는 것입니다. 이부분에 집중하도록 합니다.

코파일럿이 도움이 별로 안되면 코드 잘 짜는 것입니다. 최적화는 무조건 나중에 할수록 좋습니다.

팀프로젝트에서 중요한 것은 협업한 스토리입니다. 프로젝트 혼자하면 안 좋은 습관이 듭니다.

혼자하면 주어진 기능을 최대한 잘 짜도록합니다.

신입 프론트엔드는 1년만 있어도 좋은 사수를 구분할 가능성이 생깁니다.

변수 네이밍보단 변수 상태관리 잘하는 것이 더 중요합니다.

리액트를 깊게 공부하는 것은 좋은데 특이한 라이브러리를 깊게 파는 것은 융용합니다.

프론트가 제일 어려운 것을 뭘해야 할지 모를 때입니다.

신입 채용공고에서 기술 스택은 회사마다 다릅니다.

물경력은 면접으로 검증해보도록 합니다. 시장의 판단을 받기위해 면접을 보독합니다. 주니어는 3년까지 중고신입으로 봅니다.

기술스택은 직접 강의없이 혼자서 사용해보도록합니다.

부트캠프 수료 후 6개월까지는 괜찮습니다. 넘으면 조심하도록 합니다.

3년차에 준하는 신입은 아무도 모릅니다. 그래서 지원하도록 합니다.

백엔드 엔지니어와 커뮤니케이션은 정확히 소통해야 합니다. 가능한지 불가능한 잘 이야기합니다.

개발자는 다른 경력도 경력을 약간 칩니다. 물론 회사마다 다릅니다.
