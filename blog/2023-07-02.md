---
title: '반년'
authors: [arch-spatula]
tags: ['react', 'visibility', 'backface-visibility', 'css', 'emotion']
description: '카드 뒤집기 구현은 생각보다 난이도 있었습니다. 하지만 재미있습니다.'
toc_max_heading_level: 6
draft: true
---

<!--truncate-->

## 잡생각

- 시간이 많을 때 접근하는 방식입니다.
  - 작은 지식을 꾸준하게 쌓아 올리기
  - 복습 자주하기
- 검색은 개발자가 일 잘하는 스킬입니다.
  - 개발자의 개발 스킬이 아니다.
  - 검색으로 해결한 것은 본인의 능력으로 해결한 것이 아닙니다.
  - 검색으로 문제 해결하는 것이 괜찮은가?
    - 의외로 사람마다 생각하는게 다릅니다.
    - 검색이라도 해서 문제를 해결해야 한다는 것은 대부분 동의합니다.
    - 검색으로 문제를 해결하면 문제를 해결한 것이 아니라는 관점도 많습니다.
    - 하지만 실용적으로 해결방식을 이해하면 본인이 해결한 것은 맞지만 본인이 구현한 것은 아니라고 받아들일 수 있습니다.
- 순수주의, 장인정신, 선비정신을 추구해야 하는가?
  - 기본중 기본이고 추구해야 하는 자세라고 합니다.
  - 개인적으로 동의하기 어려운 부분이 많습니다.

## 잡생각

[[Javascript 미세팁] if else 리팩토링 #2 중첩 조건문 처리하기](https://www.youtube.com/watch?v=4I-MiMmZdcQ)

위와 같은 리팩토링 팁과 과정을 알려준다는 것을 생각해봅시다. 세상에 기초가 너무 없는 사람들이 심각하게 많다고 알려주는 것으로 받아들일 수 있습니다. 아마 면접관 모자를 쓰면 그렇게 받아 들여야 합니다. 그리고 그렇게 받아들일 것입니다.

면접은 실무가 아니라 정치입니다.

반대로 생각해보면 꽤 많은 사람들이 리팩토링할 때 모르는 방법론이고 그리고 인지할 수 있는 범위 내에서 순서대고 코드를 수정한다는 점이 인지 한계점을 감안하고 코드를 작성한다는 것을 알 수 있습니다.

## 엣지?

[😓 Web dev's biggest buzzword, explained? #webdevelopment #programming](https://www.youtube.com/shorts/GOihOAcIgMw)

## 로코의 바실리스크?

로코의 바실리스크 & 파스칼의 내기

## 잡생각

- 지금까지 개발문화, 개발 생태계, 개발자의 삶에 대해서 잘못알고 있던 것이 많고 하나씩 바로잡고 있습니다.
  - EO 출현한 개발자들과 개발바닥이 사람을 많이 망친다고 합니다. 대부분의 개발자들은 절대 그렇지 않다고 합니다.
    - 개발자들에 대해서 잘 못된 환상을 자꾸 심어주는 사람들이라고 합니다.
    - 스타트업이건 SI건 대부분 좋좋소, 헬테크, 좋코딩과 비슷하다고 합니다.
      - 부모님, 배우자 장례식도 못 다녀오게 막는다고 합니다.
      - 폐드립 가득한 욕설이 일상적입니다.
      - 주말출근은 기본이고 예비군도 계속 연기하고 주말에 다녀오고 주말에 다녀와도 연차 신청서를 올리도록 합니다.
      - 물건 던지고 사무실 흡연은 당연합니다(전자담배도 아닙니다).
    - 보통 작은 실수는 관용적이고 큰 실수도 가능하면 최대한 보듬으려고 한다는 거짓 정보를 많이 퍼트린다고 합니다.
  - 성장가능성은 강조할 필요가 없습니다.
    - 회사는 직원의 성장에 관심이 없고 관심이 없어야 합니다.
    - 직원성장이 회사 성장에 도움될 것이라는 착각하는 이상한 사람들이 많습니다.
    - 조금만 정상적인 사고를 하면 성장은 이미 다 되어 있어야 하고 중요한 것은 기여입니다.
    - 개인의 성장은 무조건 개인의 몫입니다.
  - 자꾸 개발을 재미있게 해야 실력이 는다는 거짓정보를 퍼트리는 사람들도 많습니다.
    - 재미있게 개발하는 사람들은 개발자의 자질을 의심해봐야 합니다.
      - 프로페셔널한 것이 재미있게 한다는 것만큼 프로페셔널하지 못한 것은 없습니다.
    - 개발실력은 갖고 있는 병만큼 늘어납니다.
  - 직무역량에서 제일 중요한 것은 독기입니다.

###

- 하는 실수가 많고 그동안 몰랐던 것이 엄청나게 많았습니다. 한번 해본 것은 금방적용하지만 처음해보는 것은 실수하고 기록하면서 적용했습니다. 그만큼 몰랐던 것이 많습니다.
- 교육과정 중에 잘하는 편에 속해서 진짜 잘하는 줄 착각을 크게했습니다.
- 개발적인 고민에도 한계 효용이 있습니다.
  - 고민이 어느정도 있으면 성장하지만 고민의 수준과 크기만큼 1대1로 대응되는 것은 아닙니다.
- 이미 해결해봤던 문제면 또 해결할 수 있습니다. 해결해본 문제가 많다면 작업 대부분 처리가 많고 빨라야 합니다.

###

- github 프로젝트는 생각의 부담을 전가하기 위해서 사용합니다.
  - 가능한 이슈에 작업의존성도 트레킹하도록 합니다.
    - 의존성이 많으면 코드리뷰가 많이 필요할 브랜치일 가능성이 큽니다.
    - 의존성이 많으면 코드리뷰 우선순위를 높여줄 필요가 있습니다.
  - 브랜치를 merge하는 것으로 의존성개수를 높여서 우선순위를 높이는 것도 전략입니다.

###

- 우아한 문법에 매료되고 싶어서 엘릭서를 보기 시작했습니다.
  - 뭘 만들지는 저도 모르겠습니다.
  - 그냥 무언가 재미있는 것에 빠지고 싶었습니다.

## 잡생각

- 무용지용(無用之用): 쓸모가 없는 것이 도리어 크게 쓰여진다는 뜻이다.
- 개인이 생각하는 것과 회사가 생각하는 것은 다릅니다.
  - 개발자가 컴퓨터공학, 소프트웨어 공학 전공을 안해도 괜찮다고 생각하는 개인은 많습니다.
  - 회사는 전공자만 할 수 있다고 보는 곳이 대다수입니다.
  - 개인은 개발을 재미있게 해서 꾸준히 하고 몰입해서 성장하는 것이 중요하고 좋은 방향이라고 합니다.
  - 회사는 근본적으로 개인의 성장은 개인의 몫이 당장 중요한 것은 무조건 기여입니다. 성장은 이미 다되어 있는 상태로 회사에 지원해야 합니다.
  - 개인이 보기에는 시작하기 늦은 나이는 없습니다. 돌아가면 늦은 나이가 될 가능성이 큽니다.
  - 회사는 남자는 26세 여자는 24세 이상이면 무조건 늦은 나이라고 봅니다.
  - 개인은 프로그래밍, 문제해결 능력이 중요하다고 봅니다.
  - 회사는 학벌이 중요하다고 봅니다.
  - 개인은 프로그래밍을 재미있게 하면 좋다고 합니다.
  - 회사는 프로그래밍이라는 일을 재미있게 하면 무엇인가 잘못된 것이라고 봅니다.
  - 개인은 개발을 즐길 줄 아는 개발자가 훌륭한 개발자라고 봅니다.
  - 회사는 독기를 가진 개발자가 훌륭한 개발자라고 봅니다.
- 부정적인 사고는 대응하지 않는 것이 더 효율적입니다.
  - 객관적인 사실을 추구하는 것이 아니라 주관적인이든 객관적이든 오류를 받아들여야 한다고 합니다.
- 저는 장인을 존경하는데 소프트웨어 엔지니어링에서 장인정신은 선비정신과 비슷하게 취급받는 것 같습니다.
  - 엄청나게 클린하고 최적화된 코드가 아니면 절대 merge하지 말아아야 한다고 보는 그런 관점입니다.
- 프론트엔드 엔지니어가 비즈니스 가치를 창출하는 방향은 UX인가? 이런 의문이 생겼습니다.
  - 만약에 명제를 참으로 둔다면 저는 기술적으로 갖고 있는 스킬을 비즈니스에 적용해볼만한 지식이 있다고 착각할 수 있습니다.
- 하버드대학교 파이썬 CS 개론 수업을 듣고 싶어졌습니다.
  - 부족한 CS 지식을 보완하고 파이썬의 우아한 문법에 매료되고 싶어졌습니다.

### 백일몽은 해롭다.

maladaptive daydreaming(부적응적 백일몽)

[Your Constant Daydreaming Can Be Hurting Your Mental Health](https://www.youtube.com/watch?v=YUSi9tzdNiE)

행복회로 현실도피하는 정신병입니다.

지금 자면 꿈을 꾸지만 지금 일하면 꿈을 이룬다는 말로 살아가야 합니다.

## 23.06.26.

### 좋은 리액트 코드의 기준

- JSX 컴포넌트는 상태가 없을수록 좋은 코드입니다. 상태는 최대한 hook에서 제어하고 JSX에 주입하는 방식으로 제어할 것을 권장합니다.

## Dropdown으로 props 내리기

완수했습니다. 그냥 내리는 것으로 해결했습니다.

## 랜딩페이지

https://web.dev/i18n/ko/serve-images-webp/

사실 이미지 넣고 버튼 때려 넣으면 끝입니다. 문제는 이미지를 넣는 것입니다.

### 스톡이미지 선정

https://www.pexels.com/ko-kr/photo/268351/

### webp 변환

변환 작업을 위해 homebrew를 활용해 cwebp를 설치했습니다.

```sh
brew install webp
```

위가 설치명령입니다. 절대 친절하게 알려주지 않습니다.

물론 저렇게 설치하면 터미널 자동완성 지원을 받을 수 없습니다.

https://formulae.brew.sh/formula/webp

https://formulae.brew.sh/formula/cweb#default

검색 잘하시기 바랍니다. 두번째 링크를 실수로 설치했었습니다. 대학교 교수님이 올린 거 같습니다.

https://developers.google.com/speed/webp/download?hl=ko

위 링크에서도 설치할 수 있지만 zip파일을 줍니다. ㅂㄷㅂㄷ...

https://developers.google.com/speed/webp/docs/precompiled?hl=ko

위 링크로 가야 올바른 homebrew 주소를 알려줍니다.

```sh
cwebp -version
```

설치여부를 확인하게 버전확인 명령을 해봅시다. 나오면 성공입니다.

```sh
cwebp images/flower.jpg -o images/flower.webp
```

### img 태그 함정

```tsx
// ... 생략
import { PictureContainer } from './Landing.style';
import flashCardJPG from '/pexels-pixabay-268351_1920.jpg';
import flashCardWEBP from '/pexels-pixabay-268351_1920.webp';

function Landing() {
  // ... 생략
  return (
    <div>
      {/* ... 생략 */}
      <PictureContainer>
        <source
          type="image/webp"
          media="all and (min-width: 1320px)"
          src={flashCardWEBP}
          srcSet={flashCardWEBP}
        />
        <source
          type="image/jpeg"
          media="all and (min-width: 1320px)"
          src={flashCardJPG}
          srcSet={flashCardJPG}
        />
        <img srcSet={flashCardJPG} alt="flash card picture" loading="lazy" />
      </PictureContainer>
    </div>
  );
}

export default Landing;
```

이렇게 작성하고 개발자 도구를 확인해보면 img 태그만 나오는 것을 확인할 수 있습니다.

하지만 우클릭하고 다운로드를 시도하면 webp로 받아집니다.

저는 이런 함정에 속아서 디버깅 시도를 계속하고 있었습니다. ㅂㄷㅂㄷ...

https://egghead.io/lessons/react-handle-next-gen-image-formats-in-react-with-the-picture-element

### filter으로 밝기 조절

```css
img {
  filter: brightness(50%);
}
```

https://stackoverflow.com/questions/15765550/darkening-an-image-with-css-in-any-shape

## 엘릭서

- [자료형](https://elixir-lang.org/getting-started/basic-types.html)

https://elixir-lang.org/getting-started/case-cond-and-if.html

위까지 달성했습니다. 생각보다 흥미롭고 함정이 많아보이는 언어입니다.

## 23.06.27.

## Protected Route

사실 중요하고 교육과정에서 또 안 배운 내용입니다. 야성으로 알아내야죠 뭐

Protected Route라고 하면 인증 안된 유저가 특정 페이지를 접근하면 접근을 막고 리다이렉팅하는 것을 생각합니다.

### 문제: data router에 맞는 protected route 전략

nav는 물론이고 다른 라우팅에 대해서 리소스 접근 제한을 걸어두려고 했습니다.

다시 보면 지금도 결국에는 최선의 방법을 선택한 것입니다.

### 시도

#### 시도: 검색

일단 공식 문서에서 설정하는 것이 있나 검색을 시도했습니다. 의외로 없고 아티클과 stack overflow 게시글이 있었습니다.

https://dev.to/collins87mbathi/reactjs-protected-route-m3j

https://stackoverflow.com/questions/66289122/how-to-create-a-protected-route-with-react-router-dom

좋아요가 꽤 많이 달렸습니다.

#### 시도: github 참고 자료

https://github.com/wanted-frontedend-team5/pre-onboarding-10th-1-5/blob/main/src/router/Router.jsx

저보다 더 뛰어난 개발자들이 해결한 방식도 있습니다.

```jsx
const router = createBrowserRouter([
  {
    path: '/',
    element: <Navigate to="/signin" />,
    errorElement: <NotFound />,
  },
  {
    path: '/signin',
    element: <SignIn />,
    loader: () => {
      if (getUserTokenInLocalStorage()) {
        throw redirect('/todo');
      }
      return null;
    },
  },
  {
    path: '/signup',
    element: <SignUp />,
    loader: () => {
      if (getUserTokenInLocalStorage()) {
        throw redirect('/todo');
      }
      return null;
    },
  },
  {
    path: '/todo',
    element: (
      <ProtectedRoute>
        <Todo />
      </ProtectedRoute>
    ),
  },
]);
```

흥미로운 전략입니다. 로그인 상태가 되었고 다른 라우트 접근 시도를 하면 다시 리다이렉팅을 시켜줍니다.

또 인가가 나있는 상태에서는 todo를 접근할 수 있게 됩니다.

로그인 했을 때와 로그아웃했을 때 접근 가능한 리소스가 다릅니다.

또 공식 문서를 확인해보니까 라우팅을 했을 때 해당하는 데이터에 요청을 보내도록 하는 것이었습니다.

https://reactrouter.com/en/main/route/loader

아마 라우팅을 하고 화면에 로딩 스피너가 보이는 문제를 해결하려고 했습니다. 원래 서버사이드 라우팅은 데이터를 모두 갖고 클라이언트에게 보여주지만 클라이언트 사이드 라우팅이기 때문에 마운트 시점에 요청을 보내는 것이 유저 경험에 안 좋다고 보고 해결하려는 것처럼 보입니다.

이런을 보고 request waterfall이라고 부릅니다.

ProtectedRoute는 예민한 데이터 렌더링 자체를 차단합니다. 민감한 정보는 로그인 페이지로 리다이렉팅합니다.

#### 시도: 튜토리얼

[The New Way To Create Protected Routes With React Router V6](https://www.youtube.com/watch?v=2k8NleFjG7I)

[Creating Protected Routes With React Router V6](https://medium.com/@dennisivy/creating-protected-routes-with-react-router-v6-2c4bbaf7bc1c)

미디엄 아티클 중에서 자바스크립트 하이라이트가 안 되어 있어서 인도사람이라고 생각하고 있었는데 아니었습니다.

#### 시도

[React Router 6 – Full Course](https://youtu.be/nDGA3km5He4?t=21263)

사실 신뢰할 수 있는 튜토리얼 강사입니다. 하지만 `loader`에 리다이렉팅한다는 것이 충격입니다.

그리고 loader는 라우딩 전에 실행하는 것으로 추측됩니다. 브라우저에 history stack이 안 쌓입니다.

```tsx
// ... 생략
const routes = createBrowserRouter([
  {
    path: ROUTE_PATHS.WELCOME,
    element: <Layout />,
    children: [
      {
        element: <ProtectedRoute />,
        children: [
          {
            index: true,
            element: <Landing />,
          },
          {
            path: ROUTE_PATHS.SIGN_IN,
            element: <SignIn />,
          },
          {
            path: ROUTE_PATHS.SIGN_UP,
            element: <SignUp />,
          },
          {
            path: ROUTE_PATHS.CARDS,
            element: <Cards />,
          },
          {
            path: ROUTE_PATHS.DECK,
            element: <Deck />,
          },
          {
            path: ROUTE_PATHS.SETTING,
            element: <Setting />,
          },
        ],
      },
    ],
    errorElement: <NotFound />,
  },
]);

function Router() {
  return <RouterProvider router={routes} />;
}

export default Router;
```

위처럼 작성해도 동작하지 않습니다.

```tsx
function Router() {
  return (
    <ProtectedRoute>
      <RouterProvider router={routes} />
    </ProtectedRoute>
  );
}
```

이렇게 되면 route context 밖에 존재 해야 합니다.

더러운 해결책은 있지만 올리면 혼낼 것입니다. 물론 동작합니다.

```tsx
import { ROUTE_PATHS } from '@/constant/config';
import { useLogin } from '@/hooks';
import { Navigate, Outlet } from 'react-router-dom';

export function ProtectedRoute() {
  const { isLoggedIn } = useLogin();
  return isLoggedIn ? <Outlet /> : <Navigate to={ROUTE_PATHS.SIGN_IN} />;
}
```

이 `ProtectedRoute` 컴포넌트를 갖고 한땀한땀 감싸는 방법이 있습니다.

```tsx
// ... 생략
const routes = createBrowserRouter([
  {
    path: ROUTE_PATHS.WELCOME,
    element: <Layout />,
    children: [
      {
        element: <ProtectedRoute />,
        children: [
          {
            index: true,
            element: (
              <ProtectedRoute>
                <Landing />
              </ProtectedRoute>
            ),
          },
          {
            path: ROUTE_PATHS.SIGN_IN,
            element: (
              <ProtectedRoute>
                <SignIn />
              </ProtectedRoute>
            ),
          },
          {
            path: ROUTE_PATHS.SIGN_UP,
            element: (
              <ProtectedRoute>
                <SignUp />
              </ProtectedRoute>
            ),
          },
          {
            path: ROUTE_PATHS.CARDS,
            element: (
              <ProtectedRoute>
                <Cards />
              </ProtectedRoute>
            ),
          },
          {
            path: ROUTE_PATHS.DECK,
            element: (
              <ProtectedRoute>
                <Deck />
              </ProtectedRoute>
            ),
          },
          {
            path: ROUTE_PATHS.SETTING,
            element: (
              <ProtectedRoute>
                <Setting />
              </ProtectedRoute>
            ),
          },
        ],
      },
    ],
    errorElement: <NotFound />,
  },
]);
```

이렇게 하면 동작합니다. 그리고 제가 만들고 있는 서비스는 라우팅 로직이 복잡하게 성장할 가능성이 없어서 여기서 끝내도 충분합니다.

하지만 제가 면접관이면 언더 엔니이어링을 더 싫어할 것입니다. 그리고 강성적으로 DRY와 조기 최적화를 외칠 것이기 때문에 코드가 드러워서 탈락시켰다고 피드백을 줄 것입니다.

data router 스타일에 loader 유틸함수를 만들면 해결할 수 있습니다. data router 스타일에 맞는 올바른 protected route 패턴이 아직 없습니다.

### 해결

해결자체는 했지만 이 해결책도 결국에는 안티패턴입니다. loader는 데이터 로딩을 위해 처리해줘야 하는데 취지에 어긋나고 리소스 접근 제한에 활용했기 때문입니다.

다른 접근 방법은 4시간 안에 못 찾았습니다. ~~react-router-dom이 remix 팀에 인수되고 다들 근면 성실해졌습니다.~~ data route 패턴에
올바른 protected route 패턴은 검색해도 잘 안 나옵니다.

```ts title="/utils/queryLogin.ts"
import { redirect } from 'react-router-dom';
import { checkLogin } from '..';
import { ROUTE_PATHS } from '@/constant/config';

export function queryLogin(direct: 'signin' | 'cards') {
  if (direct === 'signin' && !checkLogin()) throw redirect(ROUTE_PATHS.SIGN_IN);
  if (direct === 'cards' && checkLogin()) throw redirect(ROUTE_PATHS.CARDS);
}
```

이 부분은 리다이렉팅 로직을 처리합니다. 확인을 하고 리다이렉팅 처리를 합니다. 참고로 `throw`는 react-router-dom이 권장하고 있는 패턴이라고 합니다. 그리고 진짜 적용해야 리다이렉팅이 동작합니다.

이 함수는 route 컴포넌트에 호출하고 loader에서 사용합니다.

```ts title="route/route.tsx"
const routes = createBrowserRouter([
  {
    path: ROUTE_PATHS.WELCOME,
    element: <Layout />,
    children: [
      // ... 생략
      {
        path: ROUTE_PATHS.SIGN_IN,
        element: <SignIn />,
        loader: () => {
          queryLogin('cards');
          return null;
        },
      },
      // ... 생략
      {
        path: ROUTE_PATHS.CARDS,
        element: <Cards />,
        loader: () => {
          queryLogin('signin');
          return null;
        },
      },
      // ... 생략
    ],
    errorElement: <NotFound />,
  },
]);

function Router() {
  return <RouterProvider router={routes} />;
}

export default Router;
```

이렇게 구현하면 동작합니다. `loader`에서 호출할 때 예외처리(`catch`) 동작방식이 내부적으로 연괸되어 있을 것 같습니다.

이제 레다이렉팅할 조건을 살펴보면 됩니다.

```ts title="util/checkLogin.ts"
import { STORAGE_KEY } from '@/constant/config';

export function checkLogin() {
  return Boolean(
    localStorage.getItem(STORAGE_KEY.ACCESS_TOKEN) &&
      sessionStorage.getItem(STORAGE_KEY.SESSION_TOKEN)
  );
}
```

2개의 token을 확인하고 로그인 상태를 검증합니다. 이것은 useLogin hook에서도 유용한 로직이 됩니다.

#### 부록

이렇게 해결하면 단점이 보일 것입니다. `nav` 리랜더링과 갱신 문제입니다. `<Layout/>` 컴포넌트에서는 atom을 구독하고 atom은 storage를 구독하는 방식으로 동작하면 nav는 로그인 상태를 구독하고 리랜더링을 반영하게 됩니다.

```ts
import { STORAGE_KEY } from '@/constant/config';
import { checkLogin } from '@/utils';
import { atom, useAtom } from 'jotai';
import { useCallback } from 'react';

const loginAtom = atom(checkLogin());

export function useLogin() {
  const [isLoggedIn, setIsLoggedIn] = useAtom(loginAtom);

  const setTokens = useCallback(
    (accessToken: string, sessionToken: string) => {
      localStorage.setItem(STORAGE_KEY.ACCESS_TOKEN, accessToken);
      sessionStorage.setItem(STORAGE_KEY.SESSION_TOKEN, sessionToken);
      setIsLoggedIn(checkLogin());
    },
    [setIsLoggedIn]
  );

  const emptyTokens = useCallback(() => {
    localStorage.removeItem(STORAGE_KEY.ACCESS_TOKEN);
    sessionStorage.removeItem(STORAGE_KEY.SESSION_TOKEN);
    setIsLoggedIn(checkLogin());
  }, [setIsLoggedIn]);

  return {
    isLoggedIn,
    setTokens,
    emptyTokens,
  };
}
```

atom은 storage와 수동으로 구독하게 만들었습니다. 좋은 패턴은 이렇게 보면 당연히 안 좋습니다. 로직의 규모가 작아서 큰 문제는 없습니다.

참고로 새로고침해도 storage를 구독하기 때문에 계속 로그인 상태를 유지할 수 있습니다.

`atomStorage`는 사용해보면서 큰따옴표 문제가 너무 많아서 아쉬웠습니다.

### 학습

`ProtectedRoute`이라고 부르는 것이 컨벤션입니다.

data router와 page router 모두 각각 다릅니다. 하지만 중요한 패턴입니다. 그리고 공식적으로 제공하는 api는 아닙니다.

- auth같은 token 제어는 Jotai와 무관하게 제어하는 것이 적절합니다.
  - Jotai storage는 해결하는 문제보다 만드는 문제가 더 많습니다.
    - 큰따옴표로 감싸지는 이슈가 다른 곳에서 storage를 확인하는데 문법이 더러워집니다.
    - hook으로 호출한다는 것이 치명적인 단점입니다. 다른 util 함수가 서로 호출하고 재사용하는데 hook으로 `jsx` 혹은 객체가 아닌 것을 `return`할 때 문제가 됩니다.

## 에러 로그

> Uncaught RangeError: Value need to be finite number for Intl.RelativeTimeFormat.prototype.format()

나중에 해결하겠습니다.

## 오늘 엘릭서

https://elixir-lang.org/getting-started/enumerables-and-streams.html

## 23.06.28.

## 팩토리 함수를 리팩토링

https://stackoverflow.com/questions/13315131/enforcing-the-type-of-the-indexed-members-of-a-typescript-object

```ts title="route/route.tsx"
const routes = createBrowserRouter([
  {
    path: ROUTE_PATHS.WELCOME,
    element: <Layout />,
    children: [
      // ... 생략
      {
        path: ROUTE_PATHS.SIGN_IN,
        element: <SignIn />,
        loader: () => {
          queryLogin('cards');
          return null;
        },
      },
      // ... 생략
      {
        path: ROUTE_PATHS.CARDS,
        element: <Cards />,
        loader: () => {
          queryLogin('signin');
          return null;
        },
      },
      // ... 생략
    ],
    errorElement: <NotFound />,
  },
]);

function Router() {
  return <RouterProvider router={routes} />;
}

export default Router;
```

어제 작성한 이 코드에 중복은 은근히 있습니다. 조기 추상화도 경계할 필요가 있다고 하는 사람도 있습니다. 실력없는 사람이 이런 말 하는 것입니다. 뭐 개인적으로는 전자에 동의하지만 면접과 회사는 무조건 후자입니다.

```ts
import { redirect } from 'react-router-dom';
import { checkLogin } from '..';
import { ROUTE_PATHS } from '@/constant/config';

export function protectRoutes(direct: 'signin' | 'cards') {
  return () => {
    switch (direct) {
      case 'cards':
        if (checkLogin()) throw redirect(ROUTE_PATHS.CARDS);
        break;
      case 'signin':
        if (!checkLogin()) throw redirect(ROUTE_PATHS.SIGN_IN);
        break;
      default:
        break;
    }

    return null;
  };
}
```

일단 이렇게 작성하면 호출하는 사람은 인증이 안 되어 있으면 어디로 보낼지 내부적으로 처리했습니다.

```ts title="route/route.tsx"
const routes = createBrowserRouter([
  {
    path: ROUTE_PATHS.WELCOME,
    element: <Layout />,
    children: [
      // ... 생략
      {
        path: ROUTE_PATHS.SIGN_IN,
        element: <SignIn />,
        loader: protectRoutes('cards'),
      },
      // ... 생략
      {
        path: ROUTE_PATHS.CARDS,
        element: <Cards />,
        loader: protectRoutes('signin'),
      },
      // ... 생략
    ],
    errorElement: <NotFound />,
  },
]);

function Router() {
  return <RouterProvider router={routes} />;
}

export default Router;
```

이렇게 되면 이제 내부 구현을 몰라도 됩니다. 그냥 리소스 접근 전에 내부적으로 처리한다는 것만 압니다.

```ts
import { redirect } from 'react-router-dom';
import { checkLogin } from '..';
import { ROUTE_PATHS } from '@/constant/config';

export function protectRoutes(direct: 'signin' | 'cards') {
  return () => {
    switch (direct) {
      case 'cards':
        if (checkLogin()) throw redirect(ROUTE_PATHS.CARDS);
        break;
      case 'signin':
        if (!checkLogin()) throw redirect(ROUTE_PATHS.SIGN_IN);
        break;
      default:
        break;
    }

    return null;
  };
}
```

일단은 이렇게 코드를 작성하고 끝낼 수 있지만 여전히 아쉽습니다. 먼저 switch case는 대부분의 경우 차선책입니다.

이렇게 작성하면 다형성을 못 갖습니다. 다형성을 확보하기 위해 switch case는 팩토리함수에 있고 프로덕트 함수는 switch case의 case 별로 반환하개 만들면 됩니다.

```ts
import { redirect } from 'react-router-dom';
import { checkLogin } from '..';
import { ROUTE_PATHS } from '@/constant/config';

export function protectRoutes(direction: 'signin' | 'cards') {
  switch (direction) {
    case 'cards':
      return () => {
        if (checkLogin()) throw redirect(ROUTE_PATHS.CARDS);
        return null;
      };
    case 'signin':
      return () => {
        if (!checkLogin()) throw redirect(ROUTE_PATHS.SIGN_IN);
        return null;
      };
    default:
      return () => {
        return null;
      };
  }
}
```

이렇게 되면 다형성을 확보할 수 있습니다. `direction`의 type에 따라 case를 확장할 수 있습니다.

생산적인 엔지니어면 이정도로 충분합니다. PM의 요구사항으로 만들어지는 경우의 수는 선형시간복잡성이어도 아쉬울 것이 전혀 없습니다. 하지만 성능 강박증을 행복하게 만들어주려면 switch case 문을 제거해야 합니다.

첫째로 읽고 쓰기는 없으면 객체로 리팩토링이 가능합니다. 객체로 만들고 객체의 메서드를 접근하게 만들어서 상수시간 복잡성을 얻을 수 있습니다. 물론 지금 `switch case`는 2개 밖에 없습니다.

```ts
import { redirect } from 'react-router-dom';
import { checkLogin } from '..';
import { ROUTE_PATHS } from '@/constant/config';

type Direction = 'signin' | 'cards';

const DirectionMap: { [key in Direction]: () => null } = {
  cards: () => {
    if (checkLogin()) throw redirect(ROUTE_PATHS.CARDS);
    return null;
  },
  signin: () => {
    if (!checkLogin()) throw redirect(ROUTE_PATHS.SIGN_IN);
    return null;
  },
} as const;

export function protectRoutes(direction: Direction) {
  return DirectionMap[direction];
}
```

성능 성능강박증 환자도 행복하게 만들어 줄 수 있는 읽기 전용객체의 메서드를 반환하도록 만들었습니다.

하지만 또 문제가 있다고 합니다. 클래스 변태는 객체 리터럴을 보면 불편하다고 합니다. ㅂㄷㅂㄷ...

일단 여기서 큰 교훈이 하나 있다면 `key in type`이 큽니다. `Direction`처럼 선언한 타입 대응이 가능합니다.

## useOutSideClick

원래 있는 줄 몰랐던 hook입니다. 포트폴리오 프로젝트를 진행할 때 동료가 custom hook을 추가했었습니다.

https://github.com/react-challengers/Codefolio/blob/dev/hooks/query/useOutsideClick.ts

포트폴리오를 보니까 누군가가 custom hook을 폴더에서 대충 만들었습니다.

```ts
import { useEffect, RefObject } from 'react';

const useOutsideClick = <T extends HTMLElement>(
  ref: RefObject<T>,
  callback: () => void
) => {
  const handleClick = (e: PointerEvent) => {
    if (ref.current && !ref.current.contains(e.target as Node)) {
      callback();
    }
  };

  useEffect(() => {
    window.addEventListener('pointerdown', handleClick);
    return () => window.removeEventListener('pointerdown', handleClick);
  }, [ref]);
};

export default useOutsideClick;
```

위가 코드 정의입니다. 다음은 코드를 소비하는 측면입니다. 어떻게 소비해야 하는지 제가 까먹었습니다.

https://github.com/react-challengers/Codefolio/blob/dev/Components/Main/MainSection.tsx

```tsx
function Component() {
  const [isDropDownOpen, setIsDropDownOpen] = useState(false);
  const homeDropDownRef = useRef<HTMLUListElement>(null);

  useOutsideClick(homeDropDownRef, () => setIsDropDownOpen(false));

  return (
    <HomeDropDownList ref={homeDropDownRef}>
      {homeDropDownItems.map((item) => (
        <DropDown
          item={item}
          key={item}
          onClickHandler={onClickDropDownHandler}
        />
      ))}
    </HomeDropDownList>
  );
}
```

이렇게 사용하면 됩니다.

코드를 읽어보면 아쉬운 점이 상당히 많습니다. hook의 소비자 관점에서 제어하기 상당히 안 좋습니다. 일단은 구현하고 리팩토링하는 방향으로 처리하면 될 것 같습니다.

그리고 custom hook을 그래로 복붙하지 말고 컴포넌트 내부에 구현하고 추출하는 전략이 더 좋아보입니다.

### chakra-ui 참고

위 예시는 pointer down을 사용했습니다. 그래서 적용이 안됬습니다.

https://github.com/chakra-ui/chakra-ui/blob/main/packages/hooks/use-outside-click/src/index.ts

chakra-ui는 `mousedown`을 활용했습니다.

그리고 원본도 `mousedown`을 사용하고 있었습니다.

```tsx
import { useEffect } from 'react';

const useOutsideClick = (ref: any, callback: any) => {
  const handleClick = (e: Event) => {
    if (ref.current && !ref.current.contains(e.target)) {
      callback();
    }
  };

  useEffect(() => {
    window.addEventListener('mousedown', handleClick);
    return () => window.removeEventListener('mousedown', handleClick);
  }, [ref, callback]);
};

export default useOutsideClick;
```

any script를 만들고 있지만 처음 만들었을 때가 올바른 방법입니다.

```tsx
export function DropdownMenu({
  menuItem,
  direction = 'left',
}: DropdownMenuProps) {
  const [isOpen, setIsOpen] = useState(false);

  const toggleMenu = () => {
    setIsOpen((prev) => !prev);
  };

  const toggleClose = () => {
    setIsOpen(false);
  };

  const { customRef } = useOusSideClick<HTMLDivElement>(toggleClose);

  return (
    <DropdownMenuContainer ref={customRef}>
      <DropdownOpen type="button" onClick={toggleMenu} isOpen={isOpen}>
        <Icon />
      </DropdownOpen>
      {isOpen && <Menu menuItem={menuItem} direction={direction} />}
    </DropdownMenuContainer>
  );
}

function useOusSideClick<T extends HTMLElement>(handlerCallback: () => void) {
  const customRef = useRef<T>(null);

  const handleClick = useCallback(
    (e: MouseEvent) => {
      if (customRef.current?.contains(e.target as Node) === false) {
        handlerCallback();
      }
    },
    [handlerCallback]
  );

  useEffect(() => {
    window.addEventListener('mousedown', handleClick);
    return () => {
      window.removeEventListener('mousedown', handleClick);
    };
  }, [handleClick]);

  return { customRef };
}
```

일단 구현하고 추출까지 성공했습니다. 그리고 호출하는 사람이 타입을 정의하도록 제네릭도 추가했습니다. 이제 발톱때만큼 사람 흉내를 내기 시작했습니다.

하지만 아쉬운 부분이 있습니다. 먼저 이 hook을 handler 함수 아래에 위치 시켜야 한다는 점이 치명적인 단점으로 보입니다. ref에 대한 호출은 custom hook 내에서 처리하기 때문에 올바른 방법이라는 것은 확신할 수 있었습니다.

결정을 못내리겠는 것은 이 useState를 컴포넌트에 유지할 것인가? 아니면 custom hook에 넣어야 하는 것인가? 이것에 대한 결정을 못내리고 있습니다.

custom hook 추출 리팩토링을 했는데 여전히 부족한 hook입니다. custom hook은 handler 함수를 인자로 받아야 하고 받기 위해서는 handler 영역 아래 호출할 수밖에 없는 이 구조는 코드 스펠의 원인이 됩니다. 즉 여전히 리팩토링 대상입니다.

다른 곳에 또 적용한다고 하면 select dropdown, modal이 될 것입니다. 모두 외부 클릭을 하거나 닫기 같은 버튼을 클릭할 때 숨겨져야 합니다.

접근하는 방법은 2가지가 있습니다. 하나는 setState 함수를 인자로 받을 수 있으면 handler 영역보다 먼저 정의할 수 있게 됩니다. 다른 하나는 useState를 custom hook 내부에서 제어하는 것입니다. 그리고 열기, 닫기, 받대로 3가지 함수를 유출하는 것으로 제어하는 후자의 방향으로 생각하고 있습니다. 또 올바르다는 점이 상태공유가 특별히 더 필요하지 않습니다. UI 로직을 그것도 local하게 처리해야 하기 때문에 적절할 것 같습니다.

또 열고 닫을 때 isOpen의 값을 참조해야 합니다. provider 혹은 고차 컴포넌트 방식으로 숨기기기 위해 활용하는 것도 좋을 것 같습니다. 물론 css를 오염시켬 다시 문제가 될 것입니다.

일단 modal 구현하기 전에는 현재 시점을 저장해두는 것이 좋을 것 같습니다.

## button hierarchy

> 최초 구축보다 어려운 작업은 수정하는 작업입니다.
>
> \- 누군가?

누군가를 인용하는 문장같습니다. 저도 누구인지 모르지만 아마 인용했을 것입니다. 알려주시면 감사히 수정하겠습니다.

이 작업이 어려운 이유는 난장판으로 끝냈기 때문입니다.

예전에 생각한 전략이 맞았습니다. 스타일에 대한 책임은 `div`가 갖고 SEO, 접근성에 대한 책임은 `a`와 `button` 태그가 갖는 구조가 맞았습니다.

### `:focus-visible` & `:active`

```tsx
import styled from '@emotion/styled';
import { Link } from 'react-router-dom';

type NewButtonWrapperProps = {
  width?: number | 'grow';
  disabled?: boolean;
  hierarchy: 'primary' | 'secondary';
  isLoading: boolean;
};

export const NewButtonWrapper = styled.div<NewButtonWrapperProps>`
  background-color: ${(props) =>
    props.disabled && !props.isLoading
      ? props.theme.colors.gray400
      : props.theme.colors.green500};
  border-radius: 0.5rem;
  height: 2.75rem;
  min-width: 5.25rem;

  position: relative;

  display: flex;
  justify-content: center;
  align-items: center;

  width: ${(props) => {
    // 숫자 입력시 숫자만큼 채우기
    if (!props.width) return 'fit-content';
    if (props.width !== 'grow') return (props.width / 16).toString() + 'rem';
    return 'fit-content';
  }};

  ${(props) => props.width === 'grow' && 'flex: 1 1 0px;'}

  button,
  a {
    all: unset;
    width: 100%;
    height: 100%;
    border-radius: 0.5rem;
    ${(props) => props.theme.fonts.body16Regular}
    ${(props) => !props.disabled && 'cursor: pointer;'}
    display: flex;
    justify-content: center;
    align-items: center;
    :focus-visible {
      box-shadow: 0 0 0 0.25rem ${(props) => props.theme.colors.green200} inset;
    }
    :active {
      box-shadow: 0 0 0 0.25rem ${(props) => props.theme.colors.green200} inset;
    }
  }
`;

export const NewButtonLink = styled(Link)``;

export const NewButtonButton = styled.button``;
```

스타일링은 이렇게 접근하는 전략이 있었습니다. 하위 태그에 알아서 스타일을 적용하는 방법이 있습니다.

여기서 중요한 부분들이 있습니다. `a`, `button`은 `width`, `height`는 `100%`가 되어여 합니다.

또 `a`, `button`을 사용하면 tab index가 중요합니다. 이전까지 tab index는 `:focus`로 만 제어해야 하는 줄 알았습니다. 하지만 `:active`랑 겹치는 단점이 치명적이었습니다.

[Enable :focus only on keyboard use (or tab press) - stack overflow](https://stackoverflow.com/questions/31402576/enable-focus-only-on-keyboard-use-or-tab-press)

하지만 `:focus-visible`를 사용하면 tab으로 인한 focus만 따로 스타일링하고 클릭은 `:active`가 전담할 수 있게 됩니다.

마크업은 더 간단해졌습니다.

```tsx
export function NewButton({
  children,
  onClick,
  isLoading = false,
  href,
  width,
  hierarchy = 'primary',
}: ButtonProps) {
  return (
    <NewButtonWrapper
      width={width}
      disabled={isLoading}
      hierarchy={hierarchy}
      isLoading={isLoading}
    >
      {href && (
        <NewButtonLink to={href}>
          <TextWrapper isLoading={isLoading}>{children}</TextWrapper>
        </NewButtonLink>
      )}
      {onClick && (
        <NewButtonButton onClick={onClick}>
          <TextWrapper isLoading={isLoading}>{children}</TextWrapper>
        </NewButtonButton>
      )}
      {isLoading && (
        <LoaderWrapper>
          <PulseLoader
            color="#ffffff"
            loading
            margin={4}
            size={12}
            speedMultiplier={0.5}
          />
        </LoaderWrapper>
      )}
    </NewButtonWrapper>
  );
}
```

3가지 조건부 랜더링으로 처리하면 됩니다.

### react-router-dom의 `<Link/>` 비활성화

https://stackoverflow.com/questions/35963070/react-router-how-to-disable-a-link-if-its-active

2가지 전략이 있습니다.

```tsx
<NewButtonLink to={disabled ? '#' : href}>
  <TextWrapper isLoading={isLoading}>{children}</TextWrapper>
</NewButtonLink>
```

이 전략은 단점은 link를 마크업에서 보여주지 않는 단점이 있습니다. 수동 크롤러가 감지를 못할 가능성이 크다는 단점이 있습니다.

하지만 동작과 관련된 것이기 때문에 관심사는 적절합니다.

```css
.disabled-link {
  pointer-events: none;
}
```

이렇게 하면 적용이 됩니다. SEO는 링크를 알 수 있고 비활성화 동작도 하게 될 것입니다.

### 조건부 props와 tabindex

```tsx
export function NewButton({
  children,
  onClick,
  isLoading = false,
  href,
  width,
  hierarchy = 'primary',
  disabled,
}: ButtonProps) {
  return (
    <NewButtonWrapper
      width={width}
      disabled={disabled}
      hierarchy={hierarchy}
      isLoading={isLoading}
    >
      {href && (
        <NewButtonLink to={href} {...(disabled && { tabIndex: -1 })}>
          <TextWrapper isLoading={isLoading} hierarchy={hierarchy}>
            {children}
          </TextWrapper>
        </NewButtonLink>
      )}
      {onClick && (
        <NewButtonButton
          onClick={onClick}
          disabled={disabled}
          {...(disabled && { tabIndex: -1 })}
        >
          <TextWrapper isLoading={isLoading} hierarchy={hierarchy}>
            {children}
          </TextWrapper>
        </NewButtonButton>
      )}
      {isLoading && (
        <LoaderWrapper>
          <PulseLoader
            color="#ffffff"
            loading
            margin={4}
            size={12}
            speedMultiplier={0.5}
          />
        </LoaderWrapper>
      )}
    </NewButtonWrapper>
  );
}
```

예전에 적용했던 조건부 props를 사용했습니다. 예상과 다르게 개인 블로그에 정리한적이 없었습니다.

이렇게 되면 tab으로 접근할 수 있는 가능성이 사라집니다. tab으로 접근을 못하기 때문에 disabled에 대한 스타일링 고려사항은 가벼워집니다.

https://www.daleseo.com/html-tabindex/

### 내일 할일

`:disabled` 적용 시도해봐야 합니다.

props로 `:disabled`를 추가하고 공유하게 만드는 전략도 있습니다.

그리고 color props를 추가해야 합니다. 지정 안하면 `default`로 `green`으로 지정되도록 해야 합니다.

## 23.06.29.

## docusaurus blog 및 doc 추가

tab을 추가하고 싶었는데 multi instance라는 것이 올바른 용어입니다.

https://docusaurus.io/docs/blog#advanced-topics

https://docusaurus.io/docs/docs-multi-instance

## button 리팩토링

혹시 몰라서 tabindex의 접근성 문제를 한번더 확인하고자 했습니다.

[HTML의 tabindex 속성과 키보드 포커스](https://www.daleseo.com/html-tabindex/)

위 아티클은 접근성 문제를 알려주지 않습니다. tabindex 기능만 알려줍니다.

[tabindex로 포커스 제어 - web.dev](https://web.dev/i18n/ko/control-focus-with-tabindex/)

`tabindex="-1"`이 접근성 문제를 발생시키고 SEO에 불리해진다는 내용이 없습니다.

그래서 일단 적용을 유지하겠습니다.

```tsx
import styled from '@emotion/styled';
import { Link } from 'react-router-dom';

type HierarchyType = 'primary' | 'secondary' | 'ghost';
type ColorType = 'green' | 'red' | 'neutral';

type ButtonWrapperProps = {
  width?: number | 'grow';
  disabled?: boolean;
  hierarchy: HierarchyType;
  isLoading: boolean;
  color: ColorType;
};

export const ButtonWrapper = styled.div<ButtonWrapperProps>`
  border-radius: 0.5rem;
  height: 2.75rem;
  min-width: 5.25rem;

  position: relative;

  display: flex;
  justify-content: center;
  align-items: center;

  width: ${(props) => {
    // 숫자 입력시 숫자만큼 채우기
    if (!props.width) return 'fit-content';
    if (props.width !== 'grow') return (props.width / 16).toString() + 'rem';
    return 'fit-content';
  }};

  ${(props) => props.width === 'grow' && 'flex: 1 1 0px;'}

  button,
  a {
    all: unset;

    width: 100%;
    height: 100%;
    border-radius: 0.5rem;

    background-color: ${(props) => {
      if (props.hierarchy === 'secondary') {
        return props.theme.colors.white;
      }

      if (props.hierarchy === 'ghost') {
        return props.theme.colors.white;
      }

      if (props.disabled && !props.isLoading && props.hierarchy === 'primary')
        return props.theme.colors.gray400;

      if (props.disabled && !props.isLoading && props.hierarchy !== 'primary')
        return props.theme.colors.white;
      if (props.color === 'green') return props.theme.colors.green500;
      if (props.color === 'red') return props.theme.colors.red500;
      if (props.color === 'neutral') return props.theme.colors.gray700; // 컬러 미정
    }};

    box-shadow: 0 0 0 2px ${(props) => {
        if (props.hierarchy === 'secondary') {
          if (props.disabled) return props.theme.colors.gray400;
          else {
            if (props.color === 'green') return props.theme.colors.green500;
            if (props.color === 'red') return props.theme.colors.red500;
            if (props.color === 'neutral') return props.theme.colors.gray700; // 컬러 미정
          }
        } else {
          return 'none';
        }
      }} inset;

    ${(props) => props.theme.fonts.body16Regular}

    display: flex;
    justify-content: center;
    align-items: center;

    :focus-visible {
      box-shadow: 0 0 0 0.25rem ${(props) => {
          if (props.color === 'green') return props.theme.colors.green200;
          if (props.color === 'red') return props.theme.colors.red200;
          if (props.color === 'neutral') return props.theme.colors.gray400;
        }} inset;
    }

    :hover {
      background-color: ${(props) => {
        if (props.disabled) return props.theme.colors.gray400;
        if (props.hierarchy === 'primary') {
          if (props.color === 'green') return props.theme.colors.green400;
          if (props.color === 'red') return props.theme.colors.red400;
          if (props.color === 'neutral') return props.theme.colors.gray600;
        } else {
          if (props.color === 'green') return props.theme.colors.green050;
          if (props.color === 'red') return props.theme.colors.red050;
          if (props.color === 'neutral') return props.theme.colors.gray100;
        }
      }};
    }

    :active {
      background-color: ${(props) => {
        if (props.disabled) return props.theme.colors.gray400;
        if (props.hierarchy === 'primary') {
          if (props.color === 'green') return props.theme.colors.green600;
          if (props.color === 'red') return props.theme.colors.red600;
          if (props.color === 'neutral') return props.theme.colors.gray800;
        } else {
          if (props.color === 'green') return props.theme.colors.green100;
          if (props.color === 'red') return props.theme.colors.red100;
          if (props.color === 'neutral') return props.theme.colors.gray200; // 컬러 미정
        }
      }};
    }
  }
`;

type CustomLinkProps = Pick<ButtonWrapperProps, 'disabled'>;

export const CustomLink = styled(Link)<CustomLinkProps>`
  ${(props) => !props.disabled && 'cursor: pointer;'}
`;

export const CustomButton = styled.button``;

type TextWrapperProps = Omit<ButtonWrapperProps, 'width'>;

export const TextWrapper = styled.span<TextWrapperProps>`
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 100%;
  color: ${(props) => {
    if (props.isLoading) return 'transparent';
    if (props.disabled && props.hierarchy !== 'primary')
      return props.theme.colors.gray400;
    if (props.hierarchy === 'primary') return props.theme.colors.white;
    if (props.color === 'green') return props.theme.colors.green500;
    if (props.color === 'red') return props.theme.colors.red500;
    if (props.color === 'neutral') return props.theme.colors.gray700;
    return props.theme.colors.green500;
  }};
  margin: 0 1rem;
`;

export const LoaderWrapper = styled.div`
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  display: flex;
  align-items: center;
  justify-content: center;
`;
```

스타일링 최종 형태는 이렇게 됩니다.

여기서 아쉬운 부분은 스타일링을 위한 복잡한 조건문입니다. 다형성을 확보할 수 있어야 합니다. 중복이 상당히 많고 복잡합니다.

하지만 이미 요구사항이 복잡한데 기능추가 있기 전에 리팩토링하기에는 방향을 추정하기 어려워서 일단은 보류하겠습니다.

```tsx
import theme from '@/styles/theme';
import {
  LoaderWrapper,
  CustomButton,
  CustomLink,
  ButtonWrapper,
  TextWrapper,
} from './Button.style';
import { PulseLoader } from 'react-spinners';

type ButtonProps = React.ButtonHTMLAttributes<HTMLButtonElement> & {
  children: React.ReactNode;
  width?: number | 'grow';
  href?: string;
  onClick?: React.MouseEventHandler<HTMLButtonElement>;
  isLoading?: boolean;
  hierarchy?: 'primary' | 'secondary' | 'ghost';
  color?: 'green' | 'red' | 'neutral';
};

export function Button({
  children,
  onClick,
  isLoading = false,
  href,
  width,
  hierarchy = 'primary',
  disabled = false,
  color = 'green',
}: ButtonProps) {
  const handleColor = (color: 'green' | 'red' | 'neutral') => {
    if (hierarchy === 'primary') {
      return theme.colors.white;
    } else {
      if (color === 'green') return theme.colors.green500;
      if (color === 'red') return theme.colors.red500;
      if (color === 'neutral') return theme.colors.gray700;
    }
  };
  return (
    <ButtonWrapper
      width={width}
      disabled={disabled}
      hierarchy={hierarchy}
      isLoading={isLoading}
      color={color}
    >
      {href && (
        <CustomLink
          to={href}
          {...(disabled && { tabIndex: -1 })}
          disabled={disabled}
        >
          <TextWrapper
            isLoading={isLoading}
            hierarchy={hierarchy}
            disabled={disabled}
            color={color}
          >
            {children}
          </TextWrapper>
        </CustomLink>
      )}
      {onClick && (
        <CustomButton
          onClick={onClick}
          disabled={disabled || isLoading}
          {...(disabled && { tabIndex: -1 })}
        >
          <TextWrapper
            isLoading={isLoading}
            hierarchy={hierarchy}
            disabled={disabled}
            color={color}
          >
            {children}
          </TextWrapper>
        </CustomButton>
      )}
      {isLoading && (
        <LoaderWrapper>
          <PulseLoader
            color={handleColor(color)}
            loading
            margin={4}
            size={12}
            speedMultiplier={0.5}
          />
        </LoaderWrapper>
      )}
    </ButtonWrapper>
  );
}
```

마크업도 이렇게 구현됩니다.

## optimistic update 편집, 삭제

생성과 분리하는 이유가 있습니다. id로 원소를 구분하는데 생성 시점에 id가 없습니다. 서버가 붙이는 id와 클라이언트가 생성해서 붙이는 id 사이 불일치합니다.

생성에 대한 로직은 통신 결과가 성공하면 id를 교체하는 방식으로 해결을 시도할 수 있다는 가설이 생겼습니다.

optimistic update는 예전해 구현한 것은 맞지만 문법이 길어서 공식문서를 다시 봐야 합니다.

서버 상태 위주로 관리할 수 있는 상태관리라이브러리면 사실 이것이 간소하고 단순한 편입니다.

태생적으로 서버상태를 관리하려는 것이 아닌데 관리하려고 하면 오히려 문법이 복잡하고 실수하기 쉽고 코드의 결합도가 높아질 수 있습니다.

물론 optimistic update 패턴은 패턴이고 사용자의 체감 성능을 개선하는 것입니다. 진짜 성능개선이 아닌 사용자의 경험을 기만행위 비슷하게 구현하는 것입니다.

모든 패턴에 optimistic update를 적용하면 곤란합니다. auth, 결제는 적용하면 곤란합니다. 오히려 화면에 로더를 표시하고 통신과 동기적으로 처리하는 것이 더 적절합니다. 이런 부분은 보수적으로 접근해야 합니다. 하지만 유저의 댓글, 좋아요 같은 성격의 리소스에 적용해도 문제는 별로 없습니다.

오늘 발견한 것이 있습니다.

```tsx
function component() {
  const queryClient = useQueryClient();
  const { mutate: updateCard } = useMutation({
    mutationFn: updateCardsAPI,
    onMutate: async (cardItem) => {
      await queryClient.cancelQueries({ queryKey: ['cards'] });

      const previousCards: Card[] = queryClient.getQueryData(['cards']) ?? [];

      queryClient.setQueryData<Card[]>(['cards'], (oldCards) => {
        if (oldCards) {
          // 아래 새로운 메모리 주소에 할당하기 위해 새로운 배열을 만들고 복사합니다.
          return [...oldCards].map((card) =>
            card._id === cardItem.id
              ? { _id: cardItem.id, ...cardItem.card }
              : card
          );
        } else return [];
      });
      return { previousCards };
    },
    onError: (_err, _cardItem, context) => {
      if (context) queryClient.setQueryData(['cards'], context.previousCards);
    },
    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: ['cards'] });
    },
  });

  return <div>???</div>;
}
```

react-query의 optimistic update도 UI를 갱신하게 만들려면 참조를 바꿔야 합니다. 마치 setState를 갱신할 때 메모리 참조 비교하는 것과 동일합니다.

그래서 결국 배열을 복사할 수 밖에 없고 복사하는 시간복잡성을 갖을 수 밖에 없습니다.

객체 생성이 자바스크립트에 부담을 줘서 기존과 객체 주소를 동일하게 했었는데 그럴 필요는 없었습니다.

## 23.06.30.

## 분기 회고

- [ ] CS 지식 플래시카드로 정리하기
- [ ] 네이버 지식백과 전선학 개론 1회독
- [x] 유데미 자료구조 & 알고리즘 완강
- [x] 개발자 블로그 개발 완료하기

### Liked

- 유데미 자료구조 알고리즘 강의를 완강했습니다. 지난분기에 달성해야 할 작업을 이번 분기에 달성했습니다.
- 개발자 블로그를 보여줄 만하게 발전했습니다.
- 생활이 규칙적이게 되기 시작했습니다. 예비군을 다녀오고 일찍 일어나는 습관을 들이기 시작했습니다.

### Learned

- 기초의 방향을 바꿨습니다. 실제 코드를 작성하고 작성한 코드를 잘 정리하는 것을 기초의 방향을 바꿨습니다.
  - 회사마다 편차가 극단적으로 클 것이기 때문에 나중에 해도 괜찮고 이직할 때 다시 배워야 한다고 생각하고 있었습니다. 이 가설은 기각해야 합니다.
- 코드 퀄리티를 높이기 위한 제약을 두는 방법을 배웠습니다.

### Lacked

- 4월은 리팩토링을 읽기 시작했습니다. golang 컨프런스도 다녀왔습니다. 이력서도 어느정도 작성했지만 한참 부족한 이력서입니다.
- 5월은 중순에 지원을 중단했습니다. 보여줄 수 있는 실력이 너무 없었습니다.
- 6월은 프로젝트 전념하기로 하고 시간을 보냈습니다. 하지만 그렇게 해도 작업을 완료하지 못했습니다.

### Longed(잘하기 위해 필요한 것)

- 현재 플래시카드 포트폴리오를 완수해야 합니다. 실제 서비스처럼 남들에게 보여줄 수 있는 수준이 되어야 합니다.
  - 기능이 단순하기 때문에 코드 퀄리티가 높아야 합니다.
- 플래시카드 프로젝트 1.0.0-alpha를 배포하고 이력서 작성을 다시 해야 합니다.
- 이력서부터 대폭 수정해야 합니다.
  - 비즈니스 목적의 이유는 무엇이고 달성하려는 수단을 서술하는 방식으로 접근해야 합니다.
  - 기술적으로 특이한 문제를 해결한 경험도 서술해야 합니다.
- 실력이 없기 때문에 실력을 얻고 보여줘야 합니다.
- 규칙적인 생활을 시작하고 집중하고 작업하는 시간을 늘려야 합니다.
- 면접 준비를 더 잘하기 위해서 진행했던 프로젝트들에 대해서 잘 정리해야 합니다.
  - 모의 면접은 CS 지식 비중이 많습니다. 이력서 검토 시간이 짧으면 갖는 경향이라고 추정됩니다.
  - 이력서를 검토할 수 있는 시간이 길면 프로젝트 관련 질문 비중이 높아질 것이라고 추정됩니다.
- 아키텍쳐 능력을 길러야 합니다.
  - 코드리뷰는 코드의 상당히 미시적인 부분을 다룹니다.
  - 코드의 거시적인 검토능력을 길러야 합니다.
- 다시 코딩테스트를 공부해야 합니다. 이론으 잘 이해하는 것은 개인적으로는 중요하다고 생각하지만 회사는 문제를 맞추는 것을 더 중요시합니다.

### Action Item

- [ ] 이력서 재작성
  - 코드 스플릿팅
  - 절대 버튼?
  - 카드 컴포넌트 등...
- [ ] 포트폴리오 큐레이션 만들기
  - 지금까지한 프로젝트와 또 앞으로 하게 될 프로젝트를 정리하기
  - 물론 양보다 질로 접근해야 합니다.
  - 포트폴리오를 노션, 블로그, SSG 배포 페이지로 만들지는 맥락에 맞춰서 만들기
- [ ] 블로그 확장
  - 확장하면 고급자료 특이한 경험부터 정리하기 시작하기
    - 면접관에게 인사이트 혹은 기술적인 문제를 수월하게 풀수 있게 가치 제공해보기
- [ ] 플래시카드 앱 1.0.0-alpha 배포
  - 배포 후에 리팩토링
  - 백엔드 포팅
  - 프론트엔드 테스트 코드 추가

## 날짜 변환 디버깅

이 디버깅은 서버에 문자열 리소스를 생성해서 제출했기 때문에 발생했던 문제였습니다. 아직 데이터 규모가 작아서 데이터 스크러빙으로 해결했습니다.

여기서 얻을 수 있는 교훈 중 하나는 데이터 정제 작업도 중요합니다. 클라이언트가 정제된 데이터를 제공하는 것이 좋지만 유일하지 않습니다.

서버에서도 정제작업을 처리하고 데이터 엔지니어링 차원에서 백엔드 서버 데이터를 정제하고 파이프라인을 짜는 방식을 추구해야 할 것 같습니다.

## tiny png

[⭐️ The key to perfect lighthouse scores](https://www.youtube.com/shorts/9ZfCZroZwD4)
