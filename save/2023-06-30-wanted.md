---
title: '6월 원티드 챌린지'
authors: [arch-spatula]
tags: ['특강']
description: '????'
toc_max_heading_level: 6
_draft: true
date: 2023-06-30
---

# 6월 원티드 챌린지

주제는 스토리북과 함께하는 컴포넌트 주도 개발입니다.

<!--truncate-->

[스토리북과 함께하는 컴포넌트 주도 개발 - 6월 프론트엔드 챌린지](https://www.wanted.co.kr/events/pre_challenge_fe_10)

:::caution

예비군 일정이 겹쳤습니다. 그래서 3회차 강의가 없습니다.

또 첫강의도 놓쳤습니다. 첫 강의는 테크 트렌드 위주로 다룬 강의인데 저는 신입에게 트렌드는 독이라고 보는 입장입니다. ~~그리고 강의 PPT도 봤는데 그정 테크트렌드도 모르면 곤란합니다.~~

:::

## 원티드 특강

- 스토리북을 활용한 컴포넌트 주도 개발(CDD)을 탐구합니다.
- 실질적으로 코드 실질적은 예시도 보여줄 것입니다.
- 코드는 직접 작성하도록 합니다.
- 아토믹 디자인 패턴을 가끔 현업에서 나올 수 있습니다. 아토믹 디자인 패턴을 절대 오해하면 곤란합니다. 한계가 있습니다.
- 아토믹 디자인 패턴은 이론적으로 전달하기 좋습니다. 아토믹 디자인 패턴을 이해하기 전에 알아야 할 것이 있습니다. 바로 인터페이스입니다.
- 아토믹 디자인 패턴을 잘 모르는 사람은 거의 없습니다.

https://atomicdesign.bradfrost.com/

- 브래드 프로스트가 창시한 이론입니다. 원자, 분자, 유기체, 템플릿, 페이지로 조합하는 개념입니다. 이런 컴포넌트를 공유 자원으로 활용하면 아토믹 디자인 패턴입니다.
- 디자인 시스템 개발 방법론입니다.
- 하지만 더 중요한 것은 인터페이스입니다. [자동차 인터페이스 디자인](https://www.yes24.com/Product/Goods/109590932)에 인터페이스를 정의합니다.
- 개발에서 단어를 보면 일상에서 어떻게 사용하고 소프트웨어 공학에서 어떻게 추상화되어 있는지 탐구하도록 합니다.
- 문서도 하나의 인터페이스입니다.
- 아토믹 디자인은 원자와 분자를 구성하는 방법을 만드는 방법입니다.
- 원자는 가장 작은 단위입니다.
- 블로그, 회사마다 기준이 모두 다릅니다.
- 서로 같은 레벨과 기준을 정의하기 어렵습니다.
- 브래드 프로스트는 대략적인 원칙을 정의한 것 뿐입니다.
- 템플릿과 페이지는 설명이 비슷합니다.
- 조합하고 구분하는 기준은 없습니다. 각자 회사 프로젝트에 따라 다릅니다.

- 인터페이스는 가위바위보랑 비슷합니다. 사회적 관습상 상호작용(인터랙션)하고 승패를 정합니다. 신호등도 인터페이스의 예시입니다.
- 아토믹 디자인에서 UI 디자인에 대한 정의와 개발할 때 정의는 어떻게할지 정해야 합니다.

- 아토믹 디자인은 정답이 아닙니다. 학습용으로 좋은 이론입니다.
- 디자인과 개발은 다릅니다. 리액트 스럽게 개발하고 회사 도메인 컨텍스트를 고려하면서 방법론을 적용할 수 있는가? 아닙니다. 아토믹디자인은 사람이 생각하는 관점을 제공해준 점까지 유용합니다.
- 리액트 스로운 사고 방식을 학습해야 합니다. 리액트 공식 문서 읽도록 합니다.

https://react.dev/learn/thinking-in-react

- 아토믹 디자인 방법론으로 리액트로 개발을 하게 되면 리액트 컴포넌트를 만들기 때문에 결국 이미 아토믹 디자인 패턴을 도입하게 되는 것입니다.
- 회사가 추구하는 비즈니스 가치와 도메인을 고려해야 합니다.
- TPO를 고려해야 합니다. 회사에서 당연히 기본적으로 고려하는 비즈니스 스킬입니다. 업무의 가치라는 것은 맥락에 따라 달라기집니다.
- 도메인 컨텍스트는 회사마다 다릅니다. 고객이 겪고 있는 문제를 기준으로 설정하고 해결하기 위해 이해해야 하는 컨텍스트입니다.

- 상향식 컴포넌트 개발과 하향식 컴포넌트 개발 2가지입니다. CDD는 컴포넌트 주도 개발입니다.
- 하향식 컴포넌트 개발은 페이지를 먼저 개발하고 리팩토링하면서 쪼개고 작게 만드는 것입니다.
- 상향식 컴포넌트 개발은 아토믹 디자인 패턴을 적용한 경우입니다.
- 각각 장단점이 있습니다.
- 가장 작은 컴포넌트를 만들면 사용자는 개발자입니다. 작은 컴포넌트를 만들면 일반 사용자와 개발자도 고려해야 합니다.
- 하향식은 전체적으로 만들고 나중에 분리하는 방식으로 진행합니다. 하지만 르블랑의 법칙 문제가 있습니다. 나중에 하겠다고 미루면 절대 안 합니다.
  - 한번 작성한 쓰레기 코드는 나중에 수정하는 일은 결코 없습니다.
- 상향식 컴포넌트는 잘못하면 YAGNI 문제 빠지기 쉽습니다.

- 제어 컴포넌트와 비제어 컴포넌트는 중요한 개념입니다.
- 개발을 공부할 때 강조하는 것들입니다. 영어와 한자로 번역하고 이해합니다. 용어가 일상에서 어떻게 사용되는지 이해합니다.
- 제어 & 비제어, pull & push로 이해하면 이해가 쉬워집니다.

### 제어 컴포넌트 비제어 컴포넌트

- 제어컴포넌트는 push이고 SOT(단일진실원천)입니다. input에 value와 onChange를 활용합니다. 상당히 기본적인 내용입니다.
- 리액트 상태에 있고 html input value에 있습니다. 제어 컴포넌트는 push입니다. 데이터를 넣습니다. 값이 들어갑니다. DOM, 리액트, VDOM 모두 동기화됩니다.
- 비제어 컴포넌트는 Pull입니다. ref가 필요합니다. 제어에 관여하지 않기 때문에 상태를 가져오기만 합니다.
- 제어할지 말지는 개발자가 정하는 것입니다.
- ref는 랜더링이 일어나지 않습니다.
- 제어 비제어의 장단점입니다. 제어되면 이벤트 핸들러를 상상 작성해야 합니다. 비제어는 필요 없습니다.
- 제어 비제어는 입력이라는 이벤트가 발생할 때마다 유효성 검증할 때 활용합니다.
- 제어 비제어 컴포넌트가 CDD에 중요한 이유는 컴포넌트를 만들고 구성할 때 코드레벨 설계에 영향을 많이 주기 때문에 그렇습니다. 이런 이유로 이 기초가 중요합니다.
- 유효성 검사는 제어컴포넌트가 수월합니다. 물론 순련도가 높으면 비제어 컴포넌트로 유효성 검사하는데 문제 없습니다.
- 제어 비제어는 push pull로 생각하면 됩니다.

### 테스트

- 스토리북 상호작용 테스트입니다. TDD를 추구합니다.
- 전통적인 테스트는 테스트 피라미드로 테스트 코드를 작성합니다. 단위, 서비스, UI로 3계층 테스트를 작성합니다. 이것은 전통적입니다.
- RTL 메인테이너는 테스트 피라미드 보다 프론트엔드에게 더 적합한 테스트 트로피를 권장합니다. 올바른 테스트 전략을 선택하는 것이 중요합니다.
- 테스트를 통해서 달성할 목표를 설정하고 그 전략에 맞는 도구들을 선택하는 것이 중요합니다.
- 결합테스트는 회사마다 조금 다릅니다.
- 정적 분석은 이미 많이 활용하고 있습니다.

- 회사에서 모든 비즈니 로직을 Redux에 넣으면 Redux만 테스트해도 비즈니스 로직이 안전하다는 것을 검증할 수 있습니다.
- 시간이 없어서 일부만 테스트하고 싶을 때 필요한 것은 테스트 전략입니다. 테스트를 어디까지 할지 정할지 잘 정해야 합니다.
- Stroybook + Chromatic 조합도 많습니다.

### 개발환경 설정

- 개발 환경을 설정하기 위한 노력은 현재 최신 버전에서는 그렇게 많지는 않습니다.
- CRA 시대의 패막 이후 vite으로 리액트를 만드는 것이 일반적입니다.

```sh
yarn create vite
```

- 알아서 리액트 플러그인 잘 선택하기 바랍니다.
- 스토리북도 점유율이 높아져서 설치와 설정이 쉬워졌습니다.

```sh
yarn add storybook
```

- 스타일링은 vanilla-extract를 활용합니다.

```sh
yarn add @vanilla-extract/css
```

- 스토리북은 deps를 만들 수 있습니다.
- 최근 스토리북이 7.0으로 버전으로 올랐습니다. 버전이 오르면 API 지원을 안해서 리팩토링이 필요한 경우가 있습니다. 이것을 보고 breaking changes가 있을 것입니다.
- 공식문서를 잘 확인하도록 합니다.
- CSF 문법이 많이 바뀌고 mdx2로 바뀝니다.

https://github.com/dry-frontend/dry-design-system

- RRD도 Remix가 인수하면서 바뀐 점이 많아졌습니다.
- MDX는 마크다운에 JSX가 결합된 문법입니다.

### Q&A

- 상향식 하향식은 팀의 숙련도가 높으면 하이브리드로 작성합니다. 떨어지면 하향식으로 작성합니다.
- 과제는 리액트 과제가 일반적입니다.
  - 과제 복붙이 많아서 회사에서 사용하는 기술을 적용하도록 하는 경우가 많습니다.
- 테스트와 스토리북 중 우선순위를 둬야 한다면 둘다 안 하는 것이 좋습니다.
  - 테스트는 CLI로 단위테스트를 구현하고 일부 E2E로 작성합니다.
- AI가 프론트엔드를 대체할 시기는 5 ~ 10년이라고 봅니다.
  - 생성 AI가 대체 가능성이 높습니다.
- 취준생은 리덕스를 억지로 학습할 필요는 없습니다. 그리고 배울 거면 RTK로 배우면됩니다.
  - 상태관리 라이브러리는 본인의 강점이 담긴 것 1개 정도 잘 알면 좋습니다.
- 스타일링 라이브러리는 CSS-in-JS 계열을 활용하고 있습니다.
- SI, 웹에이전시 다니면 일단 주경야독하고 면접보고 합격하면 바로 다니도록 합니다.
  - 붙으면 가고 떨어지면 지원 계속 반복합니다.
- 주니어 이직과제는 과제보고 면접을 채우면서 이직했습니다.
- 컴포넌트 계층화는 프로젝트 상황마다 다릅니다.
  - 원자단에 가까울수록 시멘틱, Primitive하게 만듭니다.
  - 페이지에 가까워질수록 도메인 컨텍스트가 개입합니다.
    - 라우터, 화면 레이아웃 중복도 발생합니다.
    - 비동기적인 요소도 개입합니다.
  - 하지만 개인적인 생각입니다.
- 대부분 신입 수준입니다.
  - 부트캠프, IT 연합동아리 경험이 있습니다.
  - 프로젝트 1 ~ 3개,
  - 프로그래머스 레벨 1 이상,
  - TS 기본, Next.js는 대부분 공부중
  - 리액트 쿼리를 활용하지만 캐시 무효화 못하는 경우가 대부분입니다. 그냥 편해서 사용하는 경우가 대부분입니다.
  - 경력 2년이면 Next.js 복잡한 기능들을 활용할 수 있고 캐시 무효화도 가능합니다.
- 모노레포 이해해야 회사에서 업무 투입이 쉬워집니다.
- 테스트 도입은 무조건 옳은 선택이라고 할 수 없습니다.
  - 이력서에는 회사 필요한 기술적 기여를 해야합니다.
  - 회사에 기여하기 위해 필요한 기술을 논하면 됩니다. 기술적인 난이도가 엄청나지 않아도 괜찮습니다.
- 최근에는 부트캠프 안나온 사람을 찾기 더 어렵습니다.
  - 부트캠프 2개 다닌 사람 많습니다. 3 ~ 5개 다닌 사람도 봤습니다.
  - 동시에 2개 다니는 사람도 봤습니다. 꽤 많습니다.
  - 3개 다닌 사람은 훌륭한 회사에서 탈락했습니다.
  - 네부캠 다니고도 취업 못한 사람 많습니다. 엘리트는 아닙니다. 네이버 자사는 100중 4명 채용했습니다.
  - 학원에 많은 것을 생각할 필요는 없습니다.

---

https://goshacmd.com/controlled-vs-uncontrolled-inputs-react/

https://wix.github.io/Detox/

https://github.com/ynawhocodes/self-perish-project

## 쿠키 미전송 에러

### 문제: 클라이언트에서 cookie가 서버로 보내지지 않습니다.

클라이언트 서버 미들웨어에 2가지 token을 받아야 합니다. 하나는 access token을 header로 전달해줘야 합니다. 다른 하나는 cookie를 보내야 합니다. 서버에 post 요청을 하면 set-cookie 응답을 받는 것까지는 성공했습니다.

문제가 되는 지점은 받은 cookie를 다시 서버로 보낼 때입니다.

```ts
const accessToken = request.headers.get('Authorization');
const refreshToken = await cookies.get('user');

console.log('tokens', accessToken, refreshToken); // tokens Bearer (token 값) undefined
```

access token은 정상 전달을 확인할 수 있었습니다.

### 시도: ???

#### thunder client 시도

thunder client에서 요청과 응답을 시험했습니다. 그것도 배포서버 기준으로 요청과 응답을 얻은 결과 문제가 없었습니다.

```json
{
  "documents": [
    {
      "_id": "646f1ddb471560ac7eab3735",
      "question": "도큐사우르스 짱짱맨",
      "answer": "킹정",
      "submitDate": "Wed May 17 2023 21:11:26 GMT+0900 (한국 표준시)",
      "stackCount": "0",
      "userId": "646f05c55706b3d59520426b"
    },
    {
      "_id": "646f2c7b471560ac7eae6c9b",
      "question": "블로그를 더 간지나게 만드는 방법",
      "answer": "github pages로 DIY로 만든다.",
      "submitDate": "Wed May 17 2023 21:11:26 GMT+0900 (한국 표준시)",
      "stackCount": "0",
      "userId": "646f05c55706b3d59520426b"
    },
    {
      "_id": "646f36c14df1ac0e273eb0d8",
      "question": "혹시나 했는데???",
      "answer": "역시나!!!",
      "submitDate": "Wed May 17 2023 21:11:26 GMT+0900 (한국 표준시)",
      "stackCount": "1",
      "userId": "646f05c55706b3d59520426b"
    }
  ]
}
```

요청 응답이 정상적으로 동작했습니다.

여기서 추론해볼 수 있는 점은 브라우저 정책문제라는 것으로 에러의 면적을 줄일 수 있습니다.

#### 배포전략이 틀렸습니다.

> 서브 도메인이나 다른 도메인에서 쿠키에 접속할 방법은 없습니다. site.com에서 생성한 쿠키를 other.com에선 절대 전송받을 수 없습니다.

모던 자바스크립트 튜토리얼에서 찾은 내용입니다.

여기서 문제는 배포 도메인과 서버 도메인이 달라서 cookie를 공유할 수 없다는 것을 알 수 있습니다.

일단 무식한 전략으로 deno deploy의 도메인을 변경할 수 있는지 확인해봤습니다.

flash-card-frontend-pi.vercel.app을 도메인 설정으로 입력했습니다. 어림도 없습니다. 반대로 vercel에서 설정을 시도했는데 역시 이미 있어서 막혔다고 합니다.

문제가 있고 문제를 해결하기 위해서는 우회해야 합니다. 우회를 효과적으로 하는 방법을 ChatGPT에게 질문했습니다.

> 만약에 클라이언트와 서버가 통신하는데 클라이언트 도메인과 서버 도메인이 달라서 클라이언트가 쿠키를 전달할 수 없는 상황에서는 어떻게 대응할 수 있는가? 최대한 다양한 전략들을 알려주십시오.
> \- 저의 질문

> 즉 처음 설계할 때 다양한 도메인을 갖게 만들어서 문제가 된 것입니다. 또 개발부채가 추가되었다는 생각이 듭니다. 그냥 Next.js 사용했으면 같은 도메인 API 서버에 요청하고 응답받고 풀스택 프레임워크로 만들 수 있었을 텐데 아쉽습니다. 아마 2.0에서는 메타 프레임워크로 전환해야 합니다.
>
> 클라이언트와 서버가 서로 다른 도메인을 가지고 있을 때, 일반적인 방법으로는 클라이언트가 쿠키를 서버에 전달할 수 없습니다. 그러나 다음과 같은 다양한 전략들을 사용하여 이러한 상황에 대응할 수 있습니다:
>
> 1. 도메인 간 통신 (Cross-Origin Communication):
>
> 웹 브라우저는 도메인 간 통신을 위한 다양한 메커니즘을 제공합니다. 가장 일반적인 방법은 Cross-Origin Resource Sharing (CORS)입니다. 서버에서 CORS 헤더를 설정하여 특정 도메인에서의 요청을 허용할 수 있습니다.
> 또는 서버에서 JSONP(JSON with Padding)이나 프록시를 사용하여 클라이언트와 서버 간의 통신을 중개할 수 있습니다.
>
> 2. 서버 간 쿠키 전달 (Server-to-Server Cookie Transfer):
>
> 클라이언트와 서버 간의 쿠키 전달을 우회하기 위해 서버 간에 쿠키를 전달할 수 있는 메커니즘을 구현할 수 있습니다. 예를 들어, 클라이언트가 서버 A에 요청을 보내면, 서버 A는 서버 B에 요청을 전달하고, 서버 B에서는 클라이언트에 대한 응답과 함께 쿠키를 설정하여 서버 A로 전달할 수 있습니다.
>
> 3. URL 매개변수 사용:
>
> 클라이언트가 서버에 쿠키를 전달할 수 없는 경우, URL 매개변수를 사용하여 필요한 정보를 직접 전달할 수 있습니다. 클라이언트는 매 요청마다 인증 정보나 세션 ID와 같은 데이터를 URL에 포함시켜 서버로 전달합니다. 서버는 해당 매개변수를 검사하여 클라이언트를 식별하고 필요한 동작을 수행합니다.
>
> 4. 토큰 기반 인증 (Token-based Authentication):
>
> 클라이언트와 서버 간의 인증을 위해 토큰 기반 인증을 사용할 수 있습니다. 클라이언트는 로그인 시에 서버로부터 토큰을 받아서 보관하고, 각 요청마다 토큰을 헤더나 매개변수로 전달합니다. 서버는 토큰을 검증하여 클라이언트를 인증하고 요청을 처리합니다.
>
> 5. 다른 도메인 간의 프레임 사용 (Cross-Domain Iframes):
>
> 클라이언트와 서버 간의 통신을 위해 다른 도메인 간에 프레임을 사용할 수 있습니다. 클라이언트에서 프레임을 로드하고, 프레임은 자체 도메인의 쿠키를 전달할 수 있습니다. 프레임은 부모 도메인과 통신하여 필요한 정보를 전달하고 응답을 받을 수 있습니다.
>
> 이러한 전략들은 서로 다른 도메인 간의 상호작용을 위해 사용되는 일반적인 메커니즘입니다. 선택할 전략은 상황에 따라 다를 수 있으며, 보안 요구사항과 기술적 제약 등을 고려하여 적합한 전략을 선택해야 합니다.

가장 단순하게 생각되는 전략은 Refresh token은 Session Storage에 저장하고 header에 같이 보내는 방법입니다. 그리고 나중에 배포를 수정하는 전략이 있습니다. 백엔드 코드를 또 건드리고 patch 릴리즈를 또 해야 하지만 최후의 전략으로 적당해 보입니다.

### 해결: cookie에서 session storage

- 일단 갱신이 필요하면 refresh를 처리하는 절차를 인터셉터로 구현하면 됩니다. 즉 개발 부채가 또 쌓입니다. 하지만 YAGNI 원친에 맞춰 미래의 저에게 맡기겠습니다. 또 패치업데이트 하겠습니다.

### 학습: cookie를 고통스러운 방식으로 배웠습니다.

- cookie는 요청응답 도메인이 같아야 합니다. 그래야 cookie를 포함하고 통신합니다. 도메인이 다르면 cookie는 서버로 전송되지 않습니다. access token은 header에 정상 동작합니다.
- 배포 전략에서 cookie 자원 공유문제를 잘 고려하도록 합니다. 도메인이 달라서 생기는 문제도 고려해야 합니다.
- 한가지 의문이 들었습니다. 모바일은 어떻게 처리하는가?
  > 모바일 애플리케이션에서는 안전한 저장소인 안전한 키 체인(Secure Keychain) 또는 안드로이드의 안전한 저장소(Secure Storage)를 사용하는 것이 좋습니다. 이러한 안전한 저장소는 암호화된 형식으로 사용자의 인증 토큰을 저장하고 안전하게 관리합니다.
  - 얻은 답변입니다. 저장하고 접근하는 전략이 다르다는 것입니다.

## 원티드 특강

1. 저장소 만들기

git 기본이니까 다들 알아서 잘 만들도록 합니다.

fnm, volta, n로 node 버전을 관리할 것을 추천합니다.

라이브러리의 생산자가 될 것입니다. 지금까지 라이브러리의 소비자였다면 이제는 라이브러리의 생산자가 됩니다.

2. npm 환경 초기화

```
yarn init -y
```

3. 스토리북을 설치합니다.

```
yarn storybook
```

4. vanilla-extract로 알아서 설치하도록 합니다.

타입스크립트 설정은 타입스크립트 언어보다 기본 중 기본입니다.

vanilla-extract를 선호할 이유느느 CSS-in-JS 스타일의 코드로 작성하는데 빌드타임에 CSS 컴파일해서 성능이 좋습니다.

또 타입스크립트이기 때문에 타입지정이 상당히 자연스럽습니다.

참고로 어디까지나 빌드타임에 CSS를 컴파일 할 뿐입니다.

양산형 프론트엔드들 대부분이 styled component를 활용하고 있습니다. 더 나쁘게 것만 든 프론트엔드들은 tail wind 사용하고 있습니다. 본인이 아주 익숙한 것 1개만 다루도록 합니다.

대부분 회사는 module css 활용하고 있습니다.

5. 컴포넌트 구현

container presenter 패턴에서 props는 순서를 맞추도록 합니다. 부모의 컴포넌트의 props와 자식에게 전달할 props 순서를 맞추도록 합니다.

6. 번들러 설치

이 예제에서는 rollup을 활용합니다.

```
yarn add rollup
```

vite과 웹팩은 엄청나게 다릅니다. 어디 이상한 것멋만 들고 건들리지 말고 역사와 전통의 웹팩을 고수합시다(물론 작년은 vite의 해였습니다.).

7. 어떤 번들러든 엔트리포인트가 필요합니다.

esbuild로 성능 개선해보는 사람도 있습니다. 번들러에 해당하는 플러그인을 설치합니다.

플러그인이 필요한 이유는 build할 때 esbuild를 활용하는데 중간다리 역할로 필요합니다.

8. 번들을 실행합니다.

번들이 동작한다는 사실을 잘 확인하고 다음 작업을 이어서 진행합니다.

9. peerDeps를 정의합니다.

peerDeps는 아주 기초 개념입니다. 상당히 간단합니다. 면접관 입장에서 양산형을 구분할 때 활용하기 좋습니다.

10. output을 지정합니다.

번들러는 input, output 중간에 plugin/loader 위주로 생각하면 됩니다.

npm 배포 아티클 좋은 자료가 상당히 많습니다.

역사와 전통의 dist 파일을 만들어서 거기에 담아도 됩니다.

output은 esm, cjs 각각 생성하도록 만듭니다.

main은 npm에 등록될 엔트리입니다.

버전 렌즈라는 플러그인을 활용하면 최신인지 확인할 수 있고 업데이트도 가능합니다.

https://rollupjs.org/tools/#peer-dependencies

peer dependencies는 위 공식 문서를 보고 알아서 잘 해결하도록 합니다.

11. npm 로그인

```
npm login
```

OTP를 적극적으로 활용하도록 합니다.

12. .gitignore 설정을 추가합니다.

npm에 키워드는 무조건 등록하도록 합니다. 개발의 작은 디테일은 기본 중 기본입니다.

폴더명 패키지명은 캐밥케이스가 컨벤션입니다. 이것 기본입니다. 그냥 다른 라이브러리만 조금봐도 볼 수 알 수 있는 것입니다.

prepack이라는 것이 추가되었습니다.

배포하는 것은 dist 파일을 배포하게 되는 것입니다.

npm publish 명령으로 올릴 수 있습니다.

vite과 웹팩은 본인의 취향 문제입니다.

리액트에서 컴포넌트를 만들 때는 최대한 원래 컴포넌트와 유사한 형태로 만듭니다. button에 text로 입력하지말고 children에 입력하는 스타일로 작성합니다.

13. 패키지 설치

정상 동작을 확인합니다. 여기까지는 알파버전도 아닙니다.

14. 원격 레포 연결

클론부터 따는 사람도 있습니다. 혼자 일할 때 몰래 그렇게 하고 대부분 검색 없이 로컬하고 원격하고 연결할 수 있습니다.

CI/CD는 크로마틱으로 할 것을 권장합니다. github action도 활용할 수 있습니다.

https://github.com/pocojang/cdd-storybook-wanted

docs page도 만들 수 있습니다. 레포 세팅에서 pages에 docs로 설정할 수 있습니다.

참고로 스토리북과 라이브러리용 번들러는 통일해줘야 합니다. 스토리북은 vite인데 만든 컴포넌트가 웹팩이면 docs에서 에러가 발생할 것입니다.

yml도 못 만지는 기초도 없는 사람들도 다룰 수 있게 제공해주는 것이 많습니다.

awesome readme에서 보고 배우도록 합니다. 또 npm readme example을 활용합니다.

마크다운도 시멘틱한 작성은 기본 중 기본입니다. h1이 1개인 것이 기본인 것처럼 마크다운에서도 동일하게 적용하도록 합니다.

시멘틱 버전은 아주 일반적인 컨벤션입니다. 그냥 마음이 편합니다. 버전이 특이한 경우도 있습니다. 페이스북 리액트 네이티브, 타입스크립트는 시멘틱 버전에 해당하지 않는 경우입니다.

문서화까지 배포하면 알파버전이 끝납니다.

다음 문제는 유지보수의 문제입니다.

---

타입스크립트 변환입니다. 배포전에 빌드과정이 바뀝니다. 바뀌는 것을 학습해야 합니다.

github action / Workflow로 자동 빌들를 작성해야 합니다.

- 릴리즈 문서도 자동생성하도록 만듭니다.
- 자동배포 트리거 시점을 지정하고 생성합니다.
- 커밋 메시지 보고 시멘틱 버전을 지정합니다.
- 커밋 메시지 보고 시멘틱 버번을 NPM 업데이트를 합니다.

이것은 기본입니다. 대부분 프론트엔드 할 줄 알고 있습니다. 양산형만 모릅니다. 이거 하는 신입이 대부분입니다.

https://twitter.com/willmcgugan/status/1423678688802058244

> Absolutely. The thing about semver major version numbers are that they don't mean new stuff, they're a permanent reminder of how many times you got the API wrong. Semver doesn't mean MAJOR.MINOR.PATCH, it means FAILS.FEATURES.BUGS
>
> \- Will McGugan

커밋 컨벤션 중에서 앵귤러 커밋 컨벤션이 대부분 활용합니다.

커밋 메시지에서 작성한 정보를 활용해서 자동화합니다.

다음은 최적화를 해야 합니다.

- CJS, ESM 빌드멸로 최적화 전략 빌드를 정해야 합니다.

깃 커밋 => 배포 시점 트리거 => NPM 업데이트 => 릴리즈 문서 생성 => 스토리북 페이지 배포가 되면 개발 사이클입니다.

5. Figma 수정 => JSON 생성 => 디자인 토큰 생성 => github action 트리거 => 레포에서 사용합니다.

디자인 토큰을 잘 제어하면 됩니다. 디자인 토큰은 디자이너와 커뮤니케이션할 때 hex 값으로 이야기하는 것처럼 활용하는 것입니다. 시멘틱 컬러에서 컬러 시리즈를 지정하는 것과 비슷합니다.

6. 스토리북을 커스터마이징합니다.

크로마틱은 회귀테스트도 제공합니다. 스냅샷과 UI 테스트가 가능합니다.

### Q&A

- 애용하는 디자인 패턴은 없습니다.

- MSW랑 조합해서 사용하면 프론트엔드에게 괜찮은 인터랙션 테스트 도구입니다.

- 크로마틱은 좋은 기능이 많아서 추천합니다. 사이드 프로젝트에 적당합니다.

- 스토리북은 기능도 많지만 필요한 리소스가 많습니다. 프론트엔드 엔지니어의 순련도가 높고 컴포넌트 레벨 개발이 많으면 유용합니다. 디자이너가 디자인 시스템 이해가 어느정도 있어야 합니다.

- 백엔드 개발자와 협업할 때 네트워크, API, http 등 프로토콜에 대한 학습을 잘 하도록 합니다. preflight, cache, option 모두 알아야 합니다. 실력 문제입니다.

  - 욕심이 있다면 최소한 REST API 서버 만들어 봅시다. 한국이라고 Java를 고수할 필요는 없습니다.

- yarn barry 사용할 때 pnp 모르면 곤란합니다.

- 런타임 에러는 심각한 에러입니다. API 오류는 주로 프론트엔드에서 테스트를 하는 것은 아닙니다.

- 이력서에 추가할 만한 사이드 프로젝트는 react real world 정도 수준이 되어야 합니다. 정말 최소입니다. 이것도 못하면 곤란합니다.

- 뽑는 회사가 좋은 회사면 갑니다. SI 입사 전에는 좋좋소랑 조코딩 보고 가도록 합니다.

- 35살 이내면 괜찮습니다. 30대 비전공자 많습니다. 나이 많은 만큼 열심히 하는 사람 많습니다. 시작하기 늦은 나이는 없지만 돌아가면 늦은 나이가 됩니다.

- 상태코드 막날려서 200으로 모두 하나로 합치는 이상한 백엔드 있습니다. 하지만 공수가 많습니다.

- 회사가 한가하면 코드리뷰를 하면서 클린코드가 무엇인지 알려주면 됩니다.

- 난잡한 경우는 실력이 부족한 경우입니다. 고치지 못하는 경우 조언하는 것이 좋습니다.

- null 병합 연산자의 등장으로 의미가 퇴색했지만 undefined 대 null 중 undefined를 선호합니다.

- 많은 회사가 아직도 프론트엔드 코드가 백엔드 내부에 있는 경우는 흔합니다. 백엔드가 직접 프론트를 보고 싶은 경우도 있습니다.

- 회고는 KTP, 4Ls, 5F, PMI를 추천합니다.

- 스토리북 맛보기를 한 것입니다. 이제는 조금더 고급스러운 자료를 봐도 이해가 잘 될 것입니다.

## 휴대폰 탭 정리

예비군에서 폰질을 많이 하면서 휴대폰 베터리를 너무 많이 그리고 너무 빨리 소모하기 시작했습니다. 물론 안드로이드 운영체제의 브라우저는 생각보다 효율적이라 큰 문제는 없을 것이지만 일단 정리하고 싶어졌습니다.

1. Image Carousel
2. FAQ/Accordion
3. Quote Generator
4. Shopping list
5. GitHub User Search
6. Video Player
7. BMI Calculator

컴포넌트 1개만 만드는 프로젝트를 진행하더라도 위 프로젝트들은 반드시 경험해야 하는 것들입니다.

그 외에 개인적으로 그래프 관련 컴포넌트까지 해봐야 한다고 생각합니다.

## visibility는 예약어입니다.

> Warning: Received `false` for a non-boolean attribute visibility

`visible`로 이름을 바꾸니까 경고가 사라졌습니다.

## react real world

이력서에 넣을 수 있을 정도로 정말 최소한의 기준이 react real world를 활용하라는 정보를 얻었습니다.

[realworld github 레포](https://github.com/gothinkster/realworld)

[realworld 사이트](https://demo.realworld.io/)

위 사이트보다 수준이 높으면 이력서에 넣어도 괜찮다는 것입니다.

하지만 검색 중에 [Real World React](https://www.realworldreact.com/)도 발견했습니다. 여기서 유튜브 채널도 운영하고 있는데 네임드 개발자의 세션들도 있었습니다.

[Real World React 유튜브](https://www.youtube.com/@RealWorldReact)

일단 마음의 안정을 취할 수 있을 것 같습니다. 더 난이도가 높고 퀄리티 높은 프로젝트를 만들 수 있을 것이라는 확신이 있습니다.

물론 강사님이 상당히 관대한 사람인 것 같습니다.
