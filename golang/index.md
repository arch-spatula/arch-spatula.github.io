---
sidebar_position: 1
---

# go 언어

이거 배우는 이유는 단순합니다. 언어가 재미있기 때문입니다. python 보다 설정이 단순합니다. python은 가상환경 설정이 귀찮습니다.

사실 c언어를 먼저 학습해야 하기는 하지만 예스잼 필이 별로 안 왔습니다. golang은 자동완성 뽕맛이 있어서 계속하고자 합니다.

다양한 학습 리소스가 있습니다. 저는 tucker의 go 언어 프로그래밍 유튜브 시리즈와 바탕으로 도서를 활용할 것입니다.

https://www.youtube.com/playlist?list=PLy-g2fnSzUTBHwuXkWQ834QHDZwLx6v6j

https://www.youtube.com/watch?v=CIyLurz-Ius

[Tucker의 Go 언어 프로그래밍] 1장 컴퓨터 원리 1/2

## 부가적인 학습 리소스

[Tucker](https://www.youtube.com/@TuckerProgramming)

- 이 유튜버가 학습 리소스입니다.

[gophercises](https://gophercises.com/)

- 프로젝트 기반으로 golang을 학습할 수 있습니다.

[The Go Programming Language](http://acornpub.co.kr/book/go-programming)

- 오래된 책입니다. 재출판하면 구매하기를 권장합니다.

[Go by Example](https://gobyexample.com/)

- go 언어는 저처럼 머리가 나쁜 개발자에게 좋은 언어입니다. 하지만 언어가 쉬운 것으로 부족해서 예시마저 정리해준 사이트도 있습니다.

[예제로 배우는 Go 프로그래밍](http://golang.site/)

- 한국어 설명이 상당히 잘되어 있는 사이트입니다. 기초부터 응용까지 자료가 많습니다.

## 트렌지스터

애니악은 대학교 건물 층 1개 전체를 차지했습니다. 진공관은 비싸고 부피가 크고 고장이 잘났습니다. 이시절 버그는 실제 벌레가 큰 컴퓨터 안에 계산을 망치면서 발생했습니다.

트렌지스터는 나노사이즈로 만듭니다. $10^{-9}$m입니다. 실리콘으로 만듭니다. 규소로 만듭니다. 규소는 모래로 만듭니다. 모래를 구워서 만들기 때문에 튼튼해서 고장이 잘 안납니다. 전기도 효율적입니다.

n형 실리콘은 전자가 많아 +고 p는 -이리고 간주할 수 있습니다. 가운데가 베이스 양끝은 이미터와 콜랙터로 되어 있습니다.

전기가 바로 흘러서 전구가 들어오지 않습니다. p가 댐역할을 합니다. 베이스에 추가로 전압을 가하면 전기가 흐릅니다. 댐의 벽이 내렸다고 볼 수 있습니다. 이것을 보고 스위치라고 합니다.

트렌지스터를 다른말로 반도체라고 합니다. 반도체는 도체일 수 있고 아닐 수 있기 때문입니다. 금, 구리, 물처럼 전기가 흐르면 도체라고 합니다. 고무, 세라믹은 부도체에 해당합니다. 실리콘은 베이스에 전압을 가하는 특정 조건이 성립하면 도체가 되기 때문에 반도체가 됩니다. 전압을 안 가하면 부도체가 되어서 스위치고 반도체를 보고 전기의 흐름 여부를 제어할 수 있습니다.

전기가 흐르면 1 안 흐르면 0이 됩니다. 컴퓨터가 0과 1만 알고 있다고 하는 여러개의 트렌지스터로 만들기 때문에 가능합니다.

이것으로 이진수를 표현할 수 있게 됩니다. 2개의 숫자를 표현합니다. 놀랍게도 모든 숫자를 표현할 수 있습니다.

인간은 10진수 체계를 사용합니다.

컴퓨터의 본질은 계산기입니다. 어떻계 계산기를 만드는가? 논리소자 여러개를 결합해서 계산기를 만들 수 있습니다.

and 2개의 전압을 받아야 1이 됩니다.

or은 2개 중 1개이상 전압을 받으면 1이됩니다.

not은 역입니다. 1을 받으면 0 반대로 0을 받으면 1이 나옵니다.

xor은 2개 중 1개만 전압을 받으면 1이 됩니다. 1을 2개 받으면 0이 됩니다.

트렌지스터 2개로 베이스 2개를 받으면 and를 만들 수 있습니다. 2개의 지점에서 도체가 되어야 and가 됩니다. 이미터에서 2개의 도체를 허용받아야 합니다.

1비트 가산기

| A   | B   | 결과 |
| --- | --- | ---- |
| 0   | 0   | 00   |
| 0   | 1   | 01   |
| 1   | 0   | 01   |
| 1   | 1   | 11   |

| A   | B   | 올림 | 합  |
| --- | --- | ---- | --- |
| 0   | 0   | 0    | 0   |
| 0   | 1   | 0    | 1   |
| 1   | 0   | 0    | 1   |
| 1   | 1   | 1    | 0   |

올림은 and로 만들 수 있습니다. 그리고 합은 xor로 만들 수 있습니다.

덧셈은 올림과 합으로 만들 수 있습니다. 이렇게 2개의 트렌지스터를 활용해서 1비트 가산기를 만들 수 있습니다.

가산기, 감산기, 곱센기, 나눗셈기 등 계산기를 만들 수 있게 됩니다.

트렌지스터는 1비트 1개를 담을 수 있습니다. 트렌지스터를 통해서 논리소자를 만들 수 있습니다. 계산기는 이러한 논리소자들을 통해서 가산기, 감산기, 곱셈기, 나눗셈기 등을 만들 수 있습니다.

하지만 계산기와 컴퓨터 다릅니다. 계산기와 컴퓨터의 핵심적인 차이는 프로그래밍과 같은 명령(프로그램)으로 원하는데로 제어할 수 있는가가 관건입니다.

## [Tucker의 Go 언어 프로그래밍] 2장 프로그래밍 언어

https://www.youtube.com/watch?v=ELOihQ1HYBY

원하는 명령을 원하는 순서대로 실행할 수 있도록 작성한 문서가 프로그램입니다.

순서는 제어입니다. 제어는 2가지입니다. 분기와 반복입니다.

프로그램은 결국에는 문서입니다. 이 문서를 만드는 작업을 보고 프로그래밍이라고 합니다. 문서를 작성할 때 사용한 언어가 프로그램 언어입니다.

문서의 독자는 컴퓨터입니다. 컴퓨터는 문자를 읽을 수 없습니다. 더 정확히 직접 읽을 줄 모릅니다.

op 코드 add(0011)로 3(0011)과 4(0100)를 더하도록 하고 싶습니다. 컴퓨터는 op 코드 즉 작업 명령을 위한 코드입니다. 컴퓨터는 add를 모릅니다. 하지만 0011은 압니다. 3 + 4를 001100110100으로 읽습니다.

mux에서 논리소자로 add 가산기인지, 감산기인지 연결됩니다. 컴퓨터는 명령을 해석하기 보단 mux 기계에서 처리합니다.

과거에는 천공카드로 0과 1을 직접 입력했습니다. 구멍을 수기로 뚤었습니다. 여기서 문제는 잘못 뚤었으면 알수 없습니다. 어디가 잘못되었느지 모릅니다. 초기 프로그램은 이런 천공카드로 작성되었습니다. 초기 프로그래머의 작업이 이런 것이었습니다.

이후에 어쎔블리어가 등장했습니다. 모니터와 키보드로 사람이 읽을 수 있을 정도로 쉬워졌습니다. ADD, SUB, MOV(복사)가 있었습니다. 천공카드보다 더 수월하게 입력할 수 있게 됩니다. 입력 내역 전체를 검토할 수 있게 됩니다.

컴퓨터는 결국에는 0과 1의 기계어로 번역되어야 합니다. 어쎔블리어를 기계어로 변환해줘야 합니다. 어쎔블리어는 1대1로 컴파일됩니다.

어쎔블리어도 결국에는 한계가 있었습니다. 컴퓨터의 명령이 1대1로 대응되어야 합니다. 문제는 번거롭고 여전히 복잡해집니다. 고급 기능을 활용하기 어렵습니다. 현대 프로그래밍 언어는 활용할 고급기능이 많습니다. 어쎔블리어는 활용할 고급기능이 없습니다. 이런 이유로 고수준 언어가 등장했습니다.

어쎔블리어를 보고 저수준 언어고 나머지는 고수준언어라고 봐야 합니다.

고수준 언어는 인간이 읽기 쉽고 동작을 예상하기 쉽습니다.

```go
func main() {
  fmt.Println("Hello, world!")
}
```

고수준 언어는 고급 기능을 활용할 수 있습니다. 고수준이든 저수준이든 결국에는 기계어로 변환되어야 합니다.

결국에는 컴파일(인터프리터)과정이 필요합니다.

언어를 구분할 때 변환되는 시점에 따라 정적 컴파일언어와 동적 컴파일 언어로 구분할 수 있습니다. 컴파일해서 기계어로 미리 만들어 생긴 파일을 보고 실행파일이라고 봅니다. 매번 컴파일 할 필요가 없어서 속도가 빠릅니다.

동적 컴파일언어는 실행하면서 소스코드를 기계어로 바꿉니다. 정적컴파일은 미리해서 편하지만 동적 컴파일은 대체로 컴파일 속도가 빠릅니다.

c언어, java는 정적 컴파일언어입니다. 정적컴파일 언어의 문제점이 있어서 동적 컴파일 언어가 탄생했습니다.

op 코드는 명령을 이진수 숫자에 대입합니다. 기계어로 변환되려면 op 코드로 변환되어야 합니다. op 코드를 알아야 기계어를 사용할 수 있습니다.

옛날에는 cpu를 만드는 회사가 많았습니다. 회사마다 op 코드가 모두 달랐습니다. 표준이 없었습니다. 실행환경마다 만들어야 하는 기계어가 달라졌습니다.

정적 컴파일 언어에서는 기계어로 바꿔야 할 때 타겟 실행파일을 알아내고 컴파일해야 합니다. 과거에는 각각의 플랫폼별로 실행파일을 만드는 경우도 있었습니다. 또 사용자도 실행파일도 각각 받아야 했습니다.

동적 컴파일언어는 현재 본인의 환경을 분석하고 거기에 맞게 기계어로 변환합니다. 동일한 코드로 컴퓨터는 달라도 동일하게 실행될 수 있게 합니다.

go는 정적 컴파일 언어입니다. 이유는 속도입니다. 또 호스트 환경 플랫폼이 단순해졌습니다. 운영체제도 옛날보다 종류가 많이 감소했습니다.

go는 여러 플랫폼에 실행파일 만들 수 있게 언어차원에서 제공해주고 있습니다.

```sh
$Env:GOOS = "linux"
```

go의 os를 임의로 바꾸는 명령입니다.

```sh
go build
```

이렇게하면 리눅스용 실행파일이 생성될 것입니다.

go 언어의 특징 중 하나는 본인의 운영체제로 기본설정하는데 다른 원하는 운영체제를 타게팅해서 만들 수 있습니다. 실행파일을 공유만 해주면 됩니다.

약타입 언어와 강타입언어로 분류도 가능합니다.

"12" + 12 = "1212"

이렇게 되는 언어도 있습니다. 자바스크립트가 그렇습니다. 문자열과 숫자가 있는데 모두 문자열로 변환하고 문자열을 concat했습니다.

"12" + 12 = error

이렇게 에러 처리해주는 언어도 있습니다.

약타입 언어 중에서도 타입이 다를 때 계산을 막는 언어도 있습니다.

약타입 강타입은 스펙트럼으로 이해하는 것이 더 적합합니다.

언어에 따라 다르지만 정수와 소수를 더하면 에러를 발생시키는 언어도 있고 모수 소수로 변환하고 계산하는 언어도 있습니다.

go 언어는 강타입 언어로 분류할 수 있습니다. 타입검사가 상당히 강한편입니다.

타입을 맞춰줘야 하는 귀찮은 경우가 많지만 큰 코드베이스에서 이상하게 발생하는 버그는 방지됩니다.

언어를 구분할 때 GC 유무로 분류가 가능합니다. 쓰레기는 메모리 쓰레기입니다. GC가 없는 언어는 C, C++, Rust, Zig입니다. 있는 언어는 go, python, java, javascript가 해당합니다.

GC가 없으면 프로그래머가 수동으로 제거해줘야 합니다. 안 하면 메모리 누수가 발생하고 프로그램이 강제 종료가 될 수 있습니다. 또 버그가 발생할 수 있습니다.

GC의 장점은 프로그래머의 편의성입니다. 단점은 성능입니다.

Go 언어는 특이하게 GC가 있어도 성능이 상당히 좋습니다.

## [Tucker의 Go 언어 프로그래밍] 3장 Hello Go World

https://www.youtube.com/watch?v=-a63oRs38DY

오픈소스를 흉내내는 프로그램 언어입니다. 켄 톰슨이 만들었습니다. 켄 톰슨은 B언어를 만들었습니다. B언어는 C언의 모체가 됩니다. go의 많은 C언어 스러운 부분이 됩니다. C언어와 닮은 부분이 많습니다.

롭 파이크 go를 창시했는데 켄 톰슨이랑 같이 utf-8을 만들었습니다. go는 utf-8이 기본 문자입니다.

문자 인코딩은 문자를 어떻게 표현할지 문제를 해결합니다. 컴퓨터는 0과 1만 압니다. 명령어를 숫자로 바꾸는 것이 op 코드인데 컴퓨터가 문자를 숫자로 변환시켜줄 수 있게 해줍니다. 그리고 컴퓨터에게 숫자가 나오면 어떤 문자의 모양을 모니터에 출력하게 해줍니다.

문자 코드입니다. 문자 코드는 ANSI만 존재했습니다. 이 코드는 1바이트로 영어를 표현했습니다. 1바이트로 표현할 수 있는 문자는 128의 문자를 표현할 수 있었습니다. 영어, 숫자, 특수 문자 몇개를 만들었습니다.

컴퓨터가 전세계에 보편화되면서 문제가 생깁니다. 표현하기 부족합니다. utf-8이 이 문제를 해결해줍니다. 유니코드는 2바이트로 문자를 표현할 수 있습니다. utf-8은 1 ~ 3바이트로 표현합니다.

go는 기본적으로 utf-8로 표현할 수 있어서 한글, 한자 문자를 표현할 수 있습니다.

오픈 소스 프로그래밍 언어입니다. 먼저 언어도 프로그램입니다. go는 컴파일러 언어입니다. go 언어는 변화하는 컴파일러 프로그램입니다. 이 go를 만든 프로그램도 존재합니다. 그리고 공개되어 있고 기여도 가능합니다. 여기에 기여하면 이력서에 추가하기 바랍니다.

go는 클래스를 지원하지 않습니다. 메서드를 가진 구조체를 지원합니다.

상속 없습니다. 클래스가 없으니 당연합니다.

메서드 있습니다. 구조체가 있습니다. 또 어떤 타입이든 메서드를 가질 수 있습니다.

인터페이스는 지원하고 있습니다. 익명함수 있습니다. 하지만 함수 리터럴이라고 합니다.

GC있습니다. 성능도 좋습니다.

포인터 있습니다. go 포인터가 있는데 c언어와 비슷합니다. 포인터는 메모리 주소를 값으로 갖는 타입을 말합니다.

제네릭 프로그래밍 지금은 있지만 많이 제공하지 않습니다. 제네릭이 만드는 문제가 상당히 많습니다.

네임스페이스 없습니다. 패키지 단위로 분리됩니다. 모든 코드가 패키지 단위로 분리합니다.

```go
package main

import "fmt"

func main() {
	// 이것은 주석입니다.
	fmt.Println("Hello, go lang!")
}
```

이제 이렇게 만들면 됩니다.

```sh
go mod init (프로젝트_디렉토리/하위디렉토리)
```

실험을 위한 폴더 이름을 만드는 팁입니다.

go의 모든 코드는 package로 시작해야 합니다. 지금 코드가 호출하는 패키지를 봐야 합니다. 패키지는 코드를 묶는 단위입니다. 패키지 명은 아무거나 작성해도 괜찮습니다. 하지만 main은 특별한 의미를 갖고 있습니다. main은 프로그램 인트리포인트를 포함하는 패키지를 의미합니다. 여기서 프로그램 처리의 모든 시작점이 됩니다.

프로그램이 실행되면 디스크에서 메모리로 호출됩니다. 그리고 CPU는 메모리에서 읽습니다. 읽을 때 어디수 부터 읽을 것인가? 컴퓨터는 사실 중간에서 시작해도 괜찮습니다. 하지만 go는 main에서 지작해야 합니다. 인트리 포인트 1개입니다. 사실 이것은 대부분 프로그램에 해당합니다. main.go에서 출발해야 합니다.

`import fmt`는 `fmt`라는 패키지를 호출한 것입니다. 패키지는 코드를 묶어 놓은 단위인데 패키지에 유용한 기능을 호출합니다. 기능을 갖고 있는 패키지로 `import`합니다.

`import main`이 가능한가? 논리적으로 불가능해야 합니다. `main`은 엔트리 포인트이자 프로그램의 루트 역할을 해야 합니다.

`func`는 함수 키워드입니다. 함수를 선언 한 것입니다. 함수명은 자유롭게 작성해도 괜찮지만 `main`은 예약어와 비슷합니다. `main` 함수명은 시작점을 의미합니다. `package main`은 `main` 함수를 호출해서 해당하는 예약어를 사용하고 있다고 볼 수 있습니다.

주석은 JSDoc을 제외하고 자바스크립트와 동일합니다.

주석은 모든 곳에 만들 수 있습니다. 어떤 위치에서 작성할 수 없게 언어 차원에서 차단하는 언어도 존재합니다. 하지만 golang은 제한하지 않습니다.

`fmt.Println`는 패키지로 호출해서 호출한 패키지의 메서드를 사용한 것입니다. 패키지의 함수를 사용한 것입니다. `ln`은 줄 line을 의미합니다.
