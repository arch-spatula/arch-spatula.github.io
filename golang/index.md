---
sidebar_position: 1
---

# go 언어

이거 배우는 이유는 단순합니다. 언어가 재미있기 때문입니다. python 보다 설정이 단순합니다. python은 가상환경 설정이 귀찮습니다.

사실 c언어를 먼저 학습해야 하기는 하지만 예스잼 필이 별로 안 왔습니다. golang은 자동완성 뽕맛이 있어서 계속하고자 합니다.

다양한 학습 리소스가 있습니다. 저는 tucker의 go 언어 프로그래밍 유튜브 시리즈와 바탕으로 도서를 활용할 것입니다.

https://www.youtube.com/playlist?list=PLy-g2fnSzUTBHwuXkWQ834QHDZwLx6v6j

https://www.youtube.com/watch?v=CIyLurz-Ius

[Tucker의 Go 언어 프로그래밍] 1장 컴퓨터 원리 1/2

## 부가적인 학습 리소스

[Tucker](https://www.youtube.com/@TuckerProgramming)

- 이 유튜버가 학습 리소스입니다.

[gophercises](https://gophercises.com/)

- 프로젝트 기반으로 golang을 학습할 수 있습니다.

[The Go Programming Language](http://acornpub.co.kr/book/go-programming)

- 오래된 책입니다. 재출판하면 구매하기를 권장합니다.

[Go by Example](https://gobyexample.com/)

- go 언어는 저처럼 머리가 나쁜 개발자에게 좋은 언어입니다. 하지만 언어가 쉬운 것으로 부족해서 예시마저 정리해준 사이트도 있습니다.

[예제로 배우는 Go 프로그래밍](http://golang.site/)

- 한국어 설명이 상당히 잘되어 있는 사이트입니다. 기초부터 응용까지 자료가 많습니다.

## 트렌지스터

애니악은 대학교 건물 층 1개 전체를 차지했습니다. 진공관은 비싸고 부피가 크고 고장이 잘났습니다. 이시절 버그는 실제 벌레가 큰 컴퓨터 안에 계산을 망치면서 발생했습니다.

트렌지스터는 나노사이즈로 만듭니다. $10^{-9}$m입니다. 실리콘으로 만듭니다. 규소로 만듭니다. 규소는 모래로 만듭니다. 모래를 구워서 만들기 때문에 튼튼해서 고장이 잘 안납니다. 전기도 효율적입니다.

n형 실리콘은 전자가 많아 +고 p는 -이리고 간주할 수 있습니다. 가운데가 베이스 양끝은 이미터와 콜랙터로 되어 있습니다.

전기가 바로 흘러서 전구가 들어오지 않습니다. p가 댐역할을 합니다. 베이스에 추가로 전압을 가하면 전기가 흐릅니다. 댐의 벽이 내렸다고 볼 수 있습니다. 이것을 보고 스위치라고 합니다.

트렌지스터를 다른말로 반도체라고 합니다. 반도체는 도체일 수 있고 아닐 수 있기 때문입니다. 금, 구리, 물처럼 전기가 흐르면 도체라고 합니다. 고무, 세라믹은 부도체에 해당합니다. 실리콘은 베이스에 전압을 가하는 특정 조건이 성립하면 도체가 되기 때문에 반도체가 됩니다. 전압을 안 가하면 부도체가 되어서 스위치고 반도체를 보고 전기의 흐름 여부를 제어할 수 있습니다.

전기가 흐르면 1 안 흐르면 0이 됩니다. 컴퓨터가 0과 1만 알고 있다고 하는 여러개의 트렌지스터로 만들기 때문에 가능합니다.

이것으로 이진수를 표현할 수 있게 됩니다. 2개의 숫자를 표현합니다. 놀랍게도 모든 숫자를 표현할 수 있습니다.

인간은 10진수 체계를 사용합니다.

컴퓨터의 본질은 계산기입니다. 어떻계 계산기를 만드는가? 논리소자 여러개를 결합해서 계산기를 만들 수 있습니다.

and 2개의 전압을 받아야 1이 됩니다.

or은 2개 중 1개이상 전압을 받으면 1이됩니다.

not은 역입니다. 1을 받으면 0 반대로 0을 받으면 1이 나옵니다.

xor은 2개 중 1개만 전압을 받으면 1이 됩니다. 1을 2개 받으면 0이 됩니다.

트렌지스터 2개로 베이스 2개를 받으면 and를 만들 수 있습니다. 2개의 지점에서 도체가 되어야 and가 됩니다. 이미터에서 2개의 도체를 허용받아야 합니다.

1비트 가산기

| A   | B   | 결과 |
| --- | --- | ---- |
| 0   | 0   | 00   |
| 0   | 1   | 01   |
| 1   | 0   | 01   |
| 1   | 1   | 11   |

| A   | B   | 올림 | 합  |
| --- | --- | ---- | --- |
| 0   | 0   | 0    | 0   |
| 0   | 1   | 0    | 1   |
| 1   | 0   | 0    | 1   |
| 1   | 1   | 1    | 0   |

올림은 and로 만들 수 있습니다. 그리고 합은 xor로 만들 수 있습니다.

덧셈은 올림과 합으로 만들 수 있습니다. 이렇게 2개의 트렌지스터를 활용해서 1비트 가산기를 만들 수 있습니다.

가산기, 감산기, 곱센기, 나눗셈기 등 계산기를 만들 수 있게 됩니다.

트렌지스터는 1비트 1개를 담을 수 있습니다. 트렌지스터를 통해서 논리소자를 만들 수 있습니다. 계산기는 이러한 논리소자들을 통해서 가산기, 감산기, 곱셈기, 나눗셈기 등을 만들 수 있습니다.

하지만 계산기와 컴퓨터 다릅니다. 계산기와 컴퓨터의 핵심적인 차이는 프로그래밍과 같은 명령(프로그램)으로 원하는데로 제어할 수 있는가가 관건입니다.

## [Tucker의 Go 언어 프로그래밍] 2장 프로그래밍 언어

https://www.youtube.com/watch?v=ELOihQ1HYBY

원하는 명령을 원하는 순서대로 실행할 수 있도록 작성한 문서가 프로그램입니다.

순서는 제어입니다. 제어는 2가지입니다. 분기와 반복입니다.

프로그램은 결국에는 문서입니다. 이 문서를 만드는 작업을 보고 프로그래밍이라고 합니다. 문서를 작성할 때 사용한 언어가 프로그램 언어입니다.

문서의 독자는 컴퓨터입니다. 컴퓨터는 문자를 읽을 수 없습니다. 더 정확히 직접 읽을 줄 모릅니다.

op 코드 add(0011)로 3(0011)과 4(0100)를 더하도록 하고 싶습니다. 컴퓨터는 op 코드 즉 작업 명령을 위한 코드입니다. 컴퓨터는 add를 모릅니다. 하지만 0011은 압니다. 3 + 4를 001100110100으로 읽습니다.

mux에서 논리소자로 add 가산기인지, 감산기인지 연결됩니다. 컴퓨터는 명령을 해석하기 보단 mux 기계에서 처리합니다.

과거에는 천공카드로 0과 1을 직접 입력했습니다. 구멍을 수기로 뚤었습니다. 여기서 문제는 잘못 뚤었으면 알수 없습니다. 어디가 잘못되었느지 모릅니다. 초기 프로그램은 이런 천공카드로 작성되었습니다. 초기 프로그래머의 작업이 이런 것이었습니다.

이후에 어쎔블리어가 등장했습니다. 모니터와 키보드로 사람이 읽을 수 있을 정도로 쉬워졌습니다. ADD, SUB, MOV(복사)가 있었습니다. 천공카드보다 더 수월하게 입력할 수 있게 됩니다. 입력 내역 전체를 검토할 수 있게 됩니다.

컴퓨터는 결국에는 0과 1의 기계어로 번역되어야 합니다. 어쎔블리어를 기계어로 변환해줘야 합니다. 어쎔블리어는 1대1로 컴파일됩니다.

어쎔블리어도 결국에는 한계가 있었습니다. 컴퓨터의 명령이 1대1로 대응되어야 합니다. 문제는 번거롭고 여전히 복잡해집니다. 고급 기능을 활용하기 어렵습니다. 현대 프로그래밍 언어는 활용할 고급기능이 많습니다. 어쎔블리어는 활용할 고급기능이 없습니다. 이런 이유로 고수준 언어가 등장했습니다.

어쎔블리어를 보고 저수준 언어고 나머지는 고수준언어라고 봐야 합니다.

고수준 언어는 인간이 읽기 쉽고 동작을 예상하기 쉽습니다.

```go
func main() {
  fmt.Println("Hello, world!")
}
```

고수준 언어는 고급 기능을 활용할 수 있습니다. 고수준이든 저수준이든 결국에는 기계어로 변환되어야 합니다.

결국에는 컴파일(인터프리터)과정이 필요합니다.

언어를 구분할 때 변환되는 시점에 따라 정적 컴파일언어와 동적 컴파일 언어로 구분할 수 있습니다. 컴파일해서 기계어로 미리 만들어 생긴 파일을 보고 실행파일이라고 봅니다. 매번 컴파일 할 필요가 없어서 속도가 빠릅니다.

동적 컴파일언어는 실행하면서 소스코드를 기계어로 바꿉니다. 정적컴파일은 미리해서 편하지만 동적 컴파일은 대체로 컴파일 속도가 빠릅니다.

c언어, java는 정적 컴파일언어입니다. 정적컴파일 언어의 문제점이 있어서 동적 컴파일 언어가 탄생했습니다.

op 코드는 명령을 이진수 숫자에 대입합니다. 기계어로 변환되려면 op 코드로 변환되어야 합니다. op 코드를 알아야 기계어를 사용할 수 있습니다.

옛날에는 cpu를 만드는 회사가 많았습니다. 회사마다 op 코드가 모두 달랐습니다. 표준이 없었습니다. 실행환경마다 만들어야 하는 기계어가 달라졌습니다.

정적 컴파일 언어에서는 기계어로 바꿔야 할 때 타겟 실행파일을 알아내고 컴파일해야 합니다. 과거에는 각각의 플랫폼별로 실행파일을 만드는 경우도 있었습니다. 또 사용자도 실행파일도 각각 받아야 했습니다.

동적 컴파일언어는 현재 본인의 환경을 분석하고 거기에 맞게 기계어로 변환합니다. 동일한 코드로 컴퓨터는 달라도 동일하게 실행될 수 있게 합니다.

go는 정적 컴파일 언어입니다. 이유는 속도입니다. 또 호스트 환경 플랫폼이 단순해졌습니다. 운영체제도 옛날보다 종류가 많이 감소했습니다.

go는 여러 플랫폼에 실행파일 만들 수 있게 언어차원에서 제공해주고 있습니다.

```sh
$Env:GOOS = "linux"
```

go의 os를 임의로 바꾸는 명령입니다.

```sh
go build
```

이렇게하면 리눅스용 실행파일이 생성될 것입니다.

go 언어의 특징 중 하나는 본인의 운영체제로 기본설정하는데 다른 원하는 운영체제를 타게팅해서 만들 수 있습니다. 실행파일을 공유만 해주면 됩니다.

약타입 언어와 강타입언어로 분류도 가능합니다.

"12" + 12 = "1212"

이렇게 되는 언어도 있습니다. 자바스크립트가 그렇습니다. 문자열과 숫자가 있는데 모두 문자열로 변환하고 문자열을 concat했습니다.

"12" + 12 = error

이렇게 에러 처리해주는 언어도 있습니다.

약타입 언어 중에서도 타입이 다를 때 계산을 막는 언어도 있습니다.

약타입 강타입은 스펙트럼으로 이해하는 것이 더 적합합니다.

언어에 따라 다르지만 정수와 소수를 더하면 에러를 발생시키는 언어도 있고 모수 소수로 변환하고 계산하는 언어도 있습니다.

go 언어는 강타입 언어로 분류할 수 있습니다. 타입검사가 상당히 강한편입니다.

타입을 맞춰줘야 하는 귀찮은 경우가 많지만 큰 코드베이스에서 이상하게 발생하는 버그는 방지됩니다.

언어를 구분할 때 GC 유무로 분류가 가능합니다. 쓰레기는 메모리 쓰레기입니다. GC가 없는 언어는 C, C++, Rust, Zig입니다. 있는 언어는 go, python, java, javascript가 해당합니다.

GC가 없으면 프로그래머가 수동으로 제거해줘야 합니다. 안 하면 메모리 누수가 발생하고 프로그램이 강제 종료가 될 수 있습니다. 또 버그가 발생할 수 있습니다.

GC의 장점은 프로그래머의 편의성입니다. 단점은 성능입니다.

Go 언어는 특이하게 GC가 있어도 성능이 상당히 좋습니다.

## [Tucker의 Go 언어 프로그래밍] 3장 Hello Go World

https://www.youtube.com/watch?v=-a63oRs38DY

오픈소스를 흉내내는 프로그램 언어입니다. 켄 톰슨이 만들었습니다. 켄 톰슨은 B언어를 만들었습니다. B언어는 C언의 모체가 됩니다. go의 많은 C언어 스러운 부분이 됩니다. C언어와 닮은 부분이 많습니다.

롭 파이크 go를 창시했는데 켄 톰슨이랑 같이 utf-8을 만들었습니다. go는 utf-8이 기본 문자입니다.

문자 인코딩은 문자를 어떻게 표현할지 문제를 해결합니다. 컴퓨터는 0과 1만 압니다. 명령어를 숫자로 바꾸는 것이 op 코드인데 컴퓨터가 문자를 숫자로 변환시켜줄 수 있게 해줍니다. 그리고 컴퓨터에게 숫자가 나오면 어떤 문자의 모양을 모니터에 출력하게 해줍니다.

문자 코드입니다. 문자 코드는 ANSI만 존재했습니다. 이 코드는 1바이트로 영어를 표현했습니다. 1바이트로 표현할 수 있는 문자는 128의 문자를 표현할 수 있었습니다. 영어, 숫자, 특수 문자 몇개를 만들었습니다.

컴퓨터가 전세계에 보편화되면서 문제가 생깁니다. 표현하기 부족합니다. utf-8이 이 문제를 해결해줍니다. 유니코드는 2바이트로 문자를 표현할 수 있습니다. utf-8은 1 ~ 3바이트로 표현합니다.

go는 기본적으로 utf-8로 표현할 수 있어서 한글, 한자 문자를 표현할 수 있습니다.

오픈 소스 프로그래밍 언어입니다. 먼저 언어도 프로그램입니다. go는 컴파일러 언어입니다. go 언어는 변화하는 컴파일러 프로그램입니다. 이 go를 만든 프로그램도 존재합니다. 그리고 공개되어 있고 기여도 가능합니다. 여기에 기여하면 이력서에 추가하기 바랍니다.

go는 클래스를 지원하지 않습니다. 메서드를 가진 구조체를 지원합니다.

상속 없습니다. 클래스가 없으니 당연합니다.

메서드 있습니다. 구조체가 있습니다. 또 어떤 타입이든 메서드를 가질 수 있습니다.

인터페이스는 지원하고 있습니다. 익명함수 있습니다. 하지만 함수 리터럴이라고 합니다.

GC있습니다. 성능도 좋습니다.

포인터 있습니다. go 포인터가 있는데 c언어와 비슷합니다. 포인터는 메모리 주소를 값으로 갖는 타입을 말합니다.

제네릭 프로그래밍 지금은 있지만 많이 제공하지 않습니다. 제네릭이 만드는 문제가 상당히 많습니다.

네임스페이스 없습니다. 패키지 단위로 분리됩니다. 모든 코드가 패키지 단위로 분리합니다.

```go
package main

import "fmt"

func main() {
	// 이것은 주석입니다.
	fmt.Println("Hello, go lang!")
}
```

이제 이렇게 만들면 됩니다.

```sh
go mod init (프로젝트_디렉토리/하위디렉토리)
```

실험을 위한 폴더 이름을 만드는 팁입니다.

go의 모든 코드는 package로 시작해야 합니다. 지금 코드가 호출하는 패키지를 봐야 합니다. 패키지는 코드를 묶는 단위입니다. 패키지 명은 아무거나 작성해도 괜찮습니다. 하지만 main은 특별한 의미를 갖고 있습니다. main은 프로그램 인트리포인트를 포함하는 패키지를 의미합니다. 여기서 프로그램 처리의 모든 시작점이 됩니다.

프로그램이 실행되면 디스크에서 메모리로 호출됩니다. 그리고 CPU는 메모리에서 읽습니다. 읽을 때 어디수 부터 읽을 것인가? 컴퓨터는 사실 중간에서 시작해도 괜찮습니다. 하지만 go는 main에서 지작해야 합니다. 인트리 포인트 1개입니다. 사실 이것은 대부분 프로그램에 해당합니다. main.go에서 출발해야 합니다.

`import fmt`는 `fmt`라는 패키지를 호출한 것입니다. 패키지는 코드를 묶어 놓은 단위인데 패키지에 유용한 기능을 호출합니다. 기능을 갖고 있는 패키지로 `import`합니다.

`import main`이 가능한가? 논리적으로 불가능해야 합니다. `main`은 엔트리 포인트이자 프로그램의 루트 역할을 해야 합니다.

`func`는 함수 키워드입니다. 함수를 선언 한 것입니다. 함수명은 자유롭게 작성해도 괜찮지만 `main`은 예약어와 비슷합니다. `main` 함수명은 시작점을 의미합니다. `package main`은 `main` 함수를 호출해서 해당하는 예약어를 사용하고 있다고 볼 수 있습니다.

주석은 JSDoc을 제외하고 자바스크립트와 동일합니다.

주석은 모든 곳에 만들 수 있습니다. 어떤 위치에서 작성할 수 없게 언어 차원에서 차단하는 언어도 존재합니다. 하지만 golang은 제한하지 않습니다.

`fmt.Println`는 패키지로 호출해서 호출한 패키지의 메서드를 사용한 것입니다. 패키지의 함수를 사용한 것입니다. `ln`은 줄 line을 의미합니다.

## [Tucker의 Go 언어 프로그래밍] 4장 변수 #3

변수는 중요합니다.

변수는 타입별로 값의 범위가 다릅니다.

타입은 그릇처럼 생각해볼 수 있습니다. 작은 그릇은 큰 그릇에 담을 수 있지만 반대는 불가능합니다.

255, 65535는 암기하기 바랍니다.

int, uint는 음수양수 모두 표현할지 양수만 표현할지 다릅니다. 양수 음수를 표현하려면 앞에 부호를 표시해야 하기 때문에 양수 범위가 반절입니다. 대신 음수 범위도 반입니다. 하지만 길이 자체는 같습니다.

연산할 때 타입이 같아야 합니다. 같게 만들기 위해 타입 변환을 해줘야 합니다.

타입을 go에서 자동으로 바꿔지 않고 프로그래머가 명시적으로 타입변환하도록 합니다. 프로그램에 주의를 타입으로 강제하게 만듭니다.

```go
package main

import "fmt"

func main() {
	var a int16 = 3456
	var b int8 = int8(a)

	fmt.Println(a, b) // 3456 -128
}
```

b가 -128입니다. 이유는 무엇인가?

큰 그릇의 값을 작은 그릇에 옮기는 행위입니다. 초과된 량은 버려집니다.

```
00001101_10000000 <- 16비트 3456
_________10000000 <- 8비트
```

8비트로 변환하면 앞의 메모리를 삭제합니다. 뒷부분만 남고 뒷부분 이진수(10000000)를 10진수로 표현하면 -128이 됩니다.

```go
package main

import "fmt"

var g int = 10

func main() {
	var m int = 20
	{
		var s int = 30
		fmt.Println(m, s, g)
	}
}
```

golang은 정상적인 스코프 정의가 됩니다. 스코프는 단순하게 중괄호로 표현할 수 있습니다. 억지로 함수, 반복문, 조건문에 담을 필요가 없습니다.

int의 앞에는 부호비트가 항상 있습니다.

실수를 표현할 때는 특이합니다. 컴퓨터 공학적인 특면에서 golang은 평범합니다.

부호(1비트) + 지수부(8비트) + 소수부(23비트) 이렇게 32비트를 표현합니다. 소수비와 지수부를 각각 처리해야 하기 때문에 이렇게 합니다. 소수부의 비트가 고정되어 있습니다. 사람의 생각, 수학적 개념은 무한해도 메모리의 크기는 유한합니다.

중요한 것은 소수부입니다. float32는 7자리 float64는 16자리입니다.

```go
package main

import "fmt"

func main() {
	var a float32 = 1234.523
	var b float32 = 1243.2132
	var c float32 = a * b
	var d float32 = c * 3
	fmt.Println(a, b, c, d)  // 1234.523 1243.2133 1.5347752e+06 4.604326e+06
}
```

`1.5347752e+06`으료 표시하고 있습니다. 실수연산은 오차가 발생합니다. 그 근사값을 사용합니다. 자리를 초과하면 오차가 발생하고 이 오차가 여러번 거듭하면 커집니다.

## [Tucker의 Go 언어 프로그래밍] Go언어가 온당 - OT & 4장 복습

https://www.youtube.com/watch?v=td1Y-zp5KsM

프로그래밍 입문강의입니다. 기초는 기초에서 배워야 좋습니다.

신기술이 많이 나옵니다. 기초는 기초 단계가 아니면 배우기 어렵습니다. 기초가 없으면 응용하기 어렵습니다. 응용을 먼저하고 기초를 나중에 배우자는 안일한 생각하기 쉽습니다. 나중에 힘듭니다.

복습입니다. 컴퓨터는 우아하지만 본질은 단순합니다. 컴퓨터는 기계입니다. 기술과 이론은 복잡해보이지만 시작은 단순합니다. 단순함을 이해하고 그 위해 응용을 쌓아올리면 수월합니다.

컴퓨터는 단순하는 것에 시작합니다. 이것을 보고 부트스트랩이라고 합니다. 돌로 청동을 만들고 청동으로 철을 만든 발전이 의외로 단순합니다. 기반에서 응용으로 발전하는 것을 보고 부트스트랩단계라고 합니다.

트렌지스터는 스위치에서 컴퓨터가 시작합니다. 트렌지스터로 논리소자를 만듭니다. 논리소자로 계산기를 만듭니다. 계산기를 만들어서 명령으로 프로그래밍이 가능한 계산기가 컴퓨터의 원류가 됩니다.

컴퓨터를 보면 지금은 내부구조가 복잡해보입니다. 사실은 필요와 편의를 위해 만들어진 것입니다. 시작했을 때의 단순한 모습을 이해하기 위해 노력하도록 합니다.

변수는 바뀌는 숫자를 의미합니다. 이것은 수학적 용어입니다. 프로그래밍적 의미는 다릅니다. 컴퓨터는 특정한 값을 저장하는 공간을 가리키는 이름입니다.

데이터는 숫자, 문자, 소리, 이미지 등 다양합니다. 컴퓨터는 결국에 아는 것은 0과 1입니다. 이 데이터를 0과 1로 바꿔야 합니다. 인간이 보기에는 데이터 분류된 것이 자연스럽습니다.

데이터는 메모리 저장하고 접근할 수 있습니다. 변수는 이 메모리 공간을 가리킵니다. 이 공간을 주소로 그대로 보여주지 말고 이름으로 보여줘서 사람이 이해하기 쉽게하도록 합니다.

변수는 중요합니다. 프로그래밍은 결국에는 데이터(변수)를 조작하는 일입니다.

이미지 영상을 처리할 때 컴퓨터는 비디오 메모리가 있고 이것을 처리하는 것입니다. 이것을 조작하는 것은 비디오 메모리를 조작하는 것입니다.

조작하는 기본은 변수를 통해서 시작합니다. 데이터는 메모리 저장되어 있고 데이터를 접근할 때는 변수로 접근하기 때문입니다.

```go
var a int = 10
```

코드에서 선언이 필요한 이유입니다. 데이터를 조작하고 싶으면 먼저 데이터를 저장해야 합니다.

변수 선언 없는 언어도 신기하게 존재합니다.

변수명은 한글을 사용할 수 있는데 영문이 편할 것입니다.

언더스코어 특수문자를 앞에 붙일 수 있는데 용도는 나중에 알려주겠습니다.

자료형은 숫자(정수, 실수), 문자 등이 있는데 타입은 변수 선언할 때 메모리 사이즈 정의가 같이 포함됩니다.

프로그래밍에서 =은 할당 연산자입니다. 그리고 비교연산자도 ==입니다. 엄밀비교 약한비교는 없습니다. 좌변은 메모리 공간이고 우변은 데이터입니다.

대입연산으로 값을 재할당하는 것은 그냥 하면 됩니다.

변수는 4가지 속성이 있습니다. 이름, 값, 주소, 타입입니다. 프로그래머가 제어할 때는 이름이 중요합니다. 컴퓨터에게 이름은 의미가 없습니다.

컴퓨터는 메모리 주소는 16진수로 표현합니다. 0 ~ 9와 a ~ f까지 사용합니다. 메모리 주소를 접근해서 해당하는 주소에 데이터를 제어할 수 있게 됩니다.

변수에는 메모리 주소를 접근하는데 정확히 메모리 시작 주소입니다. 메모리 순서대로 확보합니다.

타입은 확보해야 할 공간을 정합니다.

시작주소와 공간 크기를 알면 읽을 대상을 알 수 있습니다.

go는 강타입언어입니다.

숫자타입에 앞에 u가 붙으면 양의 정수를 의미하는데 부호가 사라졌다는 의미입니다. 타입접미어로 붙은 숫자는 비트를 나타냅니다. 바이트 단위 아닙니다. 하지만 8, 16, 32, 64는 바이트 단위로 키웁니다.

소수점이 존재하는 실수형은 32, 64가 있습니다.

byte는 uint8의 별칭입니다.

rune은 int32랑 같은 타입입니다. utf-8을 문자인코딩에 사용하는데 문자 1개가 1 ~ 3바이트의 가변길입니다. rune은 고정시키기 위해 4바이트로 문자 1개를 저장하기 위한 별칭 타입입니다.

접미어로 뒤에 숫자가 없으면 컴퓨터 비트를 기준으로 정합니다. 32비트 컴퓨터, 64비트 컴퓨터에 따라 다릅니다. 이 32, 64는 레지스터 사이즈라고 합니다. CPU가 연산하기 위해 연산자를 보관하는 공간입니다. 한번 연산에 올라가는 크기를 기준으로 잡습니다.

부울타입이 있습니다. 부울은 조지 부울이 만든 논리대수 부울대수의 창시자의 이름을 따온 것입니다.

문자열은 문자들이 모여있는 것이 문자열입니다. 문자 개별로 구분하는 언어도 있습니다.

배열은 같은 타입 여러개가 모여있는 것입니다.

슬라이스는 동적 배열입니다. go가 제공하고 중요한 자료형입니다.

구조체는 여러개의 필드를 모읍니다. 나이, 이름, 학력 등 사람을 모으고 정리한 것입니다.

포인터는 다른 변수를 가리키는 변수입니다. 특정 변수를 가리키도록 만들 수 있습니다.

함수타입은 함수를 가리킵니다.

맵, 인터페이스, 채널도 다룹니다.

정수는 0, 실수는 0.0, 부울은 false, 문자열은 빈 문자열(""), 이외 모두 nil로 메모리 주소가 없다고 표현합니다.

c언어는 참은 1 거짓은 0으로 표현합니다. 하지만 go는 구분하고 숫자로 대입하지 않습니다. 대입을 지원하는 언어도 은근히 많습니다. c언어가 권위와 유산입니다.

complex64, complex128도 존재합니다. 이것은 복소수를 표현할 수 있습니다. 진수와 가수 실수 2개를 합친 개념이라고 볼 수 있습니다. 수학 분야 프로그래밍에서 활용하고 일반적인 웹 어플리케이션 분야는 거의 활용할 경우는 별로 없습니다.

왜 메모리 타입을 다양하게 지원하는가? 메모리 사이즈를 아끼기 위해 사용할 수 있습니다.

부모없는 정수로 1, 2, 4 바이트(255, 65535, 42억)는 모두 암기하는게 편합니다.

8바이트를 초과하려면 국가회계 혹은 천문학 분야일 가능성이 큽니다.

실수표현은 float32의 경우 부호(1비트), 지수부(8비트), 소수부(23비트)입니다.

지수표현과 일반표현이 있습니다. 지수표현은 실수를 표현하기 수월합니다. 10의 몇승으로 제곱으로 표현합니다. 지수부는 10의 제곱수를 표현할 수 있습니다.

32는 7자리, 64는 15자리를 소수의 자리수를 잘 암기하는 것이 중요합니다.

## [Tucker의 Go 언어 프로그래밍] 5장 fmt패키지를 이용한 표준입출력

fmt 패키지를 다룹니다. 이 패키지는 계속 다룰 것이기 때문에 먼저 다룰 것입니다. 그리고 입출력 중 표준 입출력을 이해해볼 것입니다.

다른 언어 전에 표준입출력을 이해하기 위한 시간입니다.

표준 입출력입니다. 프로그램이 있습니다. 프로그램은 사용자와 입출력으로 대화합니다. 사용자가 키보드, 마우스로 입력하면 피드백으로 화면과 사운드로 돌려줍니다. 이것은 일반적인 게임에서 자줄 볼 수 있을 것입니다. 또 게임이 온라인이라면 출력이 네트워크로 나가고 돌아올 것입니다.

하지만 우리는 표준이 되는 입출력을 다룹니다. 표준입출력을 이해하기 위해서는 초기 컴퓨터를 이해해야 합니다. 컴퓨터는 처음에는 천공카드 구멍으로 처리했습니다. 천공카드 구멍을 활용해서 코드를 작성했습니다. 히든 피겨스는 나사의 프로그래머들입니다. 옛날에 프로그래밍은 여성이 많이 했습니다. 초기 프로그래머는 여성이 꽤있었습니다.

구멍을 잘못 뚤었으면 디버깅하기 어려웠습니다.

입력은 천공카드의 구멍이 빛이 통과하고 말고로 제어했습니다. 초기 컴퓨터는 이런 천공카드가 입력장치가 표준이었고 출력도 하나였습니다. 표준입력장치가 카드로 입력하고 CPU가 처리하고 프린터가 출력했습니다. 천공카드가 표준입력이고 프린터가 표준출력입니다.

시간이 지나 지금은 키보드가 표준입력에 해당합니다. 출력도 모니터가 표준출력이 됩니다. 입력과 출력 기구는 바뀌지만 입출력과 출력의 과정에 해당하는 통로는 계속 같습니다.

리눅스를 사용하면 입출력을 라다이렉팅으로 모니터에 나와야 할 것을 프린터로 가게 만들 수 있습니다.

0과 1의 흐름이 컴퓨터에 입력되는데 이 흐름을 보고 비트스트림이라고 합니다. 스트림을 직역하면 시냇물이라고 합니다. 즉 물이 흐르는 것처럼 데이터가 흐른다는 의미로 이해해도 됩니다. 그냥 스트림이라고 해도 괜찮은게 과거에는 비트 스트림이지만 지금은 바이트 단위로 하기 때문에 바이트 스트림이라고 부르기도 합니다.

표준 출력함수입니다. fmt 패키지로 접근할 수 있습니다. 3개가 있습니다. Print(), Println(), Printf()입니다. Print는 단순 출력합니다. Println은 출력 후 개행합니다. Printf는 서식에 맞춰서 출력한다는 의미입니다.

키보드는 타자기에서 따온 것입니다. 개행은 타자기로 종소리를 내면서 밀어넣는 동작을 봤을 것입니다. 이 동작을 보고 개행이라고 합니다.

```go
package main

import "fmt"

func main() {
	var a int = 10
	var b int = 20
	var f float64 = 32799438743.8297
	fmt.Print("a:", a, "b:", b, "f:", f)
	fmt.Println("a:", a, "b:", b, "f:", f)
	fmt.Printf("a: %d b: %d f: %f \n", a, b, f)
}

// a:10b:20f:3.27994387438297e+10a: 10 b: 20 f: 3.27994387438297e+10
// a: 10 b: 20 f: 32799438743.829700
```

이렇게 됩니다.

Print는 개행이 포함되어 있지 않습니다. 또 사이에 빈칸도 없습니다. 여기도 실수를 지수로 표현합니다.

Println은 개행해주고 입력한 인자마다 빈칸을 사이에 넣어줍니다. 지수표현합니다.

Printf는 포매팅을 해줍니다. d는 정수를 표현합니다. 또 f는 소수로 표현해줍니다. 지수 표현을 하지 않습니다. 여기서 개행은 같이 작성했습니다.

d는 decimal로 10진수를 의미합니다. 영문으로 자릿수를 의미하기도 합니다.

서식은 %으로 표현하고 순서대로 들어갑니다.

%v는 기본 형태로 출력합니다. %T은 타입을 출력합니다. %t은 부울리안을 표현합니다. %b는 이진수로 출력합니다. %e 지수로 출력합니다. %f는 실수로 출력합니다.

%g는 출력해야 하는 길이가 크면 지수로 출력하고 작으면 실수로 출력합니다. 기준은 6자리입니다.

%q는 특수문자 동작을 제거합니다.

%(숫자)(형식)을 볼 수 있습니다. 여기서 숫자는 칸수입니다.

%0(숫자)(형식)이렇게 하면 빈공간을 0으로 채우라는 뜻입니다.

%-(숫자)(형식)은 왼쪽으로 정렬하도록 합니다. 여기서 %-0(숫자)(형식)에서 0은 의미 없습니다.

암기 중요하지 않고 혼란스럽지 않은 것이 중요합니다.

참고로 자릿수를 넘어가면 넘어가는데로 출력합니다.

%f는 6자리까지 표현합니다.

%g는 6자리 넘으면 지수로 표현합니다.

실수 타입 %v로 출력하면 기본은 %g로 동작합니다.

Println은 타입별로 %v로 모두 처리합니다. 각자의 타입별로 동작하게 합니다.

이스케이프 캐릭터는 \입니다.

표준출력은 fmt 패키지에서 제공합니다. 기본적으로 터미널입니다. 프로그래밍 외적으로 바꿀 수 있습니다.

fmt 패키지로 표준입력도 다룰 수 있습니다. Scan, Scanln, Scanf입니다. 표준입력, 표준 한줄, 표준 형식입니다. 하지만 Scanln을 그나마 자주 사용합니다.

```go
func fmt.Scanln(a ...any) (n int, err error)
```

Scanln 메서드 위에 마우스를 올리고 정보를 확인할 수 있습니다. n이 정수형이고 error는 error 값입니다.

```go
package main

import "fmt"

func main() {
	var a int
	var b int

	n, err := fmt.Scanln(&a, &b)
	if err != nil {
		fmt.Println(err)
	} else {
		fmt.Println(a, b, n)
	}
}
```

a, b는 0이 됩니다. 기본값이 할당됩니다. 중요한 것은 &입니다. 이 &이 중요합니다. a, b를 입력받는데 변수 앞에 &을 넣으면 그 변수의 메모리 주소값을 나타냅니다.

사실 언어마다 다르지만 go는 기본적으로 인자로 대입하게 되면 모든 변수(지금은 a, b)는 Rvalue 즉 할당 연산의 오른쪽의 값으로 대입하게 됩니다. 그렇다면 &을 제거하면 모두 자동으로 0이 대입될 것입니다.

&a, &b로 대입하게 되면 주소를 대입한 것입니다. 우리가 이 주소에 키보드로 입력한 값을 메모리에 작성하게 한 것입니다.

입력 버퍼입니다. 표준입력과 표준출력이 있고 이 사이는 데이터의 흐름 비트 스트림으로 들어가고 나옵니다. 흐름에 따라 문자열, 파일, 프린트가 될 수 있습니다.

비트스트림이 들어오면 잠시 보관하는데 이 보관하는 장소를 보고 버퍼라고 합니다. 지금 맥락에서는 입력버퍼라고 합니다. 버퍼는 메모리 공간을 확보하고 값을 작성할 수 있는 공간을 보고 버퍼라고 합니다. 임시저장소라고 할 수 있습니다.

예를 들어 Scanln에 hello 4라고 키보드 입력을 합니다.

h는 숫자가 아니기 때문에 첫번째 인자는 실패해서 에러가 발생합니다. 그 뒤부터 버퍼를 읽지 않습니다. 문제는 버퍼에 ello가 남아있습니다.

실패하면 입력버퍼를 비워야 합니다. 입력 버퍼를 비우는 작업을 시도해보겠습니다.

```go
package main

import (
	"bufio"
	"fmt"
	"os"
)

func main() {
	stdin := bufio.NewReader(os.Stdin) // Stdin을 의미함
	var a int
	var b int

	n, err := fmt.Scanln(&a, &b)
	if err != nil { // err에 메모리 주소가 할당 된 경우 아래를 실행
		fmt.Println(err)
		stdin.ReadString('\n') // 개행문자까지 버퍼에서 읽기 -> 버퍼를 읽는 행위로 비움
	} else {
		fmt.Println(a, b, n)
	}

	n, err = fmt.Scanln(&a, &b)
	if err != nil { // err에 메모리 주소가 할당 된 경우 아래를 실행
		fmt.Println(err)
		stdin.ReadString('\n') // 개행문자까지 버퍼에서 읽기 -> 버퍼를 읽는 행위로 비움
	} else {
		fmt.Println(a, b, n)
	}
}
```

go는 변수를 선언하면 반드시 사용해야 합니다.

앞으로 키보 입력을 받으면 버퍼를 비우는 행동을 해야 한다는 것을 기억하기 바랍니다.

## [Tucker의 Go 언어 프로그래밍] 6장 연산자

https://www.youtube.com/watch?v=XfpoLirYZm8

연산자는 계산을 표시하는 문자를 의미합니다. 사칙연산이 기본입니다. 컴퓨터가 하는 일은 데이터를 계산, 조작하는 일입니다. 변수와 연산자를 활용하면 많은 프로그래밍이 가능합니다. 여기서 조건문만 있으면 모든 코딩은 가능합니다. 이외의 것은 부가적입니다.

현대 프로그래밍 언어는 유용한 것을 잘 제공해주고 잘 활용해서 높은 생산성을 갖는 것이 중요합니다.

산술연산자가 있습니다. 사칙연산(`+`, `-`, `*`, `/`)과 나머지(%)난 일상에서 자주 볼 것입니다.

연산자는 피연산자를 연산합니다. 피연산자는 데이터입니다. 어떤 데이터를 갖는 것에만 연산할 수 있습니다.

참고로 문자열끼리 `+`로 합산연산이 가능합니다. 하자만 문자열에 다른 연산자를 사용할 수 없습니다.

비트연산자 모두 정수만 사용할 수 있습니다.

비트연산자는 4개지만 크게 3개로 볼 수 있습니다.

AND는 2개의 비트 모두 1을 받아야 1이 나오게 만들 수 있습니다.

```go
package main

import (
	"fmt"
)

func main() {
	a := 10
	b := 34
	c := a & b // 여기서 & and입니다.
	fmt.Printf("%d %016b\n", a, a)
	fmt.Printf("%d %016b\n", b, b)
	fmt.Printf("%02d %016b\n", c, c)
}

// 10 0000000000001010
// 34 0000000000100010
// 02 0000000000000010
```

이렇게 이해가 가능합니다. 비트연산을 하면서 모두 포함한 경우에 해당합니다.

```go
package main

import (
	"fmt"
)

func main() {
	a := 10
	b := 34
	c := a | b // 여기서 | or 연산자
	fmt.Printf("%d %016b\n", a, a)
	fmt.Printf("%d %016b\n", b, b)
	fmt.Printf("%02d %016b\n", c, c)
}

// 10 0000000000001010
// 34 0000000000100010
// 42 0000000000101010
```

```go
package main

import (
	"fmt"
)

func main() {
	a := 10
	b := 34
	c := a ^ b // 여기서 ^ xor 연산자
	fmt.Printf("%d %016b\n", a, a)
	fmt.Printf("%d %016b\n", b, b)
	fmt.Printf("%02d %016b\n", c, c)
}

// 10 0000000000001010
// 34 0000000000100010
// 40 0000000000101000
```

^은 언어에 따라 다르지만 승수라고 의미하기도 합니다. go는 승수를 math 패키지로 접근해서 활용해야 합니다.

```go
package main

import (
	"fmt"
)

func main() {
	a := 10
	b := 2
	c := a &^ b // 여기서 ^ xor 연산자
	fmt.Printf("%d %016b\n", a, a)
	fmt.Printf("%d %016b\n", b, b)
	fmt.Printf("%02d %016b\n", c, c)
}

// 10 0000000000001010
// 02 0000000000000010
// 08 0000000000001000
```

비트클리어 연산자입니다.

and와 xor 연산자를 사용하는데 먼저 xor를 먼저 실행합니다. xor는 피연산자가 없으면 비트 반전을 합니다. 즉 0은 1이고 1은 0이 됩니다.

비트 반전한 값을 and 연산을 해서 결과를 얻습니다.

34를 비트반전하고 비트반전된 34를 10과 and 연산을 통해 8을 구하게 된 것입니다.

비트클리어인 이유는 특정비트를 0으로 만들수 있기때문입니다. 지금은 2번째 칸을 비웠습니다.

열거값을 비트 플래그를 활용합니다. 비트조작에 비트연산자를 활용합니다. 상수와 열거값을 활용할 때 알게 됩니다.

---

시프트 연산자는 왼쪽 오른쪽 비트를 밀어버릴 때 사용합니다.

```go
10       // 0000 0000 0000 1010
10 << 2  // 0000 0000 0010 1000
```

2칸 밀어낸 것입니다.

1칸에 2입니다. 2배가 됩니다. 2의 승수 1개가 올라가기 때문에 그렇습니다.

하지마 무조건 그렇게 동작하지는 않습니다.

```go
127 // 0111 1111
127 << 1 // 1111 1110
```

지금 예시에서는 시프트 연산이 음수를 만들게 됩니다.

```go
package main

import "fmt"

func main() {
	var x int8 = 4
	var y int8 = 64

	fmt.Printf("x: %08b x << 2: %08b x << 2: %d\n", x, x<<2, x<<2)
	fmt.Printf("y: %08b x << 2: %08b y << 2: %d\n", y, y<<2, y<<2)
}

// x: 00000100 x << 2: 00010000 x << 2: 16
// y: 01000000 x << 2: 00000000 y << 2: 0
```

이렇게 왼쪽 이동이 가능합니다.

시프트는 범위를 초과하면 값을 잃고 오히려 작아집니다.

오른쪽 시프트는 이것의 역을 생각하면 됩니다. 하지만 무조건 역은 아닙니다.

```go
package main

import "fmt"

func main() {
	var x int8 = 16
	var y int8 = -128
	var z int8 = -1
	var w uint8 = 128

	fmt.Printf("x: %08b x >> 2: %08b x >> 2: %d\n", x, x>>2, x>>2)
	fmt.Printf("y: %08b y >> 2: %08b y >> 2: %d\n", uint8(y), uint8(y>>2), y>>2)
	fmt.Printf("z: %08b z >> 2: %08b z >> 2: %d\n", uint8(z), uint8(z>>2), z>>2)
	fmt.Printf("w: %08b w >> 2: %08b w >> 2: %d\n", w, w>>2, w>>2)
}

// x: 00010000 x >> 2: 00000100 x >> 2: 4
// y: 10000000 y >> 2: 11100000 y >> 2: -32
// z: 11111111 z >> 2: 11111111 z >> 2: -1
// w: 10000000 w >> 2: 00100000 w >> 2: 32
```

최상위 비트 즉 부호비트가 양수면 0으로 채워지고 음수 1이면 1로 채워집니다.

uint의 경우 부호가 없기 때문에 자동으로 0으로 채웁니다.

시프트는 생각보자 자주 사용하는 상황이 없습니다. 비트조작에 사용합니다.

go의 비교연산자는 정상적입니다. 비교연산에 엄밀비교 약한비교 이런거 없습니다.

정수 오버플로우입니다.

```go
package main

import "fmt"

func main() {
	var x int8 = 127
	fmt.Printf("%d < %d+1: %v\n", x, x, x < x+1) // 127 < 127+1: false
}
```

수학에서 값을 더하면 무조건 더 커집니다.

하지만 컴퓨터에서는 메모리의 유한한 크기 때문에 그렇지 않습니다. 타입이 메모리상 존재하는 공간상 양수 최대값에 1을 더하면 0이 됩니다.

```go
package main

import "fmt"

func main() {
	var x int8 = 127

	fmt.Printf("%d < %d+1: %v\n", x, x, x < x+1)
	fmt.Printf("x\t = %4d, %08b\n", x, x)
	fmt.Printf("x+1\t = %4d, %08b\n", x, uint8(x+1))
}

// 127 < 127+1: false
// x        =  127, 01111111
// x+1      =  127, 10000000
```

127에서 1을 더하면 -128로 가장 작은 값에서 출발하게 됩니다. 정수 오버플로우 현상이라고 합니다.

실수 오차입니다. 수학의 정의와 다른 오차가 존재합니다.

```go
package main

import "fmt"

func main() {
	var a float64 = 0.1
	var b float64 = 0.2
	var c float64 = 0.3
	fmt.Printf("%f %f === %f : %v\n", a, b, c, a+b == c)
}

// 0.100000 0.200000 === 0.300000 : false
```

지금 소수부가 전부는 안보입니다. 소수의 자리수는 수학에서는 무한하고 위 조건은 참이되어야 합니다.

컴퓨터에서는 다릅니다. 이것도 메모리의 유한함 때문입니다.

```go
package main

import "fmt"

func main() {
	var a float64 = 0.1
	var b float64 = 0.2
	var c float64 = 0.3
	fmt.Printf("%f %f === %f : %v\n", a, b, c, a+b == c)
	fmt.Println(a + b) // 0.30000000000000004
}
```

이렇게 확인해보면 당연히 다릅 값입니다. 뒤에 4가 붙은 이유는 실수표현할 때 자리수를 초과하면 근사값으로 처리하기 때문입니다. 컴퓨터는 0.3을 표현할 수 없고 가장 가까운 수로 표현하기 때문에 그렇습니다.

이진수 즉 비트로 실수표현식으로 표현하기에 한계가 있습니다. 완벽하게 극복할 수 없습니다. 이진수가 무한할 수 없습니다. 컴퓨터로 완벽한 표현을 불가능하고 비슷한 표현은 가능합니다. 갖고 있는 비트 중 가장 가까운 수를 표현하는 것입니다.

이런 오차를 극복하는 것이 실수표현식에서 계산을 처리하는 관건입니다.

```go
package main

import (
	"fmt"
	"math"
)

func equal(a, b float64) bool {
	return math.Nextafter(a, b) == b
}

func main() {
	var a float64 = 0.1
	var b float64 = 0.2
	var c float64 = 0.3
	fmt.Printf("%0.18f == %0.18f : %v\n", c, a+b, equal(a+b, c))
}
// 0.299999999999999989 == 0.300000000000000044 : true


```

Math 패키지의 Nextafter는 1비트 다음인지 알려줍니다.

```go
math.Nextafter(0.299999999999999989, 0.300000000000000044) == 0.300000000000000044
```

실수 오차를 이렇게 보정할 수 있게 됩니다.

논리연산자는 정상적입니다. 양쪽이 부울타입이면 사용할 수 있습니다.

대입연산자는 생각보다 우아하게 사용하는 방법도 있습니다.

```go
a = 30
x, y = 3, 4
```

이런 응용도 가능합니다.

```go
a, b = b, a
```

이렇게 되면 좌변은 주소이고 우변은 값입니다. 그래서 이렇게 되면 서로 값을 교환하는 방법입니다.

복합대입연산자도 정상적입니다. 하지만 몇가지 확장이 있습니다. `%=`, `^=`, `|=`, `<<=`, `>>=` 이런 나머지 연산할당도 가능하고 또 비트 연산할당도 가능합니다.

`++`, `--` 증감연산자도 존재합니다.

go는 전위증감 후위증감 같은 혼선을 유발할만한 것은 없습니다. ++는 값을 반환하지 않습니다.

대입연산자는 값을 반환하지 않습니다.

이외 연산자는 나중에 만나면서 설명하겠습니다.

연산자는 우선순위가 있습니다.

## [Tucker의 Go 언어 프로그래밍] 7장 함수

https://www.youtube.com/watch?v=0quO6sYoowQ

function은 기능이라는 뜻도 있습니다.

수학적 함수는 어떤 입력이 있으면 처리하고 출력이 있습니다. $f(x) = 2x + 5$ 을 보면 x에 2를 대입하면 9를 기대할 수 있습니다.

수학적 변수와 프로그래밍적 변수는 다릅니다. 함수도 비슷합니다. 수학적 함수와 프로그래밍적 함수는 다릅니다. 또 프로그래밍 언어별로 또 다릅니다.

함수형 언어는 수학적 정의에 가까우고자합니다.

일반적인 프로그래밍 언어는 수학적 정의의 함수와 다릅니다.

```go
func add(a int, b int) int {
  return a + b
}
```

함수 정의할 때 사용 전에 정의해야합니다. c언어는 먼저 정의해야 하지만 go는 어디에 정의해도 상관없습니다.

func은 함수 정의 키워드입니다. 함수이름은 변수랑 규칙이 동일합니다.

매개변수는 함수 정의에서 다루는 변수입니다. 호출하고 대입하면 인자라고 부릅니다.

go는 반환타입도 지정해줘야 합니다.

함수는 반환타입을 지정하는 다음 위치에 중괄호로 함수 블록을 만들 수 있습니다.

```go
package main

import (
	"fmt"
)

func add(a int, b int) int {
	return a + b
}

func main() {
	c := add(3, 6)
	fmt.Println(c) // 9
}
```

이렇게 사용할 수 있습니다.

```go
package main

import (
	"fmt"
)

func main() {
	c := add(3, 6)
	fmt.Println(c)
}

func add(a int, b int) int {
	return a + b
}
```

go는 이렇게 순서 무관하게 정의할 수 있습니다.

수학적함수와 프로그래밍적 함수는 어떻게 다른가?

어떤 개념을 볼 때 왜 만들어졌는지 보면 이해가 수월합니다.

프로그램이란 하나의 긴 문서입니다. 입력할 때는 순서대로 입력합니다. CPU 내부에서는 하나의 거대한 종이를 순서대로 읽는 것입니다.

반복되는 부분을 읽는 부분으로 보내고 끝나면 돌아오게 만들면 작업이 더 효율적이지 않을까?

이런 관점에서 생겼을 수 있습니다.

컴퓨터가 IP 즉 instruction point 혹은 PC programming count가 있습니다. 명령을 몇번째 줄을 실행해야 하는지 나타내는지 알려주는 정보입니다. 읽는 중간에 IP로 읽을 곳을 바꾸고 끝나면 읽던곳을 알려주면 만들 수 있습니다. 이것을 보고 jump라고 합니다.

처음에는 호출하면 향할 위치을 알려줄 수 있는데 돌아갈 때 어떻게 알 수 있는가? 즉 50번째 줄에서 1500줄로 갔는데 끝나면 51로 어떻게 돌아갈 수 있는가? 방법은 점프 전에 return point를 기록하고 점프하면 됩니다. 그래서 원래 읽던 곳은 return point라고 부릅니다.

이렇게 하면 반복하는 동작을 자동화할 수 있게 되었습니다.

하지만 문제가 생겼습니다. 모든 동작이 모두 완전히 동일하지 않았습니다. 아주 조금만 동작이 달랐던 경우가 있습니다.

이 한계를 극복하기 위한 방법입니다. 먼저 메모리 공간 하나에 return point를 기록부터 시작합니다. 그리고 다른 메모리 공간에 필요하게 조금 바뀌는 부분에 해당하는 값을 기록하고 점프합니다. 그리고 점프하고 실행하고 끝나면 호출했던 곳으로 돌아합니다.

하지만 문제가 또 발생합니다. 점프하기 전에 기록해야 하는 매개변수에 해당하는 값이 유동적으로 바뀌기 시작했습니다. return point는 계속 기록합니다. 링크드 리스트로 값과 보고 있는 방향을 설정합니다. pop하면서 할당하고 처리하고 결국 돌아게 합니다. call stack이라는 부분이 됩니다.

프로그램에서 함수는 반복하는 작업을 줄여주기 위해서 생겨난 것입니다. 함수를 call을 하면 돌아갈 위치를 기록합니다. 값을 기록합니다. 값은 링크리스트로 기록합니다. 입력은 정방향 값을 읽을 때는 역방향 최근에 추가한 순서대로 읽습니다.

값을 넣는 것을 push라고 하고 값을 읽고 제거하는 것을 보고 pop이라고 합니다.

선입후출 구조를 갖습니다.

함수의 관건은 반복을 줄이는 것입니다. 함수는 결국에는 코드 블럭입니다. 기능과 동작을 나타내는 블럭 단위입니다.

golang은 멀티 반환함수를 지원합니다.

```go
package main

import (
	"fmt"
)

func main() {
	c, success := divide(9, 3)
	fmt.Println(c, success)
	d, success := divide(9, 0)
	fmt.Println(d, success)
}

func divide(a, b int) (int, bool) {
	if b == 0 {
		return 0, false
	} else {
		return a / b, true
	}
}

// 3 true
// 0 false
```

go는 같은 타입이 연속되면 위 예시처럼 묶을 수 있습니다.

하지만 여기서 의문이 생겨야 합니다. success는 이미 정의한 변수입니다. 첫번째 반환값은 중복 선언할 수 없지만 두번째 반환값은 허용합니다. 이것은 golang의 선언 대입문과 반환값의 특징입니다.

golang은 출력값에 이름을 지정할 수 있습니다.

```go
package main

import (
	"fmt"
)

func main() {
	c, success := divide(9, 3)
	fmt.Println(c, success)
	d, success := divide(9, 0)
	fmt.Println(d, success)
}

func divide(a, b int) (result int, success bool) {
	if b == 0 {
		result = 0
		success = false
	} else {
		result = a / b
		success = true
	}
	return
}

// 3 true
// 0 false
```

이렇게 반환할 값이 여러개일 때 출력부에 변수를 정의하고 할당하고 반환할 수 있습니다. 이렇게 이름을 작성하면 return을 생략해야 합니다.

재귀호출입니다. 재귀호출은 자기자신을 호출하는 것을 의미합니다.

```go
package main

import (
	"fmt"
)

func main() {
	printNo(3)
}

func printNo(n int) {
	if n == 0 {
		return
	}
	fmt.Println(n)
	printNo(n - 1)
	fmt.Println("after", n)
}

// 3
// 2
// 1
// after 1
// after 2
// after 3
```

3 -> 2 -> 1 -> 2 -> 3 순서를 잘 보도록 합니다. Println 다음에 재귀호출하고 재귀호출이 끝나면 다시 Println 순서가 됩니다. 점점 내려갔다가 다시 올라오게 됩니다.

재귀함수에서 가장 주의할 점은 베이스 케이스 즉 종료조건이 중요합니다. 안 끝나면 무한합니다.

재귀호출하는데 함수는 결국에 메모리 일부를 활용하는데 메모리 공간은 유한한데 만약에 실수로 종료조건이 없는 함수는 메모리를 모두 채울 때까지 실행합니다. 물론 모던 프로그래밍 언어는 어느 콜스택 사이즈를 초과하면 중단시켜줍니다.

go는 자동증가되는 stack입니다. 특이합니다. 일부언어는 스택이 고정되어 있습니다. go는 자동 증가되기 때문에 메모리 고갈전까지 계속 증가합니다.
