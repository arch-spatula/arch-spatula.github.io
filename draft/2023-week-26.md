## 23.06.30.

## 분기 회고

- [ ] CS 지식 플래시카드로 정리하기
- [ ] 네이버 지식백과 전선학 개론 1회독
- [x] 유데미 자료구조 & 알고리즘 완강
- [x] 개발자 블로그 개발 완료하기

### Liked

- 유데미 자료구조 알고리즘 강의를 완강했습니다. 지난분기에 달성해야 할 작업을 이번 분기에 달성했습니다.
- 개발자 블로그를 보여줄 만하게 발전했습니다.
- 생활이 규칙적이게 되기 시작했습니다. 예비군을 다녀오고 일찍 일어나는 습관을 들이기 시작했습니다.

### Learned

- 기초의 방향을 바꿨습니다. 실제 코드를 작성하고 작성한 코드를 잘 정리하는 것을 기초의 방향을 바꿨습니다.
  - 회사마다 편차가 극단적으로 클 것이기 때문에 나중에 해도 괜찮고 이직할 때 다시 배워야 한다고 생각하고 있었습니다. 이 가설은 기각해야 합니다.
- 코드 퀄리티를 높이기 위한 제약을 두는 방법을 배웠습니다.

### Lacked

- 4월은 리팩토링을 읽기 시작했습니다. golang 컨프런스도 다녀왔습니다. 이력서도 어느정도 작성했지만 한참 부족한 이력서입니다.
- 5월은 중순에 지원을 중단했습니다. 보여줄 수 있는 실력이 너무 없었습니다.
- 6월은 프로젝트 전념하기로 하고 시간을 보냈습니다. 하지만 그렇게 해도 작업을 완료하지 못했습니다.

### Longed(잘하기 위해 필요한 것)

- 현재 플래시카드 포트폴리오를 완수해야 합니다. 실제 서비스처럼 남들에게 보여줄 수 있는 수준이 되어야 합니다.
  - 기능이 단순하기 때문에 코드 퀄리티가 높아야 합니다.
- 플래시카드 프로젝트 1.0.0-alpha를 배포하고 이력서 작성을 다시 해야 합니다.
- 이력서부터 대폭 수정해야 합니다.
  - 비즈니스 목적의 이유는 무엇이고 달성하려는 수단을 서술하는 방식으로 접근해야 합니다.
  - 기술적으로 특이한 문제를 해결한 경험도 서술해야 합니다.
- 실력이 없기 때문에 실력을 얻고 보여줘야 합니다.
- 규칙적인 생활을 시작하고 집중하고 작업하는 시간을 늘려야 합니다.
- 면접 준비를 더 잘하기 위해서 진행했던 프로젝트들에 대해서 잘 정리해야 합니다.
  - 모의 면접은 CS 지식 비중이 많습니다. 이력서 검토 시간이 짧으면 갖는 경향이라고 추정됩니다.
  - 이력서를 검토할 수 있는 시간이 길면 프로젝트 관련 질문 비중이 높아질 것이라고 추정됩니다.
- 아키텍쳐 능력을 길러야 합니다.
  - 코드리뷰는 코드의 상당히 미시적인 부분을 다룹니다.
  - 코드의 거시적인 검토능력을 길러야 합니다.
- 다시 코딩테스트를 공부해야 합니다. 이론으 잘 이해하는 것은 개인적으로는 중요하다고 생각하지만 회사는 문제를 맞추는 것을 더 중요시합니다.

### Action Item

- [ ] 이력서 재작성
  - 코드 스플릿팅
  - 절대 버튼?
  - 카드 컴포넌트 등...
- [ ] 포트폴리오 큐레이션 만들기
  - 지금까지한 프로젝트와 또 앞으로 하게 될 프로젝트를 정리하기
  - 물론 양보다 질로 접근해야 합니다.
  - 포트폴리오를 노션, 블로그, SSG 배포 페이지로 만들지는 맥락에 맞춰서 만들기
- [ ] 블로그 확장
  - 확장하면 고급자료 특이한 경험부터 정리하기 시작하기
    - 면접관에게 인사이트 혹은 기술적인 문제를 수월하게 풀수 있게 가치 제공해보기
- [ ] 플래시카드 앱 1.0.0-alpha 배포
  - 배포 후에 리팩토링
  - 백엔드 포팅
  - 프론트엔드 테스트 코드 추가

## 날짜 변환 디버깅

이 디버깅은 서버에 문자열 리소스를 생성해서 제출했기 때문에 발생했던 문제였습니다. 아직 데이터 규모가 작아서 데이터 스크러빙으로 해결했습니다.

여기서 얻을 수 있는 교훈 중 하나는 데이터 정제 작업도 중요합니다. 클라이언트가 정제된 데이터를 제공하는 것이 좋지만 유일하지 않습니다.

서버에서도 정제작업을 처리하고 데이터 엔지니어링 차원에서 백엔드 서버 데이터를 정제하고 파이프라인을 짜는 방식을 추구해야 할 것 같습니다.

## 23.06.27.

## 에러 로그

> Uncaught RangeError: Value need to be finite number for Intl.RelativeTimeFormat.prototype.format()

나중에 해결하겠습니다.

## optimistic update 편집, 삭제

생성과 분리하는 이유가 있습니다. id로 원소를 구분하는데 생성 시점에 id가 없습니다. 서버가 붙이는 id와 클라이언트가 생성해서 붙이는 id 사이 불일치합니다.

생성에 대한 로직은 통신 결과가 성공하면 id를 교체하는 방식으로 해결을 시도할 수 있다는 가설이 생겼습니다.

optimistic update는 예전해 구현한 것은 맞지만 문법이 길어서 공식문서를 다시 봐야 합니다.

서버 상태 위주로 관리할 수 있는 상태관리라이브러리면 사실 이것이 간소하고 단순한 편입니다.

태생적으로 서버상태를 관리하려는 것이 아닌데 관리하려고 하면 오히려 문법이 복잡하고 실수하기 쉽고 코드의 결합도가 높아질 수 있습니다.

물론 optimistic update 패턴은 패턴이고 사용자의 체감 성능을 개선하는 것입니다. 진짜 성능개선이 아닌 사용자의 경험을 기만행위 비슷하게 구현하는 것입니다.

모든 패턴에 optimistic update를 적용하면 곤란합니다. auth, 결제는 적용하면 곤란합니다. 오히려 화면에 로더를 표시하고 통신과 동기적으로 처리하는 것이 더 적절합니다. 이런 부분은 보수적으로 접근해야 합니다. 하지만 유저의 댓글, 좋아요 같은 성격의 리소스에 적용해도 문제는 별로 없습니다.

오늘 발견한 것이 있습니다.

```tsx
function component() {
  const queryClient = useQueryClient();
  const { mutate: updateCard } = useMutation({
    mutationFn: updateCardsAPI,
    onMutate: async (cardItem) => {
      await queryClient.cancelQueries({ queryKey: ['cards'] });

      const previousCards: Card[] = queryClient.getQueryData(['cards']) ?? [];

      queryClient.setQueryData<Card[]>(['cards'], (oldCards) => {
        if (oldCards) {
          // 아래 새로운 메모리 주소에 할당하기 위해 새로운 배열을 만들고 복사합니다.
          return [...oldCards].map((card) =>
            card._id === cardItem.id
              ? { _id: cardItem.id, ...cardItem.card }
              : card
          );
        } else return [];
      });
      return { previousCards };
    },
    onError: (_err, _cardItem, context) => {
      if (context) queryClient.setQueryData(['cards'], context.previousCards);
    },
    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: ['cards'] });
    },
  });

  return <div>???</div>;
}
```

react-query의 optimistic update도 UI를 갱신하게 만들려면 참조를 바꿔야 합니다. 마치 setState를 갱신할 때 메모리 참조 비교하는 것과 동일합니다.

그래서 결국 배열을 복사할 수 밖에 없고 복사하는 시간복잡성을 갖을 수 밖에 없습니다.

객체 생성이 자바스크립트에 부담을 줘서 기존과 객체 주소를 동일하게 했었는데 그럴 필요는 없었습니다.
