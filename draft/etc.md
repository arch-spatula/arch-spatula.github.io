# ETC

면접질문 레포 줍줍

[프론트엔드 면접질문 중요도별 정리](https://github.com/Esoolgnah/Frontend-Interview-Questions)

## 클라우드

[AWS 배포 완벽가이드 (feat. Lightsail, Docker, ECS)](https://www.inflearn.com/course/aws-%EB%B0%B0%ED%8F%AC-%EC%99%84%EB%B2%BD%EA%B0%80%EC%9D%B4%EB%93%9C)

## 개발자와 소프트웨어 엔지니어의 차이는 무엇인가?

[Are you a Software Developer or a Software Engineer?](https://cult.honeypot.io/reads/are-you-a-software-developer-or-a-software-engineer/)

## REST API 명세서 작성하기

API 명세서 작성하면

https://covenant.tistory.com/241

URL에 케밥케이스(kebab-case)를 사용하자

```url
[GET] /system-orders
```

이렇게 작성합니다.

## hotfix

hotfix는 이슈에 안 올라온 버그에 대한 커밋입니다.

hotfix 브랜치는 배포 브랜치의 문제를 긴급 고치는 브랜치입니다.

## 빠른 ID 생성함수

```js
// utility for creating unique Id
let id = 0;
function getId() {
  return id++;
}
```

이런 패턴도 존재합니다. 프로덕션에서는 쓰지맙시다.

실행횟수를 알아낼 때도 활용할 수 있습니다.

## eslint 지정

https://velog.io/@xmun74/Next.js-TS%EC%97%90%EC%84%9C-ESLint-Prettier-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0

---

## 게임 개발

### Godot

https://www.youtube.com/watch?v=S8lMTwSRoRg

Godot Game Development – Crash Course for Beginners 

나중에 다시 볼 튜토리얼입니다.

https://docs.godotengine.org/en/stable/getting_started/step_by_step/

세상에 필요없는 코드를 또 싸지를 자료들입니다.

### aseprite

https://aseprite.org/

픽셀아트 툴입니다.

직접 컴파일만 가능하면 무료 툴임(개발자에게는 무료)

## UTM 

https://namu.wiki/w/UTM 

위는 macOS를 위한 운영체제 가상화 툴입니다. NixOS 설치시도를 해보고 싶었습니다. 먼저 연습하고 나중에 부트로더를 만들려고 합니다.

위 시도를 먼저 해보고 macOS에서 마음에 드는 설정을 하면 해당하는 NixOS의 Nix 파일을 활용할 것입니다. 물론 생각에 불과합니다.

Docker에서 사용할 때랑 그리고 듀얼 부트로더로 회사 컴퓨터를 2개의 운영체제를 운용할 수 있으면 현재의 저의 설정을 완전히 재현할 수 있을 것이라는 착각을 할 수 있습니다.

https://nixos.org/download/

위는 패키지 매니져랑 운영체제 설치를 알려줍니다.

## 줍줍 링크 

https://www.yes24.com/Product/Goods/125577754

https://smudge.ai/blog/ratelimit-algorithms

https://product.kyobobook.co.kr/detail/S000001533029

https://devtoys.app/

https://github.com/DevToys-app

https://news.hada.io/topic?id=15445&utm_source=slack&utm_medium=bot&utm_campaign=T056MP5374J

https://github.com/dorklyorg/dorkly

- 피쳐플레그 레포

https://news.hada.io/topic?id=15633

https://pikimov.com/

- 무료 오픈소스 VFX 에디터

https://github.com/marpple/DevUniv

- 파플샵 가상 면접질문

https://youngrok.com/Simple%20Design

- 코드 품질을 다루는 아티클입니다.
- 아티클에 대한 [평가](https://careerly.co.kr/comments/107269?utm_source=slack&utm_medium=bot&utm_campaign=T056MP5374J)도 있습니다.

[어떻게 머신러닝 엔지니어로 피봇할 수 있을까요?](https://news.hada.io/topic?id=15646)

https://github.com/faif/python-patterns

- 파이썬 디자인 패턴을 소개하는 레포입니다.

https://news.hada.io/topic?id=15618

- latex 에디터입니다.

https://news.hada.io/topic?id=15661&utm_source=slack&utm_medium=bot&utm_campaign=T056MP5374J

## 7월에 들었던 생각

- 퇴근하고 연속으로 며칠동안 정보처리시가 책만 봤습니다. 손으로 하는 동작은 무엇을 문제를 풀기 시작할 때 말고 없습니다.
  - 오늘은 자취방에서 소독을 기다리고 있었습니다. 밤에 늦게 잤습니다. 또 소독 기다리면서 정보처리기사 책을 보고 있는데 너무 졸려서 컴퓨터를 켰습니다.
  - 책을 읽으면 졸음이 오는 것은 일종의 장점이자 단점입니다. 잠을 유도하고 싶을 때는 상당히 유용합니다. 문제는 실제로 학습해야 하는 상황에서는 유용하지 않습니다. 
    - 책을 읽으면서 아무런 동작이 없어서 졸리다는 것을 알고 있습니다. 필기하고 문제 풀고 암기할 플래시카드를 중간중간 만드는 활동이 잠을 깨기 유리하게 만드는 것 같습니다.
  - 프로그래밍을 공부할 때도 동일합니다. 공식문서를 그냥 읽는 것보다 예제를 직접 실행하고 풀어보면서 학습하게 됩니다.
- 요즘 드는 생각은 코드 가독성입니다. 코드의 계층과 관심사 분리입니다. 개별상태를 그냥 바꾸기만 합니다. 언제 어느 흐름과 비즈니스 로직 때문에 바꾸는지 코드베이스에서 추적하기 어려운 부분이 있습니다. `getter`랑 `setter`를 직접 사용하지 말라는 말이 이해됩니다.
  - 동료 개발자 중 1명이 타입스크립트를 사용하는데 `any`를 너무 많이 사용합니다. 굳이 따지면 그냥 객체이고 키랑 값이 있는데 정의를 너무 안 했습니다.
    - 코드를 나중에 유지보수해야 하는 관점에서 해당하는 상태 안에 무슨 속성이 있는지 `console.log`를 찍으면서 알아내야 했습니다. 
    - 타입정의가 없으면서 무슨 값, 생태를 담고 표현하려고 했는지 알아내는데 노력이 너무 많이 듭니다.
    - 어떤 경우에는 원래 객체를 담고 있던 타입인데 문자열로 바꾸는 경우도 있었습니다.
    - 필요한 것은 `any`를 사용하면 왜 `any`를 사용할 수 밖에 없었는지 설명을 달도록 하는 것이 더 쉬울 것 같습니다.
  - 플래그 변수를 사용할지 문자열 리터럴로 `enum`을 흉내낼지 결정을 잘해야 합니다.
    - 상태가 2가지라는 이유 때문에 부울을 사용하기 보단 상태가 명시적이라면 그 이름을 사용해서 문자열 리터럴이 더 유리합니다.
    - 문자열 리터럴을 사용하면 나중에 사용할 수 있는 패턴들이 있습니다.
      - 현재 상태를 기준으로 처리할 전략패턴을 사용할 수 있습니다.
      - 유한상태기계 패턴으로 변환도 가능합니다. 어떻게 언제 무엇으로 상태가 바뀔지 유한하게 설계하고 예측가능하게 관심사를 몰아버리는 전략입니다.
  - 너무 많은 계층은 가독성을 해칩니다. 하지만 일반적으로 UI - State - API 계층으로 분리하는게 익숙한 것 같습니다. 이거는 취향문제도 있는 것 같습니다.
    - 백엔드는 최소한 논리적으로 상태가 없습니다. UI도 무상태에 가까울수록 좋고 지역으로 최대한 격리될수록 관리가 쉽습니다.
    - UI에서 발생하는 이벤트가 상태를 갱신하고 상태는 API를 간접호출하게 만드는 전략을 취할 수 있습니다.
      - 일반적인 비즈니스에서는 UI가 제일 많이 바뀝니다. 그리고 비즈니스 로직이 그다음으로 많이 바뀝니다. 하지만 백엔드 API와 관련된 변화는 덜합니다.
      - 이런 멘탈모델은 전통적은 MVC인데 클라이언트 사이드 위주입니다. 이런 설계는 페이지 단위로 실천하기 쉽습니다.
      - 당연히 한계가 있습니다. 일부는 UI에서 발생하는 이벤트가 API를 호출해야 하는 경우들이 있기 때문입니다. 저는 UI 관점에서는 데이터를 채워라 그리고 API 관점에서는 서버에 요청해라 라는 각각 다른 생각을 하면서 작업을 하고 싶습니다. 
  - 회사에서는 데이터가 많고 많은 데이터를 보여주기 때문에 굉장히 많은 비즈니스 로직을 갖고 있는 컴포넌트가 있습니다.
    - 이런 경우는 꽤 흔합니다. 하지만 결론을 못찾았습니다. 결론이라기 보단 해보고 싶은 시도가 있습니다. 그리고 코드 개선에 효과적이라면 알려주는 것이 유리하다고 봅니다. 의존성 주입 패턴을 활용할 방법이 없는지 의문입니다. vue에서는 `provide`, `inject` 를 지원하는데 분명 의존성 주입용도 인 것을 알겠습니다. 지금 회사에서는 상태관리 목적으로 사용을 하고 있습니다. IoC 목적이 아닙니다. 제어를 역전시키기 위해 추상화를 하고 매개변수화하고 주입하는 전략을 모르겠습니다.
    - 주입받을 구체적인 인터페이스부터 정의해야 하는데 아직 못하고 있습니다.
    - 비즈니스 로직이 너무 거대해서 관심사별로 적당한 분리가 필요한 상황입니다.
    - 의존성 주입의 문제는 컨텍스트에 따라 각각 다르게 주입해야 하는데 이 거대한 비즈니스 로직은 그냥 거대하기만 합니다.
  - 코드 그자체가 비즈니스 가치를 창출하지는 않습니다. 코드를 통해 제품이 유저에게 전달되고 유저가 문제를 해결하면서 얼마까지 낼 의향이 있는지 얼마나 유용했는지가 코드의 가치를 정합니다.
    - 너무 재무적인 가치 위주로 생각하기는 했지만 회사입니다. 재무적인 가치로 생각했다고 순현재가치법(NPV)이나 내부수익률법(IRR) 같은 계산법은 적용할 수 없습니다.
    - 비교적 단순한 기능을 추가하려는데 코드베이스의 특정 부분이 아주 복잡한 경우도 있습니다. 이렇게 보면 개발자가 하는 리팩토링의 가치는 상당히 큽니다. 버그를 쉽게 찾고 고치거나 기능을 추가하기 유리한 구조로 코드를 작성해야 합니다.
    - 좋은 코드의 기준 중 하나는 만약에 버그가 발생한다면 어디서 찾을 수 있을지 예측이 쉬운 코드가 좋은 코드 같습니다.
    - 또 다른 좋은 코드의 기준은 변화에 견고한 코드가 좋은 코드 같습니다. 변화에 취약해서 발생하는 버그를 잘 방지할 수 있어야 합니다.
      - CSS도 공통으로 사용하는 요소가 변화하면 최대한 변수화해서 변하는 대상과 같이 변해서 발생가능성을 차단해야 합니다.
- 문제해결이라는 것을 프로그래머의 뇌에서 설명해줬습니다. 의외의 자료입니다.
  - 문제인 현재 상태와 해결인 상태를 정의하고 그 상태가 되게 만드는 여러 경로를 선택하고 수행을 잘하는 것을 보고 문제해결력이라고 볼 수 있습니다. 개발자가 좋아하는 구체적이고 작업 분해를 시도해볼만한 정의입니다. 
  - 이런 관점으로 생각해보면 무엇이 현재 문제인가? 이 정의부터 출발해볼 수 있습니다. 
  - 도달하고자 하는 것이 무엇인지 구체적이라 좋습니다. 도달해야 하는 이유가 비즈니스에서 정의를 잘 했는지 생각해보고 비즈니스 로직을 구현해야 합니다.
- 회사에서는 소프트스킬과 테크니컬한 스킬을 효과적으로 조합하는 것이 중요합니다.
  - 먼제 git & github로 소스관리할 때 전략입니다. 이런 부분은 개발자와 개발자 사이 협업 스킬과 테크니컬 스킬의 조합입니다.
  - 예전에는 소스를 공유하는 수준이었습니다. `commit`, `push`, `pull` 정도 였습니다.
  - 지금은 rebase를 사용하고 필요하면 스쿼시, 채리픽, undo 등 명령을 같이 사용합니다. 가끔은 rebase로 브랜치 이동을 할 때 같이 오는 브랜치의 커밋들을 drop 하기도 합니다. 커밋도 코드의 부분으로 보고 제어를 잘 해야 합니다.
    - 극단적으로는 롤빽을 가정하고 최종적으로 어떤 커밋을 남길지 설계하는 것도 방법입니다. 이렇게까지 코드 작성이 예측가능한 경우는 굉장히 드뭅니다.
  - merge conflict 가 발생하면 git blame 을 잘 확인해봐야 합니다. 그리고 blame과 관련있는 사람이랑 모여서 해결해야 합니다.
  - 회사 비즈니스 도메인 지식을 잘 알아야 합니다. 그래야 코드 작성을 할 때 비즈니스 로직을 표현하려면 비즈니스 도메인 지식이 풍부해야 합니다. 회사에 합격한 시점부터 시작해도 괜찮고 본인의 효과적인 학습 노하우를 갖고 있어야 합니다.
  - 글쓰기는 도구입니다. 사람은 생각을 하고 글을 쓰고 글을 써서 생각을 합니다. 이런 루프를 통해서 무엇을 알고 모르고를 정리합니다. 이런 생각하는 과정을 관련 문서에 기록해두면 나중에 다시 볼 일이 있을 때 아주 가끔은 도움됩니다.
  - 제안하기는 성장을 위해 필요한 행동입니다. 신입일수록 어떤 문제가 보이고 이 문제를 해결할 때 제안을 먼저 시도해보고 잘못된 생각이라는 것을 학습하는 과정을 겪어야 합니다. 이 것이 잘못되었다는 것을 학습하기 위해서는 시켜서 하지말고 제안을 먼저 해보고 본인의 제안이 이상한 부분이 무엇인지 설명을 들어볼 수 있어야 합니다.
    - 제안을 하면서 무엇이 문제인지 인식해보고 정의를 해보는 것부터 연습할 수단입니다.
    - 모든 것을 제안할 필요는 없습니다. 시급성으로 문제가 있어보이는 부분은 바로 말하면 됩니다.

---

https://github.com/currenjin/site-for-developers

- 개발자가 참고하면 좋은 대표적인 웹사이트를 모아놓은 북마크 저장소

## UTM 설치

https://mac.getutm.app/

https://github.com/utmapp/UTM/

의외로 설치는 직관적이었습니다.

## 플랫폼 언어

- nix를 보면서 든 생각은 운영체제 설정을 위한 언어이고 운영체제이고 shell이고 패키지메니져입니다.
- 회사에서는 windows를 운영체제로 사용하고 있습니다.
  - 옛날에는 VBA였던 것 같습니다. 지금은 C#으로 어플리케이션과 백엔드가 구성되어 있습니다.
  - windows 어플리케이션을 만들고 싶으면 C#을 배우는 것이 방법이 될 것입니다.
  - 게임개발을 위해 유니티의 언어이기 합니다.
  - 물론 멀리하고 싶습니다.
- 요즘 자주드는 생각은 swift로 mac 용 노트북, 휴대폰 앱을 직접 만드는 것입니다.
  - 아마 미래에도 노트북을 또 구매하면 mac 북을 구매할 것 같습니다.
    - 물론 WSL에 완전히 적응하고 개인 데스크 탑도 nixos로 구성한다면 thinkpad를 구매할지도 모릅니다.
  - mac용 게임을 직접 만들 수 있지만 모든 것이 애플의 환경에 제한됩니다.
  - 퇴근하고 제일 많이 사용하는 운영체제인데 직접 몇가지 툴을 만들어보고 싶여졌습니다.
- kotlin을 사용하면 안드로이드 애플리케이션과 백엔드를 모두 만들 수 있습니다.
  - 물론 1개의 언어 모바일 프론트엔드 백엔드가 가능합니다. 물론 가능하다고 해도 해야 할 것은 아닙니다.
  - 상당히 유치한 생각입니다.
- 가장 궁극의 플랫폼 언어는 결국 C/C++입니다.

